---
title: 문제 해결 전략 11
tags:
  - algorithm
classes: wide
use_math: true
published: false
---

## 11.1 도입

적절한 분할 방법이 없는 문제는 분할 정복으로 풀 수 없습니다.  
중복되는 부분 문제가 전혀 없거나 메모리가 크면 동적 계획법을 쓸 수 없습니다.  
이렇게 손도 못댈 경우에는 원좀으로 돌아와 완전 탐색으로 해결해야 합니다.  

완전 탐색은 대개 여러 개의 선택으로 나누고 재귀호출로 선택지를 채웁니다.  
이때 부분 답과 완성된 답의 집합을 탐색 공간이라고 부릅니다.  

모든 답을 만들면서 해결하면 수행시간은 탐색공간 크기에 직접 비례합니다.  
그런데 문제에서 탐색공간의 크기는 대부분 기하급수적으로 증가합니다.  

완전 탐색을 포함해 유한한 크기의 탐색공간을 찾는 알고리즘을 조합 탐색이라 부릅니다.  
조합 탐색은 다양한 최적화 방법이 있습니다.  
대부분 최적해가 될 수 없는 답들을 탐색 방지하며 답의 수를 줄여갑니다.  
조합 탐색을 최적화하기위해 어떤 방법을 쓸지는 고려할 게 많습니다.  
문제 자체에 대한 식견, 속도와 정확도간의 상충 관계를 고려합니다.  
이렇게 어려운 문제이기 때문에 조합 탐색에는 정답이 없습니다.  
최적화 기법에는 크게 두 가지로 분류할 수 있습니다.  

- 가지치기: 최적해로 연결될 가능성이 없는 부분 잘라내기  
답의 나머지를 완성했을 때 얻을 수 있는 최상이 기존보다 나쁘면 미리 자르기

- 탐색의 순서를 바꾸거나 탐색 전에 탐욕법으로 적당히 좋은답 우선 찾기  
먼저 좋은 답을 구하고 가지치기를 이용하면 더 효율적입니다.  

## 11.2 조합 탐색 기법들

우선 최적화의 기본이 될 알고리즘의 뼈대를 구현합니다.  
완전 탐색을 다루는 shortestPath()를 가지고 구현합니다.  
기존과 다른 점은 경로읙 길이를 직접 반환하지 않고 전역변수에 갱신합니다.  
전역변수에 저장해두면 가능성 없는 가지를 치기 쉬워집니다.  

가지치기는 되도록 빨리 할수록 수행횟수가 줄어듭니다.  
부분해가 최적해보다 크면 가지치기를 할 수 있지만 거의 다 수행하고 잘라냅니다.  
휴리스틱을 이용하면 적당히 어림짐작으로 훨씬 빠르게 가지치기를 합니다.  
**휴리스틱**은 경험에 의거한 문제 풀이 기법입니다.  
한 상태가 주어질때 어림짐작하는 방법으로 문제를 해결합니다.  
휴리스틱은 어디까지나 그럴듯한 짐작을 돌려줍니다.  
이와 같은 방법은 큰 문제가 있습니다.  
만약 휴리스틱이 실제 필요보다 큰 값을 내놓을 수 있습니다.  
이때 값이 최적해였다면 최적해를 찾지 못한채 끝날 수 있습니다.  
따라서 휴리스틱은 반환값을 실제보다 적거나 같게 반환해야합니다.  
이러한 방법의 문제를 과소평가하는 휴리스틱, 낙관적인 휴리스틱이라 말합니다.  

**휴리스틱 함수 작성하기**

항상 답을 과소평가하는 휴리스틱 함수를 만들기란 쉽습니다.  
한 줄로도 짤 수 있습니다.  
항상 0이라고 대답하는 함수를 만들면 되니까요.  
단 이래서는 탐색에 아무런 도움이 되지 않습니다.  
우리는 항상 항상 실제 답 이하이면서도 가능한한 큰 값을 구하길 원합니다.  
우리는 항상 실제 답 이하이면서도 가능한 한 큰 값을 구하길 원합니다.  
휴리스틱이 큰 값을 반환할수록 더 많은 가지를 칠 수 있으니까요.  
휴리스틱 함수를 만드는 과정은 문제마다 다르기 때문에 정해진 방법이 없습니다.  
다만 좋은 방법 중 하나는 문제의 제약 조건을 없앤 단순한 형태로 풉니다.  

- 남은 도시 전부가 아닌 가장 멀리 있는 도시 하나만 방문했다가 돌아옵니다.
- 남은 도시를 방문하는 방법이 꼭 일렬로 연결된 형태가 아니어도 됩니다.  

**단순한 휴리스틱 함수의 구현**

아직 방문하지 않은 도시들에 대해 인접한 간선 중 가장 짧은 간선 길이를 더합니다.  
아직 방문하지 않은 도시를 방문하려면 인접한 간선 중에 타고 가야합니다.  
이들 중 가장 짧은 간선 길이만 모으면 최단 경로 이하의 값이 됩니다.  

**가까운 도시부터 방문하기**

TSP를 해결하는 조합 탐색은 각 재귀호출마다 어느 도시를 방문할지 결정합니다.  
이때 도시를 번호 순서대로 방문하는 대신 더 가까운 것을 방문하면 빨라집니다.  
멀리 있는 도시 대신 바로 옆에 있는 도시를 택할 때가 유리한 경우가 많습니다.  
이 전략이 최적해를 가져다 주지는 않지만 좋은 답을 발견할 확률이 올라갑니다.  

**지나온 경로를 이용한 가지치기**

앞으로 남은 조각들의 비용을 이용해 예측하는 것만이 방법이 아닙니다.  
지금가지 만든 부분 답을 검사해서 가지치기를 할 수도 있습니다.  
지금까지 만든 경로가 시작상태에서 현재 까지 도달하는 최적이 아니라고 합시다.  
남은 부분에서 아무리 잘해봐야 최적해를 찾지 못할 것입니다.  
물론 현재 상태까지 택한 경로가 최적해인지 알기는 쉽지 않습니다.  
따라서 대개 현자까지 만든 부분에 간단한 조작을 가해봅니다.  
결과적으로 답이 더 좋아진다면 탐색을 중단하게 됩니다.  

TSP문제에서는 두 개의 인접한 도시를 골라 둘의 순서를 바꿔볼 수 있습니다.  
경로가 더 짧아지면 탐색을 중단하는 가지치기를 할 수 있습니다.  
(p, a, b, q) 순서로 이어졌을 때 a, b의 순서를 바꿔봅니다.  
이 때 p-q 구간의 거리가 더 짧아진다면 이 경로에서 최적해를 찾을 수 없습니다.  
두 개의 순서만 바꿔서 확인해도 성능이 나옵니다.  
좀 더 일반화하면 전체 경로의 일부분을 뒤집어서 확인할 수 있습니다.  

**MST 휴리스틱을 이용한 가지치기의 구현**

위의 내용들만으로도 간단한 최적화는 거의 다했습니다.  
좀더 현실에 가까운 답을 계산하는 휴리스틱 알고리즘이 있다면 도움이 됩니다.  
지금은 문제의 제약을 너무 많이 없애다 보니 답을 너무 과소평가합니다.  
현재 단순한 휴리스틱에서는 가장 가까운 간선을 골라 만듭니다.  
그래서 선택하지 않은 간선들을 연결하고 있지 않습니다.  
즉 중복으로 세고 있는 간선들이 있습니다.  
최소 스패닝 트리를 이용하면 항상 최단 경로보다 작지만 경로를 모두 포함합니다.  

**마지막 단계 메모리제이션하기**

조합 탐색 과정에서 같은 상태를 두번 이상 맞닥뜨리는 것은 흔한 일입니다.  
이런 비효율을 메모리제이션으로 제거하는 것이 좋겠다는 아이디어가 떠오릅니다.  
물론 대부분의 경우 메모리제이션을 그냥 사용하기에 메모리가 부족합니다.  
이 문제를 해결하기 위해, 남은 조각의 수가 정해둔 수 k 이하일때만 사용합니다.  
물론 가지치기를 사용하는 함수는 쉽게 메모리제이션을 할 수 업습니다.  
메모리제이션을 하기 위해서 함수의 반환값이 현재의 상태에 영향을 받습니다.  

## 11.3 문제: 게임판 덮기 2

H X W 크기의 게임판과 한 가지 모양의 블록이 여러개 있습니다.  
게임판에 가능한 한 많은 블록을 올려 놓으려합니다.  
게임판은 검은 칸과 흰 칸으로 구성되며, 흰 칸에만 올려놓을 수 있습니다.  
블록들은 자유롭게 회전할 수 있지만, 서로 겹치거나 어긋날 수 없습니다.  
게임판과 블록의 모양이 주어질 때 최대 몇 개의 블록을 놓을 수 있을까요?  

## 11.4 풀이: 게임판 덮기 2

문제를 해결할 때 문제점은 최적화입니다.  
구현의 뼈대는 이전과 마찬가지로 빈칸 중 가장 윗줄에 왼칸부터 채워나갑니다.  
이전 문제와 또 다른 점은 블록의 모양이 정해져 있지 않습니다.  
입력에 따라 달라지는데 기존과 다르게 모양에 중복이 생길 수 있습니다.  
무조건 4개가 아니라 중복되는 모양을 제거하면 시간이 줄어들게 됩니다.  

**가지치기**  

지금까지 찾은 최적해가 더 많은 블록을 낼 수 있는지 알아야 합니다.    
그렇지 않으면 가지치기를 할 수 없습니다.  
이렇게 가장 큰 답을 찾는 최적화 문제에서 낙관적인 휴리스틱은 과대평가합니다.  
이런 휴리스틱 함수를 만드는 쉬운 방법은 블록을 통쨰로 내려놓는 걸 포기합니다.  
즉 한 칸씩 조개서 놓을 수 있도록 문제를 변경합니다.  
그러면 우리가 놓을 수 있는 블록이 수는 남은 빈칸의 수를 블록 크기로 나눕니다.  
이 값은 항상 우리가 실제로 놓을 수 있는 블록의 수 이상입니다.  

## 11.5 문제: 알러지가 심한 친구들

집들이에 n 명의 친구를 초대하려고 합니다.  
할 줄 아는 m 가지의 음식 중 무엇을 대접해야 할까를 고민하는데,  
친구들은 각각 알러지 때문에 못 먹는 음식들이 있어서 아무 음식이나 해서는 안 됩니다.  
만들 줄 아는 음식의 목록과,  
해당 음식을 못 먹는 친구들의 목록이 다음과 같은 형태로 주어진다고 합시다.  

친구	갈비찜	피자	잡채	떡볶이	탕수육	닭강정  
채린	x	o	o	o	x	x  
봄	  x	x	x	x	o	o  
다라	o	x	o	x	o	x  
민지	o	o	x	x	x	o  

각 친구가 먹을 수 있는 음식이 최소한 하나씩은 있도록 하려면 최소 몇 가지의 음식을 해야 할까요?   
위 경우라면 다 같이 먹을 수 있는 음식이 없기 때문에 결국 두 가지 이상 음식을 해야 합니다.   
피자와 탕수육, 혹은 잡채와 닭강정처럼 두 개 이상의 음식을 선택해야만 모두가 음식을 먹을 수 있지요.  
친구들의 정보가 주어질 때 최소한 만들어야 하는 요리의 가지수를 계산하는 프로그램을 작성하세요.

## 11.6 풀이: 알러지가 심한 친구들

이 문제는 집합 덮개라고 부른 문제로, NP 완비 문제 중 하나입니다.  
NP 완제 문제는 다항 시간안에 푸는 방법이 없다는 것입니다.  
이 문제를 푸는 방법 자체는 굉장히 간단합니다.  
모든 경우의 수를 한하나 만들어보는 것입니다.  
음식의 가지수가 m종류가 있으니 2^m가지의 수가 있습니다.  

**너무 느리다!**

문제는 단순한 완전탐색으로는 m이 최댓값인 경우 대략 백만개의 상태를 탐색합니다.  
시간 내에 동작할 것 같지만 안될 수 있습니다.  
이때 최적화 기법을 통해 시간을 단축할 수 있습니다.  

- 다음으로 만들 음식을 고를 때 아직 먹을 음식이 없는 친구들 중 가장 많은 사람이 먹을 수 있는 음식
- 휴리스틱을 이용한 가지치기 해보기
- 아직 먹을 음식이 없는 친구들의 수가 적은 경우들을 메모리제이션으로 해결
- 음식 a를 먹을 수 있는 친구들의 목록이 음식 b를 먹을 수 있는 목록을 포함할 때 음식 b 제외하기
- 탐욕적 알고리즘으로 적절한 초기해 만들기

이런 최적화를 통해 수행시간을 제한 안으로 최적화할 수 있습니다.  
하지만 더 간단한 방법은 탐색의 형태를 바꾸는 것입니다.  
각 음식을 만들 것인가 여부를 선택하는 대신 재귀 호출마다 아직 먹을 음식이 없는 친구를 찾습니다.  
이 친구를 위해 만들 음식을 결정합니다.  

**왜 더 빠른가?**

이와 같이 탐색의 방향을 바꾸면 별다른 최적화 없이도 빨라집니다.  

- 항상 모든 친구가 먹을 음식이 있는 조합만 찾게 됩니다.  
- 한번 호출될 때마다 항상 음식을 하나 만들게 됩니다.  
  즉 무조건 깊이가 m인 완전탐색과 달리 낮아질 수 있습니다.  
- 음식을 만드는 경우는 무조건 필요한 사람이 있다는 의미입니다.  

**더 최적화 하기**

- 아직 먹을 것이 없는 첫번째 친구가 아닌 먹을 수 있는 음식의 종류가 적은 친구를 찾습니다.  
  두 가지 음식을 먹는 친구를 결정하는 것이 열 가지 음식을 먹는 친구를 고르기보다 쉽습니다.  

- 음식을 선택할 때, 가장 많은 사람이 먹을 수 있는 음식부터 시도합니다.

## 11.7 문제: 카쿠로

카쿠로는 흔히 수학으로 하는 십자말풀이라고 하는 논리 퍼즐입니다.  
정삭가형의 게임판에서 각 칸은 흰칸이거나 검은칸이거나 대각선입니다.  
대각선은 힌트 칸으로 대각선 반 부분에 숫자가 쓰여져 있습니다.  
모든 흰 칸에 적절히 숫자르 채워 넣어 다음과 같은 규칙을 만족시킵니다.  

- 모든 흰 칸에는 1부터 9까지의 정수를 써넣어야합니다.  

- 세로로 연속된 흰 칸들의 수를 모두 더하면 그 칸들의 바로 위에 있는 힌트 칸의 왼쪽 아래 숫자가 나옵니다.  

- 가로로 연속된 흰 칸들의 수를 모두 더하면 그 칸들의 바로 왼쪽에 있는 힌트의 오른쪽 위가 나옵니다.  

- 이때 한줄을 이루는 연속된 흰 칸들에는 같은 수를 두번 넣을 수 없습니다.  

## 11.8 풀이: 카쿠로

제대로 만든 카쿠로 퍼즐에는 항상 답이 하나 뿐입니다.  
즉 최적화 문제가 아닙니다.  
카쿠로는 특정한 제약에 해당하는 답을 찾는 **제약 충족 문제**입니다.  
스도쿠, n-퀸 문제등이 제약 충족 문제의 다른 예입니다.  
제약 충족 문제에는 더 좋은 답과 나쁜 답의 개념이 없습니다.  
따라서 최적화 문제를 풀 때 썼던 많은 기법들은 해당되지 않습니다.  
제약 충족 문제를 해결하는 조합 탐색 알고리즘에서는 크게 두 가지만 신경 쓰게 됩니다.  

**제약 전파**

일일이 시도해보지 않아도 답의 일부를 생성하면 조건에 의해 나머지 조각이 채워질 수 있습니다.  
이렇게 문제의 조건에 의해 다른 조각의 답에 대해 알게 되는 것을 제약 전파라고 합니다.  

제약 전파가 항상 다른 조각의 답을 정확하게 알아내는 것은 아닙니다.  
다만 조건으로 인해 어떤 수가 못들어가는 것을 아는 것도 제약 전파라고 합니다.  
다르게 말하면 제약 전파는 답의 일부를 생성한 뒤에 얻을 수 있는 정보를 많이 찾아내는 것입니다.  
이 방법을 이용하면 실제 탐색 공간의 수가 크게 줄어듭니다.  

**채울 순서 정하기**

채워야 할 칸이 적은 힌트 쪽을 먼저 푸는 것이 좋아보입니다.  
이유는 더 했을 때 어떤 수가 나오는 수가 현저히 줄어듭니다.  
두 개의 수를 더했을 때 나오는 경우의 수는 수가 클수록 급격히 줄어듭니다.  
하지만 그 이상의 수는 여전히 많이 나옵니다.  

따라서 채울 순서를 잘 정하면 답을 더 빨리 찾을 수 있습니다.  
정확히 말하면 순서 정하기는 두 가지로 나뉩니다.  
변수 순서 정하기로 어느 빈 칸부터 채워나갈지 결정합니다.  
값 순서 정하기는 빈 칸에 어떤 숫자부터 채워나갈지 결정합니다.  

이외에도 문제를 해결하는 전략들이 있을 수 있습니다.  
다행히 제약 충족 문제들은 위의 두가지만 충실히 구현하면 대부분 시간내에 풀립니다.  

**후보의 수 계산하기**

변수 순서 정하기를 위해 흔히 쓰는 좋은 방법이 있습니다.  
해당 칸에 들어갈 수 있는 후보의 수가 가장 적은 칸부터 채워나가는 것입니다.  
카쿠로에서는 힌트가 적힌 숫자와 해당하느 칸의 수, 그리고 이미 적힌 수들을 쉽게 알 수 있습니다.  

**후보의 수 빠르게 계산하기**

getCandiates()는 부분 함수임에도 너무 많은 연산이 필요합니다.  
이런 경우 두 번 이상 계산하지 않도록 메모리제이션하거나 미리 계산해두면 유리합니다.  
