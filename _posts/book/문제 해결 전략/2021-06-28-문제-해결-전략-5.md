---
title: 문제 해결 전략 5
tags:
  - algorithm
classes: wide
published: false
---

## 5.1 도입

**알고리즘의 정당성 증명**

알고리즘이 문제를 제대로 해결하나 어떻게 알까요?   
단위테스트를 이용해 여러 입력으로 확인해 볼 수 있습니다.   
이 경우 문제가 있음을 증명할 수 있습니다.   
하지만 문제가 없다는 것을 증명할 수는 없습니다.   
따라서 정확한 증명을 위해서는 수학적 기법이 필요합니다.

증명이 필요한 이유는 알고리즘을 유도하는데 통찰을 담고 있습니다.   

## 5.2 수학적 귀납법과 반복문 불변식
100개의 도미노가 순서대로 놓여있습니다.  
우리가 두 가지 사실을 안다고 가정합니다.   

- 첫 번째 도미노는 직접 손으로 밀어 쓸어트린다.
- 한 도미노가 쓰러지면 다음 도미노는 반드시 쓰러진다.

그러면 마지막 도미노는 반드시 쓰러지게 됩니다.   
수학적 귀납법은 이와 같은 반복적인 구조를 증명합니다.   
귀납적 증명은 세 단계로 나누어집니다.

- 단계 나누기: 증명하고 싶은 사실을 여러 단계로 나눕니다.
- 첫 단계 증명: 첫 단계에서 증명의 성립을 보입니다.
- 귀납 증명: 하나가 성립하면 다음 단계도 성립함을 보입니다.

사다리 게임을 예로 들어보겠습니다.   
사다리 게임에서 어떻게 맨 위와 아래가 1대1 매칭이 될까요?

- **단계 나누기**   
    텅 빈 N개의 세로줄에서 시작합니다.   
    원하는 사다리가 될 때 하나씩 가로 줄을 긋습니다.

- **첫 단계 증명**   
    텅 빈 N개의 세로 줄에서 위와 아래는 1대1 매칭 됩니다.

- **귀납 증명**   
    가로줄을 그어 두 개의 세로줄이 연결되었습니다.   
    이 때 세로 두 줄의 결과는 바뀌게 됩니다.   
    결과가 바뀌어도 1대1 매칭이 유지되는 것을 확인했습니다.

### 반복문 불변식
알고리즘은 대부분 반복 요소가 있기에 **귀납법**은 자주 쓰입니다.   
이 때 **반복문 불변식**이 유용하게 쓰입니다.   
반복문의 내용이 한 번 실행될 때마다 중간 결과가 나옵니다.   
결과가 우리가 원하는 답 위에 잘 있는지 명시하는 조건입니다.   
반복문이 마지막에 정답을 계산하려면 이 식이 변하면 안됩니다.

1. 반복문 진입시에 불변식이 성립함을 보인다.
2. 반복문 내용이 불변식을 깨트리지 않음을 보인다.
3. 반복문 종료 시에 불변식이 성립하면 정답을 구한 것이다.

**이진 탐색과 반복문 불변식**
```java
// list[-1] 은 -INF, list[size]는 INF로 가정
int binsearch(LinkedList<Integer> list, int x){
    int size = list.size();
    int lo = -1, hi = size;

    // 반복문 불변식 1: lo < hi
    // 반복문 불변식 2: A[lo] < x <= A[hi]
    // 여기부터 불변식이 성립
    while(lo + 1 < hi){
        System.out.println("lo : " + lo + " hi : " + hi);
        int mid = (lo + hi) / 2;
        if(list.get(mid) < x)
            lo = mid;
        else
            hi = mid;
        // 끝날때도 성립
    }

    return hi;
}
```

while문은 두 개의 불변식을 유지합니다.   
첫 번째는 lo < hi입니다.    
두 번쨰는 A[lo] < x <= A[hi]입니다.     
그렇다면 만족하는 사실이 있습니다.

- lo + 1 = hi: while문이 종료할 때 lo + 1 >= hi입니다.      
    불변식이 만족하고 있으니 lo < hi 로 lo + 1 = hi입니다.

즉 반복문의 정당성은 다음과 같이 증명할 수 있습니다.

**초기 조건**   

while문이 시작될 때 lo = -1, hi = size 입니다.   
size가 0이더라도 조건 1은 만족하고, while문은 건너뜁니다.  
list[-1]은 -INF, list[size]는 INF로 조건 2도 만족합니다.

**유지 조건**

    **조건 1**

    while문 내부가 불변식이 깨트리지 않는 것을 보여줍니다.   
    while문 내부에 들어왔으면 lo와 hi는 2 이상 차이납니다.   
    mid는 중간 값으로 mid에 lo, hi 상관 없이 1은 만족합니다.

    **조건 2**

    lo나 hi가 mid로 바뀌어도 조건 2를 만족합니다.

## 5.3 귀류법

기차에 규정 인원보다 많은 인원이 예약했습니다.   
역을 지날 때마다 더 탑승하면 문제가 생깁니다.   
이 때 어느 승객을 빼는 게 최선일까요?   
바로 가장 멀리 가는 사람들입니다.   
이 질문을 답하기 위해선 반대로 가정해봐야 합니다.   
빨리 내리는 사람은 내쫓아도 멀리 가는 사람은 남아있습니다.   
결국 새로운 사람이 타면 인원이 초과되는 건 마찬가지입니다.   
이런 식으로 반대로 가정하는 방법이 **귀류법** 입니다.

**책장 쌓기**
책장을 여러 개 쌓아 올리려고 합니다.   
각 책장마다 버틸 수 있는 무게 M과 자신의 무게 W가 주어집니다.   
이 때 가장 높이 쌓으려면 몇 개나 쌓을 수 있을까요?   
단 책장 위에 쌓은 W의 합은 M을 넘어서는 안됩니다.   
이 문제를 풀려면 먼저 어떤 순서로 쌓을지 고민해야 합니다.

W순으로 정렬해야할까요? M순으로 정렬해야 할까요?   
답은 W+M이 큰 것부터 아래에 놓아야 합니다.   
이를 증명하기 위해 귀류법을 사용합니다.  
W+M이 더 큰 책장 a가 더 작은 책장 b 위에 있습니다.   
이 때 두 책장을 항상 바꿀 수 있다면 가정이 맞습니다.
> Ma + Wa > Mb + Wb   

둘을 바꿔도 Ma가 버티는 걸 보여주기 위해 Ma만 남깁니다.
> Ma > Mb + Wb - Wa   

Mb가 아래 있으면 Wa와 그 위 X를 견딘다는 의미입니다.
> Ma > Mb + Wb - Wa >= (Wa + X) + Wb - Wa

Wa를 제외하면 다음이 남습니다.
> Ma > X + Wb

이 말은 Ma는 X+Wb를 버틸 수 있다는 의미이지요.   
즉 a와 b를 언제나 바꿔도 무관하다는 말입니다.

## 5.4 다른 기술들

### 비둘기집의 원리
비둘기 집의 원리는 다음과 같습니다.
> 10마리의 비둘기가 9개의 비둘기 집에 있다.     
    그렇다면 2마리 이상 있는 비둘기집은 반드시 존재한다.

### 동전 뒤집기
100개의 동전이 있을 때 F개는 앞면, 100-F개는 뒷면입니다.   
동전들을 모두 앞면으로 바꾸려고 합니다.   
한 번 뒤집을 때 X개의 동전을 뒤집어야합니다.   
같은 동전을 두 번 뒤집는 것은 상관없습니다.   
최소로 동전을 뒤집으려면 답의 상한은 얼마일까요?

답은 100입니다.   
동전을 뒤집을 때마다 앞면의 개수를 적는다고 합시다.   
답에서 동전을 101번 뒤집는 경우 F까지 합쳐 102개를 적게 됩니다.   
이는 0~100까지 101개를 넘어가므로 중복이 있다는 뜻입니다.

### 순환 소수 찾기
분수 a/b가 있는 경우 실수 연산이 아닌 소수로 출력합니다.   
3/8의 경우 0.375 처럼 말이지요.     
그런데 1/11의 경우 0.090909..로 계속 반복됩니다.   
이럴 때 무한 소수라는 사실을 어떻게 알까요?   
나눗셈을 할 시 a = (a%b) * 10을 반복하게 됩니다.   
이 때 a%b는 [0...b-1] 범위의 값을 갖습니다.   
즉 b+1번 반복되도 종료되지 않으면 순환 소수입니다.

### 구성적 증명
여태까지는 안되면 안된다는 걸 증명해 보였습니다.   
다음은 만들어서 예를 들어 답을 제시하는 것입니다.   
하늘을 날 수 있는 교통 수단을 만들 수 있는 것을 증명합니다.   
모든 물리 법칙에서 된다는 걸 증명하기 어렵습니다.   
비행기를 만들어 실제로 보여주는 방법입니다.

### 안정적 결혼 문제 
n명의 여성과 남성이 단체 미팅을 합니다.   
게임을 진행하는 동안 우선순위를 맘 속에 정했습니다.   
남자 여자 1호끼리, 남자 여자 2호끼리 짝이 되었습니다.   
그런데 남자 1호는 여자 2호를 더 선호했습니다.   
남자 2호도 여자 1호를 더 선호했습니다.   
이런 일이 안생기려면 어떤 방법이 있을까요?

이를 안되는 경우가 없다는 걸 증명하긴 어렵습니다.   
다만 되는 경우를 만들어서 보여줄 수 있습니다.

1. 처음에 여성이 자신이 선호하는 남성 앞에 섭니다.
2. 남성이 가장 맘에 드는 여성을 고르고 나머지는 돌아갑니다.   
3. 다음으로 마음에 드는 남성 앞에 섭니다.  
4. 남성은 더 마음에 드는 여성인 경우 교체합니다.   
5. 여성이 남지 않을 때까지 3,4번을 반복합니다.   

**종료 증명**

각 여성은 최대 n명 앞에 서고 종료합니다.

**모든 사람이 짝을 찾는지 증명**

남성은 반드시 한 명은 선택하게 됩니다.   
더 우선순위가 높은 여성이 온 경우 교체할 수 있습니다.   
짝에 실패하면 더 낮은 순위로 내려가다보면 다 짝이 됩니다.

**짝들의 안정성**

두 남녀가 서로 자신의 짝보다 더 맞는 사람이 있을까요?   
여성은 우선순위대로 짝을 시도해보게 됩니다.  
즉 짝이 안되었으면 이미 떨어졌다는 이야기입니다.   
남성의 경우 더 맘에 들면 교체할 수 있습니다.   
그런데 교체하지 않았다는 건 우선순위가 높은 쪽입니다.

