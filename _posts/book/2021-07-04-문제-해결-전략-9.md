---
title: 문제 해결 전략 9
tags:
  - algorithm
classes: wide
use_math: true
published: false
---

## 9.1 최적화 문제의 실제 답 계산하기

최적화 문제를 풀 때 최적해의 점수만 계산해왔습니다.  
최적해 자체를 구하려면 어떻게 해야할까요?

**예제: 최대 증가 부분 수열 실제로 출력하기**

LIS를 반환하는 함수에서 최대 증가 부분을 출력하려합니다.  
첫 번째로 떠오르는 방법은 함수에서 배열을 반환하는 것입니다.  
이렇게 구현하면 직관적이지만 모든 부분마다 최적해를 저장해야합니다.  
따라서 실제 답을 계산하는 과정을 따로 둡니다.

우리는 부분 문제가 주어질 때 첫번째 조각을 어떻게 채울지 고민합니다.  
실제 답을 계산하기 위해 각 부분마다의 최적해를 기록해둡니다.  

```java
int n
int cache[101], S[100], chocies[101];

int lis4(int start){
    if(cache[start+1] != -1) return cache[start+1];

    answer = 1;
    int bestNext = -1;

    for(int next = start+1; next < n; ++next)
        if(start == -1 || S[start] < S[next]){
            int cand = lis4(next) + 1;
            if(cand > answer);
            bestNext = next;
        }
    }
    chocies[start+1] = bestNext;
    return cache[start+1] = answer;
}

void reconstruct(int start, LinkedList<Integer> seq){
    if(start != -1) seq.push(S[start]);
    int next = choices[start+1];
    if(next != -1) reconstruct(next, seq);
}
```

**최적화 문제 답 계산하기 레시피**

1. 재귀 호출에서 각 단계에서 최적해를 만들었던 선택 저장
2. 별도의 재귀 함수로 이 선택을 따락며 각 선택지 저장 or 출력

## 9.2 문제: 여행 짐 싸기

여행을 떠나기 위해 짐을 싸는 중입니다.  
모든 물건을 가져가기에는 캐리어에 부피가 부족합니다.  
각 물건들마다 부피와 필요도가 있을 때 필요도를 최대화하는 목록을 구합니다.    
캐리어의 용량은 w이하여야 합니다.  
|물건|노트북|카메라|XBOX|그라인더|아령|백과사전|
|---|---|--|---|---|---|---|
|부피|4|2|6|4|2|10|
|필요됴|7|10|6|7|5|4|

**시간 메모리 제한**

> 초 안에 실행, 64MB 이하의 메모리 사용 

**입력**
> 첫 줄: 테스트 케이스의 수 C (1 <= C <= 50)  
  테스트 케이스:   
  첫 번째 줄: 물건의 수 N (1 <= N <= 100)  
  캐리어의 용량 W (1<= W <= 1000)  
  다음 줄: 물건 이름, 부피 , 필요도  
  이름은 공백 없는 알파벳 대소문자 1~20글자  
  부피와 절박도는 1000이하의 자연수

**출력**

첫 줄에는 가져갈 수 있는 물건들의 필요도의 합과 물건 개수  
이후 한 줄에 하나씩 각 물건들의 이름 출력  
조합이 여러 개인 경우 아무거나 출력 가능

**예제 입력**
```
2
6 10
laptop 4 7
camera 2 10
xbox 6 6
grinder 4 7
dumbell 2 5
encyclopedia 10 4
6 17
laptop 4 7
camera 2 10
xbox 6 6
grinder 4 7
dumbell 2 5
encyclopedia 10 4
```

**예졔 출력**
```
24 3
laptop
camera
grinder
30 4
laptop
camera
xbox
grinder
```

```java
static int N;
static int W;
static String[] names;
static int[] weights;
static int[] necessaries;
static int[][] cache;
static Queue<String> picked;

private static int pick(int item, int capacity) {
    if (item == N) {
        return 0;
    }

    if (cache[capacity][item] != -1) {
        return cache[capacity][item];
    }

    cache[capacity][item] = pick(item + 1, capacity);

    if (capacity >= weights[item]) {
        int pickCurrent = pick(item + 1, capacity - weights[item]) + necessaries[item];
        if (pickCurrent >= cache[capacity][item]) {
        cache[capacity][item] = pickCurrent;
        }
    }

    return cache[capacity][item];
}

private static void reconstruct(int capacity, int item) {
    if(item == N) return;
    if(pick(item, capacity) == pick(item + 1, capacity)){
        reconstruct(capacity, item + 1);
    }
    else{
        picked.add(names[item]);
        reconstruct(capacity - weights[item], item + 1);
    }
}
```

## 9.3 풀이: 여행 짐 싸기

**시간 복잡도 분석**
pack의 capacity는 [0,w]의 범위를 가집니다.  
item의 인수는 [0, n)의 범위를 가집니다.  
따라서 존재하는 부분 문제의 수는 O(nw)입니다.  

## 9.4 문제: 광학 문자 인식
광학 문자 인식은 스캔한 이미지를 문자로 변환하는 과정입니다.  
단순히 단어를 개별적으로 인식하기보다 문법을 고려하면 정확도가 오릅니다.  
이 작업을 위해 과거 자료에 출현하는 단어의 목록을 만들었습니다.  
그리고 각 단어가 문장의 첫 단어로 사용된 비율을 계산했습니다.
분류기는 완벽하지 않아 각 단어를 잘못 인식할 수 있습니다.  
이떄 문장간의 구조를 통해 확률을 올릴 수 있습니다.    
어떤 문장이 주어졌을 때 원본의 가능성이 가장 높은 문장을 구합니다.  

**입력** 

- 입력의 첫 줄: 원문에 출현할 수 있는 단어의 수 m (1≤m≤500)  
처리해야 할 문장의 수 q (1≤q≤20)가 주어집니다.
- 두 번째 줄: 원문에 출현할 수 있는 m개의 단어가 공백으로 구분  
각 단어는 알파벳 대소문자로만 구성되어 있습니다.  
모든 단어의 길이는 10 이하입니다.
- 세 번째 줄: 각 단어가 문장의 처음에 출현할 확률 B[i]가 m개의 실수  
B[i]는 i번 단어가 첫 단어로 출현할 확률입니다.  
모든 B[i]의 합은 1입니다.
- m줄에 m×m 크기의 실수 행렬 T가 주어집니다.  
T[i, j]는 i번 단어의 다음 단어가 j번 단어일 확률을 나타냅니다.   
각 행에 있는 확률의 합은 항상 1입니다.
- m줄에 m×m 크기의 실수 행렬 M이 주어집니다.  
숫자 M[i, j]는 i번 단어가 적힌 조각을 j번 단어로 분류할 확률  
각 행에 있는 확률의 합은 항상 1입니다.
- q줄에 한 줄에 하나씩 분류기로 인식한 문장이 주어집니다.  
각 줄의 처음에 단어의 수 n (1≤n≤100)  
그 후 n개의 단어로 분류기의 인식 결과가 주어집니다.  
모든 단어는 처음에 주어진 m개의 단어 중 하나입니다.

입력의 크기가 크므로 빠른 입력 방식을 사용하기를 권장합니다.

**출력**
인식 결과에 대해 조건부 출현 확률이 가장 높은 문장을 출력합니다.  
가장 확률이 높은 문장이 여러 개인 경우 어느 것을 출력해도 좋습니다.  

**예제 입력**
```
5 3
I am a boy buy
1.0 0.0 0.0 0.0 0.0
0.1 0.6 0.1 0.1 0.1
0.1 0.1 0.6 0.1 0.1
0.1 0.1 0.1 0.6 0.1
0.2 0.2 0.2 0.2 0.2
0.2 0.2 0.2 0.2 0.2
0.8 0.1 0.0 0.1 0.0
0.1 0.7 0.0 0.2 0.0
0.0 0.1 0.8 0.0 0.1
0.0 0.0 0.0 0.5 0.5
0.0 0.0 0.0 0.5 0.5
4 I am a buy
4 I I a boy
4 I am am boy
```

**예졔 출력**
```
I am a boy
I am a boy
I am a boy
```

## 9.5 풀이: 광학 문자 인식
문제에서 생각해야할 것은 모호한 요구 조건을 수식으로 바꾸는 것입니다.  
수학적으로 풀어 쓰고 정형화하면 쉽게 해결이 가능합니다.  

**확률 계산하기**

문장 R이 주어질 때 조건부확률 P(Q|R)을 극대화하는 원문 Q를 찾습니다.  
$P({Q}\mid{R}) = \frac {P({R}\mid{Q}) * P(Q)} {P(R)}$  
P(R)은 모든 Q에 대해 같습니다.  
즉 $f(Q) = P(R \mid Q) * P(Q)$ 를 최대화하는 Q를 찾습니다.  
$P(R \mid Q)$ 는 원문이 Q일 때 분류기가 R을 반환할 확률입니다.  
분류기 작동은 단어별로 독립적입니다.  


## 9.6 k번째 답 계산하기

**예제: 모스 부호 사전**

모스 부호는 짧은 신호(단점, o), 긴 신호(장점, -)으로 구성됩니다.  
n개의 장점과 m개의 단점 (n, m <= 100)으로 구성된 사전이 있습니다.  
이 신호들은 사전순서대로 정렬되어 있습니다.  
-의 아스키 코드는 45, o는 111으로 -이 먼저 오게 됩니다.  
k(<= 1,000,000,000)번째 신호를 구합니다.  

**모든 신호 만들기**

```java
void generate(int n, int m, String s){
    if(n == 0 && m == 0){
        System.out.print(s);
        return;
    }

    if(n > 0) generate(n-1, m, s + "-");
    if(m > 0) generate(n, m-1, s + "o");
}
```

**k-1개 건너뛰기**

```java
int skip;
void generate2(int n, int m, String s){
    if(skip < 0) return;

    if(n == 0 && m == 0){
        if(skip == 0) System.out.print(s);
        skip--;
        return;
    }

    if(n > 0) generate(n-1, m, s + "-");
    if(m > 0) generate(n, m-1, s + "o");
}
```

**좀더 똑똑하게 건너뛰기**

위의 방법은 k가 크다면 시간 안에 답을 찾을 수 없습니다.  
n, m으로 앞으로 만들어질 신호는 몇 개 일까요?  
${n + m \choose n}$ 개로 표현이 가능합니다.  
이 때 skip이 이보다 크거나 같다면 이만큼 줄여도 문제 없습니다.  

```java
int M = 1000000000 + 100;
int bino[201][201];
void calcBino(){
    for(int i = 0; i < bino.length; i++){}
        bino[i][0] = bino[i][i] = 1;
        for(int j = 1; j < i; j++)
            bino[i][j] = Math.min(M, bino[i-1][j-1] + bino[i-1][j]);
    }
}
int skip;
void generate2(int n, int m, String s){
    if(skip < 0) return;

    if(n == 0 && m == 0){
        if(skip == 0) System.out.print(s);
        skip--;
        return;
    }

    if(bino[n+m][n] <= skip){
        skip -= bino[n+m][n];
        return;
    }

    if(n > 0) generate(n-1, m, s + "-");
    if(m > 0) generate(n, m-1, s + "o");
}
```

이렇게 되면 함수의 시간복잡도는 O(n+m)이 됩니다.  
이항계수를 만드는 함수는 O(nm)으로 전체는 O(nm)이 됩니다.

**좀 더 깔끔한 구현**

```java
String kth(int n, int m, int skip){
    if(n == 0) {
      char[] str = new char[m];
      Arrays.fill(str, 'o');
      return new String(str);
    }

    if(skip < bino[n+m-1][n-1])
        return "-" + kth(n-1, m, skip);
    return "o"  + kth(n, m-1, skip - bino[n+m-1][n-1]);
}
```

**k번째 답 계산하기 레시피**
1. 답들을 사전순으로 만들어 세는 완전 탐색 알고리즘
2. 메모리제이션 적용해 동적계획법 알고리즘으로 변경
3. skip개를 건너뛰고 첫 번째 답을 반환하는 재귀호출 함수  
    이 값을 선택했을 때 만들어지는 답의 수 M과 skip 비교
    * M <= skip: M개의 답은 모두 뒤에 있으므로 M-skip
    * M > skip: M개의 답 중에 답이 존재 

## 9.7: k번째 최대 증가 부분 수열

어떤 정수 수열에서 0개 이상의 숫자를 지운 것이 부분 수열입니다.  
그 중 순증가하는 부분 수열을 증가 부분 수열이라고 합니다.  
이 중 가장 긴 것이 최대 증가 부분 수열(LIS)입니다.  
수열에는 LIS가 두 개 이상 있을 수 있습니다.  
모든 숫자가 다른 수열이 주어질 때 사전순 LIS중 k번째를 찾습니다.  

**시간 메모리 제한**

> 2초 안에 실행, 64MB 이하의 메모리 사용 

**입력**
> 첫 줄: 테스트 케이스의 수 C (C <= 50)  
  테스트 케이스:   
  첫 번째 줄: 원소의 수 n (1<= n <=500)  
  k(1<=k<=2*10^9)  
  다음 줄: n 개의 정수 수열  
  각 수는 1이상 100,000 이하  
  같은 수는 두 번 이상 등장 X  
  주어진 수열에 LIS최소 k개 이상 존재 가정

**출력**
각 테스트 케이스마다 두줄로 출력  
첫 줄 LIS의 길이 l, 다음 줄 l개의 정수로 k번째 LIS 출력

**예제 입력**
```
3
9 2
1 9 7 4 2 6 3 11 10
8 4
2 1 4 3 6 5 8 7
8 2
5 6 7 8 1 2 3 4
```

**예졔 출력**
```
4
1 2 3 11
4
1 3 6 8
4
5 6 7 8
```

## 9.8: k번째 최대 증가 부분 수열

1. 답의 수를 세는 문제를 푼다.
2. 답의 수를 기반으로 답안을 재구성한다.  

이 문제에서는 답의 수가 아닌 최대 증가 부분 수열 길이를 계산합니다.  
수열에는 엄청나게 많은 증가 부분 수열이 있을 수 있습니다.  
가장 긴 것을 찾아내는 것은 최적화 문제입니다.  

1. 바탕이 되는 최적화 문제를 푼다.
2. 최적화 문제의 최적해를 세는 문제를 푼다.
3. 답의 수를 기반으로 답안을 재구성한다.

**LIS의 개수 세기**

LIS의 길이를 찾는 문제는 이전에도 다룬 적이 있습니다.  
lis3()의 시간 복잡도는 $O(n^2)$입니다.  
최적해를 구하고 나면 그 개수를 세기란 어렵지 않습니다.  

먼저 개수를 세는 알고리즘입니다.  
LIS의 개수는 n에 따라 지수적으로 증가할 수 있습니다.  
오버플로를 막기 위해 long으로 임시 캐스팅 후 사용합니다.  
O(n)개의 부분 문제가 있고 하나당 O(n)으로 $O(n^2)$이 걸립니다. 

```java
static int[] cacheCnt;
static int MAX = 200000000+1;

static int count(int start){
    if(lis3(start) == 1) return 1;
    int answer = cacheCnt[start+1];
    if(answer!= -1) return answer;
    answer = 0;
    for(int next = start + 1; next < n; next++){
        if(start == -1 || S[start] < S[next])
        if(lis3(start) == lis3(next) + 1)
            answer=Math.min(MAX, (long)(answer + count(next)));
    }
    return cacheCnt[start+1] = answer;
}
```
**LIS의 재구성**

최적해를 구하고 개수를 구했으면 k번째 답을 찾습니다.  
먼저 앞에 부분을 건너뛸 skip = k-1을 둡니다.  
skip을 빼고 사전순으로 나오는 LIS를 구해야합니다.  
lis()에서 처음 그랬듯이 $S[-1]= -\infty$를 추가합니다.  
모든 LIS는 반드시 S[-1]에서 시작해야 합니다.  

1. S[start]를 lis에 추가  
    S[start]에서부터 시작하는 LIS의 첫 번째 수는 항상 S[start]

2. LIS에서 S[start] 다음에 올 수 있는 숫자들의 목록 작성  
    S[start] 오른쪽에 있으면서 S[start]보다 커야합니다.  
    lis(next) + 1 == lis(start)인 S[next]를 찾습니다.  
    이 숫자들을 숫자가 증가하는 순서대로 정렬합니다.  

3. 목록중 k번째 LIS에 포함되는 숫자를 찾습니다.  
    LIS의 수가 skip 이하인지 확인합니다.  
    초과한다면 k번째 LIS가 이 수를 사용합니다.  
    아니라면 skip에서 해당 답의 수를 빼면 됩니다.  

4. 나머지 숫자는 skip을 뺀 형태로 재귀호출로 해결합니다.  

## 9.9 문제: 드래곤 커브

드래곤 커브는 선분 하나에서 시작해 변형해 나갑니다.  
세대가 변할수록 복잡한 모양으로 변하게 됩니다.  
확대했을 때 전체와 비슷한 형태로 나오는 프랙탈 입니다.  
드래곤 커브를 그리는 방법을 드래곤 커브 문자열이라 합니다.  
드래곤 커브 문자열은 X, Y, F, +, -로 구성된 문자열입니다. 

- F: 앞으로 한 칸 전진하며 선을 긋습니다.
- +: 왼쪽으로 90도 회전합니다.
- -: 오른쪽으로 90도 회전합니다.
- X: 다음번 차례에 X + YF로 치환됩니다.
- Y: 다음번 차례에 FX - Y로 치환됩니다.

0세대는 FX로 구성됩니다. 
n세대 드래곤 커브에서 문자열 중 p번째에서 l글자만을 계산합니다.  

## 9.10 풀이: 드래곤 커브

**더 간단한 문제부터 풀어보자**

이 문제를 쉽게 만드는 비법은 더 간단한 문제를 풀어봅니다.  
문자열의 일부를 계산하는 문제 대신 주어진 위치 한 글자만 출력해봅니다.  
만약 이 문제를 빨리 풀 수 있으면 여러 글자도 가능할 것입니다.  
문제는 n세대의 p번째 글자를 찾는 것으로 바뀌었습니다.  

**p번째 글자를 찾는 함수 작성하기**

우선 맨 앞에서부터 드래곤 커브 문자열을 만들어봅니다.  
이것을 기반으로 p번째 글자를 찾을 것입니다.  
문자열을 만드는 방법은 여태 그래왔듯이 재귀적인 구현으로 만듭니다.  

> curve(seed, generations)= 초기 문자열 seed를 generation 진화 결과

여기서 진화했다는 말은 출현하는 X와 Y를 규칙만큼 치환한 결과입니다.  
원하는 글짜만 출력하려면 재귀호출이 몇 글자를 출력할지 알아야합니다.  
seed로 주어지는 값은 항상 FX, X+YF, FX-Y 셋 중 하나입니다.  

```java
  final static int MAX = 1000000000 + 1;
  static int[] length = new int[51];

  static void precalc() {
    length[0] = 1;
    for (int i = 1; i <= 50; i++) {
      length[i] = Math.min(MAX, length[i - 1] * 2 + 2);
    }
  }

  final static String EXPAND_X = "X+YF";
  final static String EXPAND_Y = "FX-Y";

  static char expand(String dragonCurve, int generations, int skip) {
    if (generations == 0) {
      return dragonCurve.charAt(skip);
    }
    for (int i = 0; i < dragonCurve.length(); ++i) {
      if (dragonCurve.charAt(i) == 'X' || dragonCurve.charAt(i) == 'Y') {
        if (skip >= length[generations]) {
          skip -= length[generations];
        } else if (dragonCurve.charAt(i) == 'X') {
          return expand(EXPAND_X, generations - 1, skip);
        } else {
          return expand(EXPAND_Y, generations - 1, skip);
        }
      } else if (skip > 0) {
        --skip;
      } else {
        return dragonCurve.charAt(i);
      }
    }
    return '#';
  }
```

## 9.11 정수 이외의 입력에 대한 메모리제이션

어떤 함수를 메모리제이션으로 최적화하려고 합니다.  
그 입력 중 하나가 정수가 아니라면 어떻게 할까요?  
입력 하나를 배열의 위치 하나에 배당하는 것이 불가능해집니다.  

**연관 배열 사용하기**

맨 처음 떠오르는 방법은 map과 같은 연관 배열을 이용합니다.  

**일대일 대응 함수 작성하기**

떄떄로 유용하게 써먹는 방법은 입력을 적절히 정수로 변환합니다.  
예를 들어 주어지는 정수 배열이 [1,n] 범위 수를 가지고 있습니다.  
이때 입력의 종류는 n!가지가 됩니다.  
가능한 입력 중 사전순 몇번째인지 계산하는 함수를 만들면 편합니다.  
이럴 때 함수는 **일대일 대응 함수**여야 합니다.
**일대일 대응 함수**는 집합 A와 B의 원소를 1대1으로 대응시킵니다.  

- 두 개의 다른 입력이 같은 출력이 나온다면 잘못된 답을 저장할 수 있습니다.  
- 어떤 배열 위치에 대응되는 입력이 없다면 메모리가 낭비됩니다.  

**입력이 불린 값의 배열인 경우**

불린 값의 배열이 함수의 입력으로 오는 예가 있습니다.  
불린 값 변수는 배열의 길이가 n일 때 예/아니오 두 경우로 2^n가지가 나옵니다.  
이때 써먹을 수 있는 방법은 n인 배열을 길이가 n인 2진수로 가정합니다.  
배열 A[]에 대해 A[0]은 맨 아랫 자리, ..  식으로 계산하게 됩니다.  
이때 해당 위치에 참이면 1을 넣게 됩니다.  
문제는 크기가 지수적으로 늘기 때문에 메모리 크기에 문제가 있습니다.  
따라서 이와 같은 방법은 n이 20이 넘어가면 사용하기 쉽지 않습니다.  
만약 숫자가 작다면 비트마스크를 이용한 방법도 고려해볼 수 있습니다.  

**입력이 순열인 경우**

주어진 배열 X[1,2,3...10]의 순열이라고 가정합니다.  
이런 문제느느 가능한 n! 입력 중 몇번째 인지 계산하는 함수를 만듭니다.  
10!의 입력을 사전순으로 나열하고 첫번째 자리 숫자에 따라 나눕니다.  
각 묶음마다 9!개의 입력이 존재하게 될 것입니다.  
여기서 순서를 계산할 때는 매번 팩토리얼 단위로 계산하면 됩니다.  
첫번째 숫자를 9!으로 계산했으면 그 다음은 8!을 뺴가며 계산할 수 있습니다.  

```java
// factorial[i] = i!
int[] factorial = new int[12];

int getIndex(LinkedList<Integer> x){
  int ret = 0;
  for(int i = 0; i< X.size(); i++){
    int less = 0;
    for(int j = i+1; j< X.size(); ++j){
      if(X[j] < X[i])
        ++less;
    }
    ret += factorials[X.size() -i -1] * less;
  }
  return ret;
}
```

**예제: 여행하는 외판원 문제**

6.7절에서 다뤘던 외판원 문제를 다시 돌아봅니다.  
당시에 n!개의 경로를 모두 생성해서 완전 탐색 알고리즘으로 해결했습니다.  
n!는 굉장히 빨리 증가하기 때문에 n이 15만 되도 계산하기 힘들어집니다.  
작성했던 재귀함수의 정의를 다시 한 번 보겠습니다.

> shortestPath(path) = 만든 경로가 path에 주어질때, 나머지 방문하는 최소 경로

부분 문제의 개수는 O(n!)이 됩니다.  
부분 문제의 수도 그렇고 같은 path인자가 두번 이상 쓰이지 않아 메모리제이션이 힘듭니다.  

**함수의 정의 바꾸기**

메모리제이션을 위해서는 선택들에 대한 정보를 최소한만 받아야합니다.  
지금까지 만든 부부 경로인 path가 쓰이는 곳은 두 군데입니다.  
- 경로가 완성되었을 때 전체 경로의 길이를 계산하는 부분
- 어떤 도시를 전에 방문한 적이 있는지 확인하는 부분

다음과 같이 바꾸면 정보를 덜 받을 수 있습니다.  

1. 방문한 경로의 길이 계산  
  shortestPath()가 전체 경로 대신 남은 경로를 반환합니다.  
2. 어떤 도시를 전에 방문했는지 확인:   
  도시 방문 여부는 알아야하지만 순서는 알 필요가 없습니다.  
  따라서 boolean배열로 받겠습니다.   

>shortestPath2(here, visited)=현재가 here이고 각 도시 방문 여부 visited  
here에서 시작해서 나머지 도시를 방문하는 경로의 최소 길이

이때 입력으로 주어질 수 있는 부분 문제의 수는 nx2^n입니다.  
지수 시간이라 많아보이지만 기존에 n!보다 훨씬 빠릅니다.  
visited를 bollean배열로 해도 되지만 int 비트마스크로 계산해보겠습니다.  

```java
  double shortestPath2(int here, int visited) {
    if (visited == (1 << n) - 1) {
      return dist[here][0];
    }

    double answer = cache[here][visited];
    if(answer >= 0) return answer;

    answer = INF;

    for (int next = 0; next < n; ++next) {
      if((visited & (1 << next)) > 0) continue;
      double cand = dist[here][next] +
          shortestPath2(next, visited + (1<<next));
      answer = Math.min(answer, cand);
    }
    return answer;
  }
```

## 9.12 문제: 웨브바짐

물가가 계속 오르는 나라 웨브바짐이 있습니다.  
물가를 반영해서 계란 가격을 종이판으로 표시하고 있습니다. 
이미 팔린 계란을 환불하러 온 사람이 있는데 가격이 이미 바뀌었습니다.  
이전에 팔린 가격이 기억이 안나는 상황입니다.  
다만 이전 가격에서 현재로 바뀌었을 때 조건이 있습니다.  

- 종이판의 순서만 바뀌었습니다. (종이판 내의 숫자 종류는 안바뀌었습니다.)
- 가격을 보며 사탕 m개를 살 수 있다고 생각했습니다.  
  즉 마지막 계란 가격은 m의 배수였습니다.  

지금 계란 가격 e와 m이 주어질 때 가능한 이전 계란 가격 개수를 구합니다.  
이전 계란 가격은 e보다 항상 작아야 합니다.  

**시간 메모리 제한**

> 2초 안에 실행, 64MB 이하의 메모리 사용 

**입력**
> 첫 줄: 테스트 케이스의 수 C (C <= 50)  
  테스트 케이스:   
  첫 번째 줄: 각 두개의 자연수 e와 m(1 <= e <= 10^14, 2<= m <= 20)  
  현재 계란 가격은 0으로 시작하지 않지만 이전 가격은 가능합니다.  

**출력**
각 가능한 결과를 1,000,000,007로 나눈 나머지를 출력

**예제 입력**
```
4
321 3
123 3
422 2
12738173912 7 
```

**예졔 출력**
```
5
0
2
11033
```

## 9.14 풀이: 웨브바짐

이전 계란 가격은 세 가지 조건을 만족해야 합니다.

1. 새 계란 가격 e에 포함된 숫자들을 재배열해야 합니다.  
2. 새 계란 가격 e보다 작아야 합니다.
3. m으로 나누어 떨어져야 합니다.  

먼저 e에 포함된 숫자들로 e보다 작고 m으로 나누어 떨어지는 알고리즘을 만듭니다.  

**완전 탐색도 쉽지 않네**

e의 자릿수들을 재배열하여 만들 수 있는 가격들을 만들어 봅니다.  
전체 n자리가 있을 때 가격을 n조각으로 나누어 맨 앞자리부터 만듭니다.  
지금까지 만든 가격의 일부분과 각 자릿수의 사용여부를 받을 것입니다.  
가격의 다음 자리가 무엇일지 반복문에서 결정하고 재귀함수로 생성합니다.  
기저 사례에서는 이 숫자가 e보다 작은지 m으로 나누어떨어지는지 확인합니다.  
문제는 이렇게 작성하면 같은 숫자가 있을 때 중복으로 세게 됩니다.  
예제처럼 224라는 숫자라면 각 숫자를 다른 것으로 보고 두 번 셀 것입니다.  

이런 중복을 해결하는 방법 중 하나는 순서를 강제하는 것입니다.  
같은 숫자가 여러 개 남아있자면 그 중 가장 먼저오는 것만 선택합니다.  
이 제약 조건은 여러가지 방법이 있습니다.  
그 중 하나는 각 자릿수를 정렬하고 저장한 뒤 바로 앞자리를 검사합니다.

1. i = 0 (앞자리가 없는 경우)
2. digits[i] != digits[i-1] (이번 자릿수와 다른 경우)
3. taken[i-1] = true (이미 사용된 경우)

위의 조건들을 만족했을 때만 사용이 가능합니다.  
그대로 코드를 작성하면 다음과 같습니다. 

```java
static String e, digits;
static int m;

private static void generate(String price, boolean[] visited) {
  if (price.length() == e.length()) {
    if (price.compareTo(e) < 0) {
      System.out.println(price);
    }
    return;
  }
  for(int i = 0; i < e.length(); i++){
    if(!visited[i])
      if(i == 0 || visited[i-1] || digits.charAt(i) != digits.charAt(i-1)){
        visited[i] = true;
        generate(price + digits.charAt(i), visited);
        visited[i] = false;
    }
  }
}
```

**메모리제이션 적용하기**

taken은 비트마스크를 써서 바꾼다해도 문자열 price를 메모리제이션하기 어렵습니다.  
같은 price를 두 번 만들일이 없기때문에 중복 문제가 없습니다.  
즉 최소한의 정보를 재귀호출에 전달해 중복 문제를 많이 만들어야 합니다.  
price를 사용하는 곳은 세군데입니다.  

1. n자리를 모두 만들었는지 판단할 때
2. 다 만든 가격이 사탕 가격의 배수인지 확인할 때
3. 다 만든 가겨이 나중 가격보다 작은지 확인할 때

**가격이 오른 것이 맞는지 확인할 때**

먼저 첫자리에 따라 가격을 고를 수 있는지 결정이 됩니다.

- 첫 자리가 e보다 작을 경우: 무조건 e보다 작은 수를 만듭니다.
- 첫 자리가 e와 같은 경우: 뒷자리에 따라 e보다 클수도 작을수도 있습니다.  
- 첫 자리가 e보다 클 경우: 무조건 e보다 큽니다.  

e보다 작은 경우는 less를 true로 표현합니다. 
e보다 큰 경우는 less를 false로 두고 뒷자리가 e보다 검사해야 합니다. 

**사탕 가격의 배수가 맞는지 확인할 때**

price가 m의 배수인지 판단할 수 있도록 해야 합니다.  
아까와는 달리 마지막 숫자가 나올때까지 판단하기 어렵습니다.  
이 결과를 나머지 연산의 분배 법칙을 사용하면 해결할 수 있습니다. 
나누기를 할 때 각 자리수 별로 나누기를 할 수 있습니다.  
나누기를 하고 남은 나머지로 나누기를 다시 하더라도 최종 나머지는 같습니다.  

## 9.14 문졔: 실험 데이터 복구하기

실수로 실험에 사용하던 데이터를 삭제했습니다.  
들키지 않기 위해 데이터를 위조하려고 합니다.  
알고 있는 것은 데이터가 k개의 문자열 조각을 포함하고 있습니다.  
모두 알파벳 소문자로 구성되어 있습니다.  
주어진 문자열 조각들을 모두 포함하는 가장 짧은 문자열을 계산합니다.  
조건을 만족하는 문자열이 여럿이면 아무거나 출력하면 됩니다.  

**시간 메모리 제한**

> 2초 안에 실행, 64MB 이하의 메모리 사용 

**입력**
> 첫 줄: 테스트 케이스의 수 C (C <= 50)  
  테스트 케이스:   부분 문자열의 수 k(1<=k <= 15)  
  첫 번째 줄: k줄에 알파벳 소문자 문자열 조각  
  각 문자열 조각의 길이는 1이상 20이하

**출력**
문자열을 모두 포함하는 가장 짧은 문자열 중 하나

**예제 입력**
```
3
3
geo
oji
jing
2
world
hello
3
abrac
cadabra
dabr
```

**예졔 출력**
```
geojing
helloworld
cadabrac
```

## 9.15 풀이: 실험 데이터 복구하기

**담의 구조 파악하기**

세 번쨰 예제 입력을 손으로 먼저 풀어봅니다.  
cadabra의 뒤 네글자와 abrac의 첫 네글자는 일치합니다.  
이 점을 생각하면 abra의 네 글자를 아낄 수 있습니다.  
dabr 또한 cadabra의 일부이기 때문에 dabr는 신경쓰지 않아도 됩니다.  
여기서 알 수 있는점 3가지가 있습니다.  

- 어떤 문자열 조각에도 포함되지 않는 문자를 더할 일은 없습니다. 
- 연속해서 출현하는 문자열들의 접두사와 접미사를 많이 겹쳐야 합니다.  
- 한 문자열 조각이 다른 문자열에 포함되는 경우 무시합니다.  

**모든 답을 만들어 보기**

동적 계획법을 쓰기 위해 모든 답을 만드는 완전탐색에서부터 시작합니다.  
이때 모든 답은 모든 문자열 조각을 포함하는 문자열입니다.
알파벳 소문자로 구성된 문자열 하나씩 모두 만드는 것은 비효율적입니다.  
문자열을 만드는 좋은 방법은 문자열 조각들이 어떤 순서대로 출현할지 정합니다.  
문자열 조각들이 특정 순서대로 출현한다고 하면 최대한 겹치게 연결하면 됩니다.  

단어 a뒤에 단어 b가 등장할때 최대 몇글자 겹치는지 계산하는 overlap(a,b)입니다.  
그러면 원문의 길이는 다음과 같습니다.

$\sum_{i=0}^{k-1} w_i - \sum_{i=1}^{k-1} overlap(w_{i-1}, w_i)$

우리는 이 값을 최소화하면 됩니다.

**비슷한 문제를 풀어 폰 적이 있군요** 

문자열 조각 k개가 등장할 수 있는 순서는 k!개입니다.

이 중 인접한 문자열 조각들의 overlap()결과의 합을 최대화합니다.  
이 문제는 외판원 문제의 최소화 부분을 최대화로 바꾼 것 뿐입니다.  
따라서 같은 점화식으로 풀릴 것이라 예상할 수 있습니다.  

> restore(last, used) = 마지막에 출현한 조각 last, 지금까지 출현 조각 used  
  나머지 조각을 추가해서 얻을 수 있는 overlaps()의 최대 합

> restore(last, used) = max(overlap(last, next) + restore(next, used U {next}))

## 9.16 조합 게임

동적 계획법의 또 다른 사용처는 여러 조합 게임 해결입니다.  
해결의 의미는 게임의 상태가 주어졌을 때 완벽한 한 수를 찾아냅니다.  
완벽한 한 수란 그 이후에 수로 실수하지 않으면 무조건 이기는 수입니다.  

**게임 트리**

게임트리란 게임의 모든 상태를 트리 형태로 그린 것입니다.  
트리의 최상단에는 게임을 시작했을 때 초기 상태가 위치합니다.  
먼저수를 두는 참가자들이 정점에서 나가는 간선으로 표현됩니다.  

완전한 게임 트리가 주어질 때 어떤 게임도 완벽하게 풀 수 있습니다.  
그 방법은 맨 아래쪽 승리부터 위로 올라가는 것입니다.  

**위에서 내려가기**

이렇게 게임트리 전체를 그린후 밑에서부터 승패를 판단하며 올라갈 수 있습니다.  
이런 방법을 **bottom up** 이라하고 직관적이지만 구현하기 까다롭습니다.  
이유는 맨 아래가 아니라 중간마다 승부가 날 수도 있습니다.  
그리고 모든 경우를 계산하려면 메모리도 많이 차지하게 됩니다.  
이 대신에 많이 사용하는 방법이 위에서 부터 내려오는 **top down**입니다.  
재귀 호출을 이용해 다음과 같은 함수 정의를 이용합니다.

> winner(state, player) 현재 상태가 state, player가 수를 둘 차례  
어느 쪽이 최종적으로 이길지 계산

어느 쪽이 수를 둘 차례인지를 player 인자를 통해 따로 전달합니다.  
오목이나 바둑은 검은 돌이 먼저 두기 때문에 이런 정보가 필요없습니다.  
하지만 게임 상태로 순서를 알 수 없는 게임은 필요합니다.  
하지만 함수 정의를 바꾸면 이런 정보가 필요없게 됩니다.  

> canWin(state) 현재 상태가 state일 때 이번에 수를 두는 사람이 이길까?

이런 정의를 구현하면 구현이 더 직관적이 됩니다.  
함수를 실행했을 때 다음 수 상태를 state'라고 가정하겠습니다.  
canWin(state') 시 true라면 상대가 이기는 경우입니다.  
canWin(state') 시 false라면 내가 이기는 경우입니다.  
즉 canWin(state')에서 false가 하나라도 있으면 이길 수 있다는 의미입니다.  

**메모리제이션**

오목과 같은 게임은 어떤 순서로 놓았는지가 상관없습니다.  
따라서 상태에 대한 정보를 메모리제이션에 저장할 수 있습니다.  
그 결과로 canWin()을 호출하면 결과를 저장하고 불러 쓸 수 있습니다.  

**바둑이나 체스는?**
게임 트리를 완벽하게 그릴 수 있다면 어느 게임이든 해결 가능합니다.  
하지만 바둑이나 체스는 게임의 상태가 너무 많습니다.  
게임의 종료하기까지 둬야하는 수도 많아서 컴퓨터로 계산하기 너무 큽니다.  
이와 같은 한계로 이런 게임들은 전체 트리 중 일부만 탐색합니다.  
그럴듯한 몇 개만 시뮬레이션 하고 시간 제한내 탐색 트리 깊이로 확률을 계산합니다.  

**처음으로 돌아올 수 있는 게임들**

게임 트리를 그릴 수 있는 문제들은 지난 상태로 다시 돌아갈 수 없습니다.  
한 번 둔 수를 다시 물릴 수 있는 게임은 게임 트리에 사이클이 생깁니다.  
따라서 지금까지 설명한 방법으로 문제를 풀 수 없습니다.  

**예졔: 틱택토**

틱택토는 3X3 크기의 게임판에서 하는 3목 게임입니다.  
오목처럼 흑백대신 O와 X로 말을 표시합니다.  
틱택토를 해결하는 프로그램을 작성합니다.  

**상태 표현**

틱택토 게임판을 3X3 문자열 배열로 표현합니다. 

> canWin(board) 틱택토 게임판이 현재 board일 때 이번 차례사람이 이길지 반환

이 함수에 메모리제이션을 저장하려면 게임판을 정수로 변환하거나 해야합니다.  
일대일 함수를 구현하는 간단한 방법은 board를 9자리 3진수 수자로 봅니다.  
${3^9}$ = 19683으로 시간 내에 충분히 계산할 수 있습니다.  

**비기는 게임**

오목과 달리 틱택토에는 승부가 나지않고 비길 수 있습니다. 
양쪽 다 줄을 만들지 못하고 게임판을 꽉 채우는 경웨는 양쪽이 비깁니다.  
따라서 각 참가자는 이기지 못하는 경우에 최대한 비기는 쪽으로 만듭니다.  
따라서 canWin()의 반환 값은 참, 거짓이 아니라 세가지로 해야합니다. 

- 이길 수 있는 경우
- 이길 수는 없지만 비길 수 있는 경우
- 상대가 실수하지 않으면 항상 질 수밖에 없는 경우

> canWin(board) 택틱토 게임판이 현재 board일 때 이길수 있으면 1 반환  
비길 수 있으면 0, 질 수밖에 없으면 -1 반환

이제 모든 참가자는 canWin(board')=-1 인 수가 있으면 무조건 그쪽을 택합니다.

**구현**

- 이미 게임이 끝난 상태를 기저 사례로 택합니다.  
  먼저 받은 게임판에 이미 한 줄이 만들어져 있는지 확인합니다.  
- 함수의 반환 값이 -1이 될 수도 있기 때문에 cache[]의 초기치는 -2입니다.
- canWin()은 현재상황판 말고도 누구 차례인지도 turn으로 전달합니다.  
  틱택토는 항상 X가 먼저 두기때문에 board만 가지고도 알 수 있습니다. 
- canWin()은 모든 수를 시도해보며 반환 값중 가장 작은 것을 찾습니다.  
  어떤 수를 두었을 때 -1이 반환된다면 이길 수 있다는 의미입니다.  

**더 빠르게 구현하기**

최대 ${3^9}개의 부분 문제가 있고 한 부분 문제당 최대 ${3^2}이 걸립니다.  
즉 동작시간의 상한은 ${3^11}이 됩니다.  
물론 이 숫자는 실제로 존재할 수 없는 O나 X로 꽉 찼을 때의 경우입니다.  

**무조건 비기기**

프로그램으로 돌려보면 양쪽이 항상 완벽하게 플레이하면 비길 수 밖에 없습니다.

## 9.17 문제: 숫자 게임

n개의 정수를 일렬로 늘어놓은 게임판으로 현우와 서하가 게임을 합니다.  
게임은 현우부터 시작해 번갈아가며 두가지 일 중 하나를 할 수 있습니다. 

- 게임판의 왼쪽 끝에 있는 숫자나 오른쪽 끝에 있는 숫자 중 하나를 가져갑니다.  
  가져간 숫자는 게임판에서 지워집니다. 

- 게임판에서 두 개 이상의 숫자가 있을 경우 왼쪽/오른쪽 끝에서 두개를 지웁니다.

게임은 모든 숫자가 다 없어졌을 때 끝나며 각 점수는 가져간 숫자 합입니다.  
두 사람이 최선을 다할 때 현우와 서하의 최종 점수 차이는 얼마일까요? 

## 9.19 문제: 블록 게임

5X5 게임판에서 시작해 번갈아가며 블럭을 하나씩 게임판에 놓습니다.  
블럭은 L몽양으로 구성된 3칸짜리 블럭과 2칸짜리 블럭이 있습니다.  
항상 게임판에 있는 줄에 맞춰 내려놓아야 합니다.  
블럭들은 서로 겹칠 수 없습니다.  

각 블록은 자유롭게 뒤집거나 회전해서 올려놓을 수 있습니다.  
더 올려놓을 수 없으면 두 사람 중 마지막에 놓은 사람이 승리합니다.  
이번 차례인 사람이 승리할 수 있는 방법이 있는지 판단합니다.  

## 9.20 풀이: 블록 게임

**상태 표현하기**

이 게임은 게임판이 주어질때 양쪽이 둘 수 있는 수가 항상 같은 대칭 게임입니다.  
대칭 게임은 게임판만 주어지면 지금이 누구 차례인지 중요하지 않습니다.  
승패를 판단하는데 있어서 지금이 누구 차례인지 알 필요 없습니다.  

또 하나 알 필요 없는 것은 블록의 배치입니다.  
입력에서 블록들이 구분되지 않는다는 점이 있듯이 배치는 중요하지 않습니다.  
블록이 칸에 놓여져있는지 그 자체만 중요합니다. 

따라서 게임판의 각 칸에 블록이 있는지만 상태로 표현하면 됩니다.  
> play(board) 현재 게임판 상태가 board일때 이번차례 사람이 이길 수 있는지 반환

**상태 개수 계산하기**

크기 25인 불린 값 배열은 대략 3천 3백만 가지의 값을 가질 수 있습니다.  
때문에 부분 문제의 수가 너무 많은 것이 아닐까 생각할 수 있습니다.  
하지만 실제로 문제를 풀다보면 문제가 그렇게 크지 않습니다.  
두 가지 형태의 블록을 놓아서 만들 수 있는 게임판의 상태는 2^25보다 적습니다.  
예를 들어 전체 25칸 중 3칸에 블록이 놓여져 있는 경우는 2300가지 입니다.  
이 게임의 규칙을 가지고 실제로 만들 수 있는 게임판은 64가지 입니다.  
실제로 게임판에 대해 실행해보면 약 160만개의 상태를 방문하게 됩니다.  

## 9.21 반복적 동적 계획법

동적계획법을 구현할 때 재귀호출과 메모리제이션으로 구현해왔습니다.  
하지만 동적계획법을 구현할 때는 반복문을 통해서도 가능합니다.  
이를 반복적 동적 계획법이라고 합니다.  

**슬라이딩 원도를 이용한 공간 복잡도 줄이기**

반복적 동적 계획법 사용시 공간 복잡도를 줄일 수 있습니다.  
삼각형 윙의 최대 경로 문제를 풀 때 n = 10000이라 가정하겠습니다.  
n^2은 대략 1억으로 실행은 가능하지만 메모리가 부족할 수 있습니다.  
이 경우에 유용한 방법이 슬라이딩 윈도 테크닉입니다.  
슬라이딩 윈도란 사용하는 데이터 전체를 유지하는 것이 아닙니다.  
필요한 부분만을 저장해서 사용하는 기법입니다.  
슬라이딩 윈도는 새 값을 계산할 때 과거 계산 결과 일부만 필요할 때 씁니다.  
삼각형 최대 경로 문제를 계산하려면 C[i]를 풀때 C[i+1]만 필요합니다.  
따라서 항상 두 줄만 저장하면 됩니다.  

```java
int[][] C2 = new int[2][10000];

int iterative2(){
  for(int x = 0; x < n; ++x)
    C2[(n-1)%2][x] = triangle[n-1][x];
  
  for(int y = n-2; y >= 0; --y)
    for(int x = 0; x <y+1; ++x)
      C2[y%2][x] = max(C2[(y+1)%2][x],
                       C2[(y+1)%2][x+1]) + triangle[y][x];
  return C2[0][0];
}
```

**행렬 거듭제곱을 이용한 동적 계획법**

굉장히 한정된 경우에만 쓸 수 있지만 선형 변환으로 빠르게 푸는 기법입니다.  
피보나치 수열의 특정 항을 구하는 문제로 예를 들어 보겠습니다.  
피보나치 수열은 첫 두 숫자가 각각 0과 1이고 다음부터는 이전 두수의 합입니다.  
따라서 다음과 같은 점화식으로 정의할 수 있습니다.  

> fib(n) = fib(n-1) + fib(n-2)

피보나치 수열의 n번째 숫자의 마지막 다섯자리를 계산하는 함수를 만듭니다.  
가장 단순한 형태로 O(n)의 동적계획법 알고리즘을 구현하면 다음과 같습니다.

```java
int fib(int n){
  if(n <= 1) return n;
  int[] seq = new int[3];
  seq[0] = 0;
  seq[1] = 1;
  for(int i = 2; i <= n; i++)
    seq[i % 3] = (seq[i-1] % 3 + seq[i-2] % 3) % 100000;
  return seq[n%3];
}
```
메모리 사용량은 O(1)이 됩니다.  
seq의 크기는 2가 아니라 3이 되는데 사고를 방지하기 위해 1을 늘립니다.  
seq[i]가 seq[i-2]를 덮어쓸 수 있기 떄문에 대비하는 것이 좋습니다.  

이 코드는 O(n)의 시간복잡도를 가집니다.  
이것보다 훨씬 빠른 시간에 수행되는 알고리즘이 있습니다.  
바로 빠른 행렬 제곱 알고리즘을 이용하는 것입니다.  

fib(i-1)과 fib(i)를 포함하는 크기가 2인 열벡터 $C_i$ 라고 부릅니다.  

그러면 $C_{i+1}$ 을 다음과 같이 쓸 수 있습니다. 

$fib(i) fib(i-1) + fib(i) = C_i1 C_i0 + C_i1 = 01 11$

**반복적 동적 계획법과 동적 계획법의 비교**

### 재귀적 동적 계획법의 장단점 

#### 장점 
1. 좀더 직관적인 코드
2. 부분 문제간의 의존 관계나 계산 순서 고민할 필요 X
3. 전체 부분 문제 중 일부의 답만 필요한 경우 더 빠르게 동작

#### 단점
1. 슬라이딩 윈도 기법 사용 불가
2. 스택 오버플로 조심

### 반복적 동적 계획법의 장단점

#### 장점
1. 구현이 대개 더 짧음
2. 재귀 호출의 부하가 없기 때문에 조금 더 빠르게 동작
3. 슬라이딩 윈도 기법 사용 가능

#### 단점
1. 구현이 좀 더 비직관적
2. 부분 문제간의 의존 관계를 고려해 계산 순서 고민

중요한 것은 가능한 한 자신이 선택한 방법으로 일관되게 계속 연습

## 9.22 문제: 회전초밥

회전초밥 집에는 n종류의 메뉴가 있습니다.  
각 메뉴에 대한 선호도가 있습니다.  
주어진 예산안에서 선호도의 합이 최대한이 되도록 초밥을 먹고 싶습니다.  
각 초밥은 무한정으로 공급됩니다.  
이때 얻을 수 있는 최대한의 선호도는 얼마일까요?  

## 9.23 풀이: 회전초밥

**비슷한 문제를 풀어본 적이 있군요**

여행 짐싸기 문제와 거의 같은 문제입니다.   
다른 점은 두가지입니다. 

1. 각 문제들을 하나가 아닌 무한정 가져갈 수 있습니다.  
2. 가져갈 수 있는 총량의 제한이 엄청나게 큽니다.  

첫 번째 다른 점은 점화식을 약간 바꿔서 해결이 가능합니다.  
문제는 총량의 제한이 10^9로 10억까지 해결해야된다는 점입니다.  
메모리제이션을 할 때에도 크기 때문에 고민이 됩니다.  
이때 해결법은 문제에서 가격은 최대 20,000이고 항상 100의 배수라는 점입니다.  
즉 100으로 나눠서 계산해도 문제가 없다는 뜻입니다.  
마찬가지로 100으로 나눴을때 200이 넘는 수는 계산할 필요가 없게 됩니다.

## 9.24 문제: 지니어스

MP3 플레이어에 들어있는 곡들을 전부 셔플 모드로 들을 때 문제점이 있습니다.  
서로 어울리지 않는 노래들이 갑자기 나올 수 있다는 점입니다.  
이 문제를 해결하기 위해 같이 들었을 때 어울리는 셔플 모드를 만드려합니다.  
지니어스를 사용하면 한 곡 다음 다음곡이 재생될 확률은 유사도에 달립니다.   
음악들 간의 유사도를 조사해 i번 곡 다음 j번 곡이 재생될 확률 T를 만들었습니다.  
처음 재생버튼으로 0번을 듣기 시작했습니다.  
k분 30초가 지난후 좋아하는 곡이 재생되고 있을 확률은 얼마일까요?  
MP3 플레이어에 들어있는 곡들의 길이는 1분,2분,3분,4분 중 하나입니다.  

## 9.25 풀이: 지니어스

**비슷한 문제를 풀어본 적이 있군요**

광학 문자 인식과 비슷한 문제 입니다.  
다른 점이 있다면 곡마다 길이가 다르다는 점입니다.  
