---
title: 문제 해결 전략 7
tags:
  - algorithm
classes: wide
published: false
---

## 7.1 도입
**분할 정복**은 답을 둘 이상으로 나누고 재귀로 문재를 해결합니다.  
각 부분 문제의 답으로부터 전체 문제의 답을 계산합니다.   
재귀 호출과 다른 점은 비슷한 크기로 문제를 나눕니다.  
보통 **분할 정복**은 세가지 요소로 구성되어 있습니다.   

- 문제를 더 작은 문제로 분할하는 과정 **(divide)**
- 각 문제에 대해 구한 답을 원래 문제에 대한 답으로 병합 **(merge)**
- 더이상 답을 분할하지 않고 곧장 풀 수 있는 작은 문제 **(base case)**

### 행렬의 거듭제곱
n x n 크기의 행렬 A가 주어질 때, A의 거듭제곱 A^m은 A를 m번 곱합니다.  
m이 매우 큰 경우 A^m을 구하는 것은 시간이 오래 걸립니다.  
행렬의 곱셈에는 O(n^3)이 들기 때문에 대략 O(n^3*m)이 걸립니다.   
일반 컴퓨터로는 1초 안에 계산할 수 없는 양입니다.  
**분할 정복**을 이용해 m개의 조각을 절반으로 나눠봅니다.  

```java
class SquareMatrix{
  
  SquareMatrix pow (SquareMatrix A, int m){
    // 기저 사례 A ^ 0 = 1
    if(m == 0) return identity(A.size());
    if(m % 2 > 0) return pow(A, m-1) * A;
    SquareMatrix half = pow(A, m / 2);
    
    return half * half;
  }
}
```

**나누어 떨어지지 않을 때의 분할과 시간 복잡도**
m이 홀수일 때, A^m = A * A^(m-1) 로 나누고 있습니다.  
이 때 절반에 가깝게 더 좋지 않을까 생각할 수 있습니다.  
하지만 이 문제에선 그 방식이 더 느리게 만듭니다.  
이렇게 문제를 풀면 계산해야 할 부분 문제의 수가 늘어납니다.  

즉 같은 문제라도 어떻게 분할하느냐에 따라 시간복잡도가 달라집니다.  
달라지는 이유는 중복되는 부분에 의한 것입니다.  

### 예제: 병합 정렬과 퀵 정렬
**병합 정렬**과 **퀵 정렬**은 분할 정복을 기반으로 만들어졌습니다.  
두 정렬은 오래 걸리는 O(n) 작업이 언제인지에 따라 달라집니다.  
병합 정렬은 나눌 때는 O(1), 병합할 때는 O(n)이 걸립니다.  
퀵 정렬은 나눌 때 O(n), 병합할 때는 O(1)의 시간이 걸립니다.   

병합 정렬은 매번 모두 절반씩 줄어 O(logn)이 됩니다.  
병합 정렬은 결론적으로 O(nlogn)이 됩니다.   
퀵 정렬은 경우에 따라 절반씩 잘 나눠지지 않을 수 있습니다.  
이런 최악의 경우 O(n^2)이 딥니다.  


## 7.2 문제: 쿼드 트리 뒤집기
대량의 좌표 데이터를 압축해 저장하기 위해 **쿼드 트리**를 사용합니다.  
주어진 공간을 항상 4개로 분할해 재귀적으로 표현합니다.  
쿼드 트리는 2^N X 2^N 크기의 흑백 그림을 다음 과정을 거쳐 만듭니다.  
ㅇ
- 모든 픽셀이 검은 색일 경우 결과는 크기 상관 없이 b입니다.
- 모든 픽셀이 흰 색일 경우 크기에 관계 없이 w입니다.
- 모든 픽셀이 같은 색이 아니라면 가로 세로로 각각 2등분합니다.  
  압축 결과는 x(왼쪽 위)(오른쪽 위)(왼쪽 아래)(오른쪽 아래)가 됩니다.

압축된 훅백 그림이 주어졌을 때 뒤집은 그림을 압축해서 출력합니다.  

**시간 메모리 제한**

> 1초 안에 실행, 64MB 이하의 메모리 사용 

**입력**
> 첫 줄: 테스트 케이스의 수 C (C <= 50)  
  문자열의 길이 1,000 이하  
  원본 그림의 크기 2^20 X 2^20 이하

**출력**

쿼드 트리 압축 결과

**예제 입력**
```
4
w
xbwwb
xbwxwbbwb
xxwwwbxwxwbbbwwxxxwwbbbwwwwbb 
```

**예졔 출력**
```
x
xwbbw
xxbwwbbbw
xxwbxwwxbbwwbwbxwbwwxwwwxbbwb
```

## 7.3 풀이: 쿼드 트리 뒤집기

이 문제를 푸는 가장 무식한 방법은 압축을 풀고 상하 반전 후 다시 압축합니다.  
물론 문제에 원본 그림의 크기 제한 때문에 이 방법을 쓸 수 없습니다.  
이런 경우 선택할 수 있는 접근 방법은 두 가지 입니다.  

- 큰 입력에 대해서도 동작하는 효율적인 알고리즘을 만들기
- 작은 입력에 대해서만 동작하는 단순한 알고리즘에서 최적화해 나가기  

둘 중 쉬운 것은 단순한 알고리즘을 만들어보는 것입니다.  

압축을 풀고 문제를 푸는 방법을 생각할 수 있습니다.  
문제는 압축을 푼 결과를 저장하려면 (2^20)^2의 공간이 필요합니다.   
대략 계산해보면 1테라가 넘는 공간을 차지하게 됩니다. 
64MB를 넘으므로 제한 조건에도 맞지 않습니다.  
즉 압축해제를 저장한 결과를 사용할 일이 없다는 뜻입니다.  
그렇다면 압축을 해제하지 않아도 뒤집을 수 있다는 뜻이지요.  
이런 식으로 전개해나가면 4등분한 결과를 상하로 뒤집어봅니다.  
b나 w인 경우 위치만 바뀔뿐 값이 바뀌지 않습니다.  
마찬가지로 x이더라도 내부의 위치만 바뀌는 것을 알 수 있습니다.   
```java
private static String quadTree(String compress) {
  char head = compress.charAt(0);
  if (head == 'b' || head == 'w') {
    return Character.toString(head);
  }
  
  String remains = compress.substring(1);
  String ul = quadTree(remains);
  
  remains = remains.substring(ul.length());
  String ur = quadTree(remains);
  
  remains = remains.substring(ur.length());
  String ll = quadTree(remains);
  
  remains = remains.substring(ll.length());
  String lr = quadTree(remains);
  return "x" + ll + lr + ul + ur;
}
```

## 7.4 문제: 울타리 잘라내기

너비가 같은 N개의 나무판자를 붙여 울타리를 만들었습니다.  
시간이 지나 판자들이 부러져 높이가 다 달라졌습니다.  
울타리를 버리려고 하는데 일부를 직사각형으로 잘라 재활용합니다.  
이 때 잘라낼 수 있는 직사각형의 최대 크기를 계산합니다.  
단 울타리를 대각선으로 비스듬히 자를 수 없습니다.  
판자의 너비는 모두 1입니다. 

**시간 메모리 제한**

> 1초 안에 실행, 64MB 이하의 메모리 사용 

**입력**
> 첫 줄: 테스트 케이스의 수 C (C <= 50)  
  판자의 수 N (1 <= N <= 20000)  
  N개의 정수로 왼쪽부터 판자의 높이가 주어집니다.  
  높이는 모두 10000이하의 자연수입니다.

**출력**

울타리에서 잘라낼 수 있는 최대 직사각형의 크기를 나타냅니다.

**예제 입력**
```
3
7
7 1 5 9 6 7 3
7
1 4 4 4 4 1 1 
4 
1 8 2 2
```

**예졔 출력**
```
20
16
8
```

## 7.5 풀이: 울타리 잘라내기

**무식하게 풀 수 있을까?**

각 판자 높이의 배열 h[]가 주어졌을 때 l번부터 r번까지를 자릅니다.  
사각형의 넓이는 다음과 같습니다.  

> (r-l+1) x min(h[i](l <= i <= r))

이떄 문제를 풀 수 있는 가장 간단한 방법은 2중 for문으로 계산합니다.  
하지만 입력 최대 크기는 20,000으로 O(n^2)으로 풀면 시간이 걸립니다.  

**분할 정복 알고리즘의 설계**

분할 정복 알고리즘을 설계하려면 어떻게 분할할지 결정합니다.  
n개의 판자를 절반으로 나눠 두개의 부분 문제로 만듭니다.  
최대 직사각형은 다음 세가지 중 하나입니다.

- 가장 큰 부분은 왼쪽 부분 문제에서만 만들 수 있다.
- 가장 큰 부분은 왼쪽과 오른쪽에 걸쳐 있다.
- 가장 큰 부분은 오른쪽 부분 문제에서만 만들 수 있다.

왼쪽과 오른쪽은 재귀호출로 풀면 가능합니다. 
따라서 걸쳐 있는 부분을 구해 큰 부분을 선택하면 됩니다.  

**양쪽 부분 문제에 걸친 경우의 답**

양쪽 부분 문제에 모두 걸치는 가장 큰 값을 어떻게 찾을까요?  
힌트는 가장 큰 부분은 경계에 두 부분을 걸쳐야한다는 것입니다.  
그런데 두 부분을 걸치고 있을 때 다음 칸 탐색을 어느쪽으로 할까요?  
다음 칸이 더 높은 쪽으로 고르는 것이 이득일 것입니다.  

```java
private static int fence(List<Integer> board) {
  if(board.size() == 1) return board.get(0);

  int lo = 0;
  int hi = board.size();

  int mid = (lo + hi) / 2;

  int leftMax = fence(board.subList(lo, mid));
  int rightMax = fence(board.subList(mid, hi));

  int answer = Math.max(leftMax, rightMax);

  int left = mid - 1;
  int right = mid;

  int height = Math.min(board.get(left), board.get(right));

  while(left > lo && right < hi){
    if(right < hi - 1 && (lo == left - 1 || board.get(left - 1) < board.get(right + 1))){
      ++right;
      height = Math.min(height, board.get(right));
    } else{
      --left;
      height = Math.min(height, board.get(left));
    }
    answer = Math.max(answer, height * (right - left + 1));
  }
  return answer;
}
```

**정당성 증명**

이 알고리즘의 정당성의 핵심은 걸친 부분에서 높은 걸 고르는 부분입니다.  
이것은 귀류법을 이용해 해결해 보겠습니다.  
어떤 사각형 R이 낮은 걸 골랐지만 더 크다고 가정해봅니다.  
처음에 2개부터 시작해 너비를 늘려나갑니다.  
그 중에 R과 너비가 같은 사각형 R\`이 무조건 하나는 있습니다.  
이 때 R은 R\`보다 높이가 더 높아야 합니다.  
이 때 R\`의 판자 중 A가 있다고 생각합니다.  
이 경우 R의 판자들은 모두 A보다 높이가 높습니다.  
우리 알고리즘은 둘 중에 더 높은 것을 고르게 됩니다.  
그런데 R\`은 항상 R보다 작을 수 밖에 없습니다.  
즉 더 높은 쪽을 고르는 것이 넓어진다는 것을 알 수 있습니다.  

**시간 복잡도 분석**

n크기의 배열을 n/2크기의 배열 두개로 나눈 뒤 해결합니다.  
이 작업 외에는 함수 내에서 두 부분에 걸친 부분을 찾습니다.  
이 과정은 너비가 2부터 시작해 n까지 도달합니다.   
이 때 걸리는 시간은 O(n)이고 재귀호출을 곱하면 O(nlogn)입니다.  
n이 20,000이라도 nlogn은 290,000으로 문제를 해결할 수 있습니다.

## 7.6 문졔: 팬미팅

팬미팅을 하면서 M명의 팬들이 줄지어 이동합니다.  
맨 오른쪽 멤버부터 시작해 왼쪽까지 팬들은 동시에 한명씩 움직입니다.  
남성 멤버와 남성 팬은 악수를 하고 아닌 경우 포옹을 합니다.  
이 때 모든 멤버가 동시에 포옹을 하는 횟수를 계산합니다.  

**시간 메모리 제한**

> 10초 안에 실행, 64MB 이하의 메모리 사용 

**입력**
> 첫 줄: 테스트 케이스의 수 C (C <= 20)  
  테스트 케이스:   
  첫 번째 줄: 멤버들의 성별  
  두 번째 줄: 팬들의 성별  
  M은 남자, F는 여자  
  멤버와 팬 수 모두 1이상 200,000이하의 정수  
  멤버의 수는 항상 팬의 수 이하

**출력**

모든 멤버가 포옹하는 횟수를 출력합니다.

**예제 입력**
```
4
FFFMMM
MMMFFF
FFFFF
FFFFFFFFFF
FFFFM
FFFFFMMMMF
MFMFMFFFMMMFMF
MMFFFFFMFFFMFFFFFFMFFFMFFFFMFMMFFFFFFF
```

**예졔 출력**
```
1
6
2
2
```

## 7.7 풀이: 팬미팅

가장 단순한 풀이는 하나하나 시뮬레이션 합니다.  
팬의 수를 N, 멤버의 수를 M이라 할때 대략 O(NM-M^2)이 걸립니다.  
N과 M이 각각 20만에 달하는 수라는 걸 생각하면 풀기 어렵습니다.  

**곱셈으로의 변형**

이 문제를 빠르게 푸는 방법은 큰 수의 곱셈과 비슷합니다.

```java
private static int fanMeeting(String members, String fans) {
  int N = members.length();
  int M = fans.length();
  int[] A = new int[N];
  int[] B = new int[M];

  for (int i = 0; i < N; i++) {
    A[i] = members.charAt(i) == 'M' ? 1 : 0;
  }
  for (int i = 0; i < M; i++) {
    B[M - i - 1] = fans.charAt(i) == 'N' ? 1 : 0;
  }

  ArrayList<Integer> C = karatsuba(A, B);
  int allHugs = 0;
  for (int i = N - 1; i < M; ++i) {
    if (C.get(i) == 0)
      ++allHugs;
  }
  
  return allHugs;
}
```