---
layout: post
title:  "JPA Bulk Insert"
date:   2022-05-15 00:01:00 +0900
category: backend
tags: ["backend"]
keywords: ["backend"]
---

## 대량의 데이터를 Insert한다면
적은 데이터를 insert 한다면 DB와 네트워크 연결이 시간이 제일 오래 소요되기 때문에 개수가 늘어도 큰 차이가 나지 않습니다.
하지만 대량의 데이터를 입력한다면 방법에 따라 성능이 많이 차이날 수 있습니다.

### 트랜잭션을 하나로 묶기
```sql
start transaction;
insert into table1 (id, name) values (1, 'name1');
insert into table1 (id, name) values (2, 'name2');
commit;
```

트랜잭션을 열고 닫는 데도 시간이 들기 때문에 작업을 트랜잭션 하나로 묶어주면 조금이라도 성능이 올라갑니다.

### Bulk insert 사용하기
```sql
insert into table1 (id, name) values (1, 'name1'), (2, 'name2');
```

MySQL에서는 Bulk Insert라고 불리는 방법으로 여러 row를 한 번에 입력하는 방법입니다.
이렇게 여러 row를 입력하는 경우 unique 제약조건이나, 외래 키 제약조건을 임시적으로 꺼두면 성능이 더 올라갈 수 있습니다.

```
SET unique_checks=0;
SET foreign_key_checks=0;

... insert

SET unique_checks=1;
SET foreign_key_checks=1;
```

여러 row를 insert하는 경우에 데이터 패킷의 크기가 너무 커서 못 받을 수 있습니다.

```sql
show global variables like 'max_allowed_packet'
```

이 때 필요한만큼 `max_allowed_packet` 크기를 키워주면 됩니다.

## JPA Bulk Insert
JPA에서도 대량의 데이터를 insert하는 경우 bulk insert 방식을 지원합니다. entitymanager가 flush 될 때까지 데이터를 모아서
flush할 때 bulk insert로 처리할 수 있습니다. bulk insert를 위해선 여러 설정이 필요합니다.

### Batch Size 설정
`jdbc batch_size` 값을 설정하면 크기만큼 sql문을 모아서 한 번에 DB 서버에 요청합니다.
`batch_size`가 정해져있는 이유는 모든 엔티티가 영속성 컨텍스트에 올라가면 `OutOfMemoryException`이 발생할 수 있어
batch_size를 기준으로 flush()와 clear() 작업을 진행해서 입니다.

```yaml
spring.jpa.properties.hibernate.jdbc.batch_size: 20
```

### order_inserts, order_updates 설정
같은 테이블에 대한 insert나 update가 모여 있지 않으면 batch 처리를 할 수 없습니다.
`order_inserts` 와 `order_updates`를 설졍해주면 같은 테이블에 insert끼리 묶어줍니다.

```yml
spring.jpa.properties.hibernate.order_inserts: true
spring.jpa.properties.hibernate.order_updates: true
```

### mysql datasource url 설정
```
spring.datasource.url: jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=true
```
`rewriteBatchedStatements` 옵션을 적용해줘야 여러 insert 쿼리를 bulk insert 방식으로 재작성해줍니다.
이렇게 재작성된 쿼리는 Hibernate에 찍히는 SQL 로그와 달라지는데 바뀐 쿼리를 보고 싶은 경우
`profileSQL=true` 를 추가해주면 실제 mysql 쿼리를 볼 수 있습니다.

## GenerationType.Identity 에서의 문제
MySQL에서 Id 자동 생성 전략을 사용하는 경우 Identity 전략을 주로 사용합니다.
문제는 Identity 전략의 경우 다음 Id를 받아오기 위해서 insert를 해야하기 때문에 bulk insert 작업을 지원하지 않습니다.
따라서 bulk insert를 사용하려면 2가지 해결책이 있습니다.

### 해결책 1. Id 자동 생성 전략 변경
Id 자동 전략을 Sequence 전략이나 Table 전략으로 변경하는 방법을 사용하면 사용이 가능해집니다.
다만 이 방식에서도 주의할 점은 기본 id 생성은 하나씩 생성되기 때문에 생성할 Id 크기를 지정해줘야합니다.

```java
    @Id
    @GenericGenerator(
            name = "sequence-generator",
            strategy = "org.hibernate.id.enhanced.SequenceStyleGenerator",
            parameters = {
                    @Parameter(name = "sequence_name", value = "hibernate_sequence"),
                    @Parameter(name = "optimizer", value = "pooled"),
                    @Parameter(name = "initial_value", value = "1"),
                    @Parameter(name = "increment_size", value = "100")
            }
    )
    @GeneratedValue(
            strategy = GenerationType.SEQUENCE,
            generator = "SequenceGenerator"
    )
    private Long id;
```

### 해결책 2: JDBC 사용하기
JPA를 꼭 써야만 하는 게 아니라면 bulk insert 작업을 JDBC로 분리할 수 도 있습니다.
jdbcTemplate의 batchUpdate() 메서드를 사용해 bulk insert가 가능해집니다.

```
jdbcTemplate.batchUpdate("INSERT INTO MEMBER(`NAME`) VALUES(?)",
new BatchPreparedStatementSetter() {
    @Override
    public void setValues(PreparedStatement ps, int i) throws SQLException {
        ps.setString(1, "member" + i);
    }

    @Override
    public int getBatchSize() {
        return 1000;
    }
});
```

## 결론
JPA 로만 작성한다면 키 자동 생성 전략을 바꾸는 게 좋습니다.
하지만 JDBC를 사용했을 때 자동 생성 전략을 바꾼 것보다 대체적으로 속도도 빨랐고 키 자동 생성 전략을 그대로 사용할 수 있습니다.
