<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><meta name="google-site-verification" content="t9jriQOGsOEGOgq2XbZl6_3pnAgAIIlxYDUR8dMKeqI"/><link rel="icon" href="/favicon.ico"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=${process.env.NEXT_PUBLIC_GOOGLE_ANALYTICS}"></script><script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){dataLayer.push(arguments);}
                    gtag('js', new Date());

                    gtag('config', undefined);
                </script><meta name="next-head-count" content="8"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-eb1296e2ea1b0bf3.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-7b056bee4cd8c8ba.js" defer=""></script><script src="/_next/static/SnfS2hY1xd_gWtYQjQ1Z9/_buildManifest.js" defer=""></script><script src="/_next/static/SnfS2hY1xd_gWtYQjQ1Z9/_ssgManifest.js" defer=""></script><script src="/_next/static/SnfS2hY1xd_gWtYQjQ1Z9/_middlewareManifest.js" defer=""></script><style id="__jsx-3f51d5b7c2116204">header.jsx-3f51d5b7c2116204{display:grid;
color:#0070f3;
background-color:#1e1e1e;
grid-template-columns:32fr 40fr 25fr;
grid-template-rows:5rem;
position:fixed;
width:100%;
padding:0.5rem 2rem;
height:5rem;
z-index:300;
opacity:0.95}
.link.jsx-3f51d5b7c2116204:hover{color:#7bd694}
input[type="checkbox"].jsx-3f51d5b7c2116204{display:none}
label.jsx-3f51d5b7c2116204{width:2rem;
height:2rem;
border:0.3rem solid #FFFFFF;
border-radius:1rem;
display:inline-block;
margin-top:1.5rem;
margin-left:2rem;
cursor:pointer}
label.jsx-3f51d5b7c2116204:hover{border-color:#7bd694}
input[type="checkbox"].jsx-3f51d5b7c2116204:checked+label.jsx-3f51d5b7c2116204{border-color:#7bd694}
aside.jsx-3f51d5b7c2116204{position:fixed;
margin-top:5rem}
@media (max-width:1080px) {.bar.jsx-3f51d5b7c2116204{display:none}
header.jsx-3f51d5b7c2116204{grid-template-columns:1fr 1fr}}
.home.jsx-3f51d5b7c2116204{font-size:2.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
padding-left:2rem;
padding-bottom:1rem;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-text-decoration:none;
text-decoration:none}
.about.jsx-3f51d5b7c2116204{font-size:1.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
padding-bottom:1rem;
padding-right:2rem;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-flex-direction:row-reverse;
-ms-flex-direction:row-reverse;
flex-direction:row-reverse}
.category.jsx-3f51d5b7c2116204{display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center}</style><style id="__jsx-506446869">a.jsx-506446869{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-506446869:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-2105002209">a.jsx-2105002209{display:block;
margin-left:20px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:120px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-2105002209:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-ba6267904dd67a4c">aside.jsx-ba6267904dd67a4c{position:absolute;
right:0;
padding-left:200px;
width:200px;
height:100%}
nav.jsx-ba6267904dd67a4c{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
ul.jsx-ba6267904dd67a4c{list-style:none}
@media (max-width:1080px) {aside.jsx-ba6267904dd67a4c{visibility:hidden}}</style><style id="__jsx-2bb422412afe9fa4">img.jsx-2bb422412afe9fa4{display:inline;
vertical-align:middle}
span.jsx-2bb422412afe9fa4{color:#BBBBBB;
padding-left:0.5rem;
display:inline;
font-size:1rem;
vertical-align:middle}</style><style id="__jsx-2372982303">div.jsx-2372982303{font-size:24pt;
font-weight:bold;
line-height:1.3;
margin-top:2rem;
padding-top:0.5rem}</style><style id="__jsx-2767058302">div.jsx-2767058302{font-size:16pt;
font-weight:bold;
line-height:1.3;
margin-top:2rem;
padding-top:0.5rem}</style><style id="__jsx-6ec3cf284346852c">article.jsx-6ec3cf284346852c{display:block;
margin:0 auto;
padding:0 1rem}
h1.jsx-6ec3cf284346852c{font-size:3rem;
margin-bottom:5px}
.head.jsx-6ec3cf284346852c{margin-bottom:2rem}
.container.jsx-6ec3cf284346852c{width:100%;
max-width:35rem;
margin:0 auto;
line-height:1.625}
@media (max-width:1080px) {aside.jsx-6ec3cf284346852c{position:static;
height:auto}
.container.jsx-6ec3cf284346852c{max-width:40rem}}</style><style id="__jsx-243dc63d52768b84">.content{max-width:40rem}</style><style id="__jsx-acfe784ee19a4513">.github.jsx-acfe784ee19a4513{font-size:1rem;
display:inline-block;
text-align:center;
width:8rem;
height:2rem;
margin:0 auto}
.github.jsx-acfe784ee19a4513:hover{background-color:#4d4747;
box-shadow:0 0 0.6rem rgb(0 0 0 / 60%);
-webkit-transform:translate(0, -0.4rem);
-moz-transform:translate(0, -0.4rem);
-ms-transform:translate(0, -0.4rem);
transform:translate(0, -0.4rem)}</style><style id="__jsx-43ca208974c5fcc2">footer.jsx-43ca208974c5fcc2{height:6rem;
padding:0 2rem;
text-align:center;
margin:0 auto;
display:grid;
grid-template-columns:1fr 1fr}
span.jsx-43ca208974c5fcc2{font-size:0.8rem;
padding:3rem 0}
@media (min-width:720px) {footer.jsx-43ca208974c5fcc2{max-width:35rem;
padding:0 2rem;
margin:0 auto}}</style><style id="__jsx-1d03646c56579e3c">*{color:#AAA;
box-sizing:border-box}
html, body{padding:0;
margin:0;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
background:#1e1e1e}
a{color:#AAA;
-webkit-text-decoration:none;
text-decoration:none}
main{background:#1e1e1e;
min-height:100vh;
height:100%;
padding:8rem 0 0 0;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center}
strong{color:#a964a7}
code{color:#eb5757;
background:#2c2c2c;
font-weight:bold;
font-size:0.85rem;
border-radius:3px;
padding:0.2em 0.4em;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif}
blockquote{border-left:3px solid currentcolor;
padding-left:1rem;
padding-right:1rem;
width:100%}
article{position:relative}
.hljs{font-size:0.8rem;
background:#333;
font-family:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
display:block;
color:#ddd;
border-radius:5px;
overflow:auto;
padding:1em;
margin:0.6em}
.hljs-doctag, .hljs-meta-keyword, .hljs-name, .hljs-strong{font-weight:bold}
.hljs-code, .hljs-emphasis{font-style:italic}
.hljs-section, .hljs-tag{color:#62c8f3}
.hljs-selector-class, .hljs-selector-id, .hljs-template-variable, .hljs-variable{color:#ade5fc}
.hljs-meta-string, .hljs-string{color:#a2fca2}
.hljs-attr, .hljs-quote, .hljs-selector-attr{color:#7bd694}
.hljs-tag .hljs-attr{color:inherit}
.hljs-attribute, .hljs-title, .hljs-type{color:#ffa}
.hljs-number, .hljs-symbol{color:#d36363}
.hljs-bullet, .hljs-template-tag{color:#b8d8a2}
.hljs-built_in, .hljs-keyword, .hljs-literal, .hljs-selector-tag{color:#fcc28c}
.hljs-code, .hljs-comment, .hljs-formula{color:#888}
.hljs-link, .hljs-selector-pseudo, .hljs-regexp{color:#c6b4f0}
.hljs-meta{color:#fc9b9b}
.hljs-deletion{background:#fc9b9b;
color:#333}
.hljs-addition{background:#a2fca2;
color:#333}
.hljs-operator, .hljs-params, .hljs-property, .hljs-punctuation{}
.hljs-subst{color:#fff}
.hljs a{color:inherit}
.hljs a:focus, .hljs a:hover{color:inherit;
text-decoration:underline}
.hljs mark{background:#555;
color:inherit}</style></head><body><div id="__next" data-reactroot=""><header class="jsx-3f51d5b7c2116204"><div class="jsx-3f51d5b7c2116204 menu bar"><input type="checkbox" id="menu-button" class="jsx-3f51d5b7c2116204"/><label for="menu-button" class="jsx-3f51d5b7c2116204"></label></div><div class="jsx-3f51d5b7c2116204 home"><span class="jsx-3f51d5b7c2116204 link">Ordinary</span></div><div id="about" class="jsx-3f51d5b7c2116204 about"><span class="jsx-3f51d5b7c2116204 link">About</span></div></header><main><div class="jsx-243dc63d52768b84"><div class="jsx-6ec3cf284346852c"><article class="jsx-6ec3cf284346852c container"><aside class="jsx-ba6267904dd67a4c"><nav class="jsx-ba6267904dd67a4c"><ul class="jsx-ba6267904dd67a4c"><li class="jsx-506446869"><a href="#이 책에서 배우는 것" class="jsx-506446869"> <!-- -->이 책에서 배우는 것</a></li><li class="jsx-2105002209"><a href="#대규모 서비스 규모" class="jsx-2105002209"> <!-- -->대규모 서비스 규모</a></li><li class="jsx-2105002209"><a href="#소규모 서비스와 대규모 서비스의 차이" class="jsx-2105002209"> <!-- -->소규모 서비스와 대규모 서비스의 차이</a></li><li class="jsx-2105002209"><a href="#확장성 확보, 부하분산 필요" class="jsx-2105002209"> <!-- -->확장성 확보, 부하분산 필요</a></li><li class="jsx-2105002209"><a href="#다중성 확보" class="jsx-2105002209"> <!-- -->다중성 확보</a></li><li class="jsx-2105002209"><a href="#효율적 운용 필요" class="jsx-2105002209"> <!-- -->효율적 운용 필요</a></li><li class="jsx-2105002209"><a href="#개발자 수, 개발방법의 변화" class="jsx-2105002209"> <!-- -->개발자 수, 개발방법의 변화</a></li><li class="jsx-2105002209"><a href="#대규모 데이터량에 대한 대처" class="jsx-2105002209"> <!-- -->대규모 데이터량에 대한 대처</a></li><li class="jsx-506446869"><a href="#계속 성장하는 서비스와 대규모화의 벽" class="jsx-506446869"> <!-- -->계속 성장하는 서비스와 대규모화의 벽</a></li><li class="jsx-506446869"><a href="#대규모 데이터로의 쿼리" class="jsx-506446869"> <!-- -->대규모 데이터로의 쿼리</a></li><li class="jsx-2105002209"><a href="#대규모 데이터 처리의 어려운 점" class="jsx-2105002209"> <!-- -->대규모 데이터 처리의 어려운 점</a></li><li class="jsx-2105002209"><a href="#디스크는 왜 늦을까?" class="jsx-2105002209"> <!-- -->디스크는 왜 늦을까?</a></li><li class="jsx-2105002209"><a href="#OS 레벨에서의 연구" class="jsx-2105002209"> <!-- -->OS 레벨에서의 연구</a></li><li class="jsx-2105002209"><a href="#전송속도, 버스의 속도차" class="jsx-2105002209"> <!-- -->전송속도, 버스의 속도차</a></li><li class="jsx-2105002209"><a href="#Linux 단일 호스트의 분하" class="jsx-2105002209"> <!-- -->Linux 단일 호스트의 분하</a></li><li class="jsx-2105002209"><a href="#규모 조정의 요소" class="jsx-2105002209"> <!-- -->규모 조정의 요소</a></li><li class="jsx-506446869"><a href="#대규모 데이터를 다루기 위한 기초지식" class="jsx-506446869"> <!-- -->대규모 데이터를 다루기 위한 기초지식</a></li><li class="jsx-2105002209"><a href="#대규모 데이터를 다루는 세가지 급소" class="jsx-2105002209"> <!-- -->대규모 데이터를 다루는 세가지 급소</a></li><li class="jsx-2105002209"><a href="#프로그램 개발의 한층 아래 기초" class="jsx-2105002209"> <!-- -->프로그램 개발의 한층 아래 기초</a></li></ul></nav></aside><div class="jsx-6ec3cf284346852c head"><h1 class="jsx-6ec3cf284346852c">대규모 서비스를 지탱하는 기술 (1 ~ 2)</h1><div class="jsx-2bb422412afe9fa4"><img src="/profile.png" alt="profile" class="jsx-2bb422412afe9fa4"/><span class="jsx-2bb422412afe9fa4">ordilov<!-- --> / <!-- -->2022. 3. 14</span></div></div><div class="jsx-2372982303">대규모 웹 서비스 개발 오리엔테이션</div>
<div id="이 책에서 배우는 것"><h2>이 책에서 배우는 것</h2></div>
<ul>
<li>대규모 웹 서비스 개발이란?</li>
<li>대규모 데이터를 다룰 때의 과제, 다루기 위한 기본적인 사고방식</li>
<li>알고리즘과 데이터 구조의 중요성</li>
<li>RDBMS로 모두 다룰 수 없는 규모의 데이터 처리 방법</li>
<li>대규모 서비스를 될 것을 전제로 한 서버/인프라 시스템의 예외 개념</li>
</ul>
<div id="대규모 서비스 규모"><h3>대규모 서비스 규모</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">일일 100만명 이상의 사용자, 일일 액세스 로그가 기본적으로 GB, DB서버는 테라바이트 수준의 서비스입니다.
데이터를 처리하는 서버는 하드웨어적으로 500대 이상으로 가상화로 다루는 호스트의 수는 1000대 이상입니다.</p>
<div id="소규모 서비스와 대규모 서비스의 차이"><h3>소규모 서비스와 대규모 서비스의 차이</h3></div>
<div id="확장성 확보, 부하분산 필요"><h3>확장성 확보, 부하분산 필요</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">대량의 액세스가 있는 서비스에서는 서버 1대로 처리할 수 없는 부하를 어떻게 처리할 것인지가 가장 큰 문제입니다.
횡적으로 늘리는 스케일 아웃 구조가 최근에 해결하는 트렌드입니다.
저가의 하드웨어를 여러 개 이용하는 것이 고성능 하나보다 저렴하기 때문에 선택합니다.
하지만 분산되어 있기 때문에 생길 수 있는 문제들이 있습니다.</p>
<ul>
<li>사용자의 요청을 어떻게 분배할 것인가? (로드 밸런서)</li>
<li>데이터 동기화는 어떻게 할 것인가? (DB 분산)</li>
<li>네트워크 통신의 지연 시간 (통신의 오버헤드)</li>
</ul>
<div id="다중성 확보"><h3>다중성 확보</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">시스템은 특정 서버가 고장나거나 성능이 저하되더라도 서비스를 계속할 수 있도록 구성할 필요가 있습니다.
서버 대수가 늘어나면 고장률도 필연적으로 올라가는데 이 중 하나가 고장났다고 전체가 고장나서는 안됩니다.
시스템이 고장나면 끝인 구조와 다른 시스템이 처리를 인계 받는 시스템 구축 간에는 큰 차이가 있습니다.</p>
<div id="효율적 운용 필요"><h3>효율적 운용 필요</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">서버가 여러대라면 어떤 서버가 무슨 역할을 하고 있는지, 어떤 상황인지 파악하기 힘듭니다.
부하나, 고장, 디스크 용량, 보안 설정 등 살펴볼 부분이 많습니다.
이를 자동화하고 효율적으로 운용할 수 있는 방법이 필요합니다.</p>
<div id="개발자 수, 개발방법의 변화"><h3>개발자 수, 개발방법의 변화</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">대규모 서비스라면 여러 기술자가 역할을 분담해지는데 표준화가 필요해집니다.
어떤 라이브러리, 프레임워크를 사용하고, 코딩 규약, 버전 관리 등 조정이 필요합니다.</p>
<div id="대규모 데이터량에 대한 대처"><h3>대규모 데이터량에 대한 대처</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">데이터가 많으면 데이터를 모두 메모리에서 처리할 수 없어지고, 캐시 미스로 I/O 처리가 많이 발생합니다.
어떻게 하면 데이터를 적게 가져가서 최리할 수 있을지 고민이 필요합니다.</p>
<div id="계속 성장하는 서비스와 대규모화의 벽"><h2>계속 성장하는 서비스와 대규모화의 벽</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">대규모화되면서 어려워지는 다른 점은 서비스 자체도 계속해서 성장하고 규모가 확대해나가는 점입니다.
서비스가 사용자가 늘다보면 새로운 서비스도 릴리즈하게 됩니다.
그 과정에서 작은 서비스에서는 오픈 소스와 방법을 찾아서 비용 절감을 하고 시행 착오를 겪습니다.
이후 규모가 커지면서 시스템 병목지점을 찾고 I/O 처리가 많이 필요한 쪽은 메모리를, CPU 부하는 CPU 성능을 중요시하게 구성합니다.
그리고 가상화를 도입해서 서버 가동률과 유지 보수성을 높여 갑니다.
서버 인프라, DB 스키마 검색 엔진등을 처리해나가며 개발과 품질 개선을 수행나갑니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">소규모일 때부터 대규모를 가정해서 완벽하게 부하분산을 처리할 수 있는 시스템을 설계하면 비용이 너무 많이 나갑니다.
불완전하게 시작하는 경우가 당연히 훨씬 많으며 문제가 복잡해지기 시작했을 때 수정하는 경우가 많습니다.</p>
<div class="jsx-2372982303">대규모 데이터 처리 입문</div>
<div id="대규모 데이터로의 쿼리"><h2>대규모 데이터로의 쿼리</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">데이터가 커지면 큰 데이터를 조회하면 쿼리를 던져도 결과가 타임아웃 내에 반환하지 못할 수 있습니다.
이는 엄청나게 부하를 많이 주는 것 뿐만 아니라, 서비스에도 장애를 일으킵니다.</p>
<div id="대규모 데이터 처리의 어려운 점"><h3>대규모 데이터 처리의 어려운 점</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">어려운 점 중 하나는 &#x27;메모리 내에서 계산할 수 없다&#x27; 입니다.
메모리 내에서 계산할 수 없으면 디스크를 계속 읽어나가면서 검색해야 합니다.
당연히 I/O 처리는 큰 병목 지점이 됩니다.
메모리와 디스크의 속도 차이는 대략적으로 10^5 ~ 10^6 으로 10만 배에서 100만 배 정도 차이납니다.</p>
<div id="디스크는 왜 늦을까?"><h3>디스크는 왜 늦을까?</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">메모리는 전기적인 부품이기 때문에 물리적 구조와 탐색 속도와 그다지 상관없습니다.
하지만 디스크는 헤드를 이동시켜서 읽어낼 부분을 움직이는 물리적인 시간이 필요합니다.
따라서 메모리에 전부 올릴 수 있다면 데이터 탐색 시 오버헤드가 거의 없습니다.</p>
<div id="OS 레벨에서의 연구"><h3>OS 레벨에서의 연구</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">OS에서 디스크 속도를 조금씩 읽어오면 느리기 때문에 4KB 정도씩 한번에 읽어옵니다.
이렇게 해서 디스크의 회전횟수를 최소화합니다.</p>
<div id="전송속도, 버스의 속도차"><h3>전송속도, 버스의 속도차</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">탐색할 때도 속도의 차이가 있지만 CPU로 데이터를 보내는 버스에서도 속도의 차이가 있습니다.
메모리에서 CPU로 보낼때는 7.5GB/s 정도라면 디스크는 58MB/s로 전송 속도에도 큰 차이가 납니다.
따라서 SSD를 사용해서 탐색속도가 줄더라도 버스 속도를 생각하면 병목이 발생할 수 밖에 없습니다.</p>
<div id="Linux 단일 호스트의 분하"><h3>Linux 단일 호스트의 분하</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">하나의 서버에서 처리할 수 없을 때 복수의 호스트를 사용하는 것이기에, 하나를 충분히 사용할 수 있어야 합니다.
성능을 끌어내는 방법은 서버를 얼마나 사용할 수 있는지 정확하게 파악해야 합니다.
여기서 중요한 점은 추측하지 말고 계측해야 하는 것입니다.</p>
<div class="jsx-2767058302">병목 규명작업의 기본적인 흐름</div>
<div class="jsx-2767058302">Load Average 확인</div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">top이나 uptime으로 시스템의 부하상황을 load average가 낮은데 문제가 있는 경우 외부의 원인을 찾아봅니다.</p>
<div class="jsx-2767058302">CPU, I/O 중 병목 원인 조사</div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">load average가 높은 경우 CPU와 I/O 중 어디에 원인이 있는지 확인합니다.</p>
<ul>
<li>top이나 sar로 프로그램이 문제인지, 시스템 프로그램이 원인인지 확인합니다.</li>
<li>ps로 프로세스나 CPU 사용시간 등을 보며 원인 프로세스를 찾습니다.</li>
<li>프로세스를 찾은 후 상세하게 조사할 경우 strace나 oprofile로 프로파일링합니다.</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">CPU에 부하가 있는 경우는 두 가지 중 하나입니다.</p>
<ul>
<li>디스크나 메모리등 밖의 부분이 원인이 아닙니다.</li>
<li>프로그램에서 CPU에 필요이상의 부하가 걸립니다.</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">I/O 부하가 있는 경우</p>
<ul>
<li>특정 프로세스가 극단적으로 메모리를 소비하고 있는지 ps로 확인합니다.</li>
<li>프로그램의 오류로 메모리를 지나치게 사용하고 있는 경우 개선합니다.</li>
<li>자체적으로 메모리가 부족한 경우 메모리 증설을 검토합니다.</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">OS 튜닝이 기본 성능을 더 뛰어나게 한다기보다 부하 작업을 개선시키는 것으로 보는 것이 좋습니다.</p>
<div id="규모 조정의 요소"><h3>규모 조정의 요소</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">웹 어플리케이션을 확장시킨다고 하면 CPU 부하의 확장성을 확보하기는 쉽습니다.
간단하게 프록시 서버에서 AP서버 그리고 DB 서버로 요청이 이동한다고 생각합니다.
DB 서버에선 I/O 부하가 발생하고 AP 서버는 CPU 부하만 발생합니다.
따라서 AP 서버 호스트가 동일하게 처리만 하면 분산할 수 있고 요청을 분산해줄 로드 밸런서를 구성하면 됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">하지만 I/O 부하의 경우에는 데이터를 쓸 때 어떻게 동기화를 시킬지의 문제가 생깁니다.</p>
<div id="대규모 데이터를 다루기 위한 기초지식"><h2>대규모 데이터를 다루기 위한 기초지식</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">대규모 데이터는 메모리에서 처리하기 어렵고 디스크는 느리며, 분산 작업 처리는 어렵습니다.
이럴 때 어떻게 해결해나갈지 두 가지 관점이 있습니다.</p>
<ul>
<li>프로그램의 작성할 때의 요령</li>
<li>프로그램 개발의 근간이 되는 기초라는 점에서 전제로서 알아두었으면 하는 것</li>
</ul>
<div id="대규모 데이터를 다루는 세가지 급소"><h3>대규모 데이터를 다루는 세가지 급소</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">첫 번째 요령은 &#x27;어떻게 하면 메모리에서 처리를 마칠 수 있을까?&quot; 라는 점입니다.
단순한 것으로는 알고리즘을 이용해 탐색 횟수를 줄이는 것입니다.
다음으로는 데이터를 압축하거나 검색 기술을 이용해 읽는 횟수를 최소화합니다.
이렇게 줄어들게 되면 메모리에 캐싱하기도 쉬워집니다.</p>
<div id="프로그램 개발의 한층 아래 기초"><h3>프로그램 개발의 한층 아래 기초</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">프로그램을 만드는 입장에서 위의 기술들이 중요하다면 그 근간에 필요한 지식들이 있습니다.</p>
<ul>
<li>OS 캐시</li>
<li>분산을 고려한 RDBMS의 운용 방법</li>
<li>대규모 환경에서 사용하는 알고리즘과 데이터 구조</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">AP 서버의 경우는 늘리면 늘릴수록 속도가 빨라지지만 DB 서버는 늘리더라도 의미가 없는 경우가 자주 있습니다.
따라서 환경에 따라서 어떻게 운용할지 알고 있어야 합니다.</p>
<div class="jsx-2767058302">Load average</div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">sar(System Activity Reporter) 명령어를 사용하면 시간대별 CPU 사용률과 I/O 대기 비율을 확인할 수 있습니다.
%user는 사용자 모드의 CPU 사용률을, %system은 시스템 모드에서의 CPU 사용률입니다.
I.O의 경우 %iowait로 확인 가능합니다.</p></article></div></div></main><footer class="jsx-43ca208974c5fcc2"><span class="jsx-43ca208974c5fcc2"><a href="https://github.com/ordilov" class="jsx-acfe784ee19a4513 github">Github 🔗</a></span><span class="jsx-43ca208974c5fcc2">Copyright © Ordilov</span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"대규모 서비스를 지탱하는 기술 (1 ~ 2)","date":"2022-03-15 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"대규모 서비스를 지탱하는 기술 1"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h1: \"h1\",\n      h2: \"h2\",\n      ul: \"ul\",\n      li: \"li\",\n      h3: \"h3\",\n      p: \"p\",\n      h4: \"h4\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h1, {\n        children: \"대규모 웹 서비스 개발 오리엔테이션\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"이 책에서 배우는 것\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"대규모 웹 서비스 개발이란?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"대규모 데이터를 다룰 때의 과제, 다루기 위한 기본적인 사고방식\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"알고리즘과 데이터 구조의 중요성\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"RDBMS로 모두 다룰 수 없는 규모의 데이터 처리 방법\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"대규모 서비스를 될 것을 전제로 한 서버/인프라 시스템의 예외 개념\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"대규모 서비스 규모\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"일일 100만명 이상의 사용자, 일일 액세스 로그가 기본적으로 GB, DB서버는 테라바이트 수준의 서비스입니다.\\n데이터를 처리하는 서버는 하드웨어적으로 500대 이상으로 가상화로 다루는 호스트의 수는 1000대 이상입니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"소규모 서비스와 대규모 서비스의 차이\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"확장성 확보, 부하분산 필요\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"대량의 액세스가 있는 서비스에서는 서버 1대로 처리할 수 없는 부하를 어떻게 처리할 것인지가 가장 큰 문제입니다.\\n횡적으로 늘리는 스케일 아웃 구조가 최근에 해결하는 트렌드입니다.\\n저가의 하드웨어를 여러 개 이용하는 것이 고성능 하나보다 저렴하기 때문에 선택합니다.\\n하지만 분산되어 있기 때문에 생길 수 있는 문제들이 있습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"사용자의 요청을 어떻게 분배할 것인가? (로드 밸런서)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"데이터 동기화는 어떻게 할 것인가? (DB 분산)\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"네트워크 통신의 지연 시간 (통신의 오버헤드)\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"다중성 확보\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"시스템은 특정 서버가 고장나거나 성능이 저하되더라도 서비스를 계속할 수 있도록 구성할 필요가 있습니다.\\n서버 대수가 늘어나면 고장률도 필연적으로 올라가는데 이 중 하나가 고장났다고 전체가 고장나서는 안됩니다.\\n시스템이 고장나면 끝인 구조와 다른 시스템이 처리를 인계 받는 시스템 구축 간에는 큰 차이가 있습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"효율적 운용 필요\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"서버가 여러대라면 어떤 서버가 무슨 역할을 하고 있는지, 어떤 상황인지 파악하기 힘듭니다.\\n부하나, 고장, 디스크 용량, 보안 설정 등 살펴볼 부분이 많습니다.\\n이를 자동화하고 효율적으로 운용할 수 있는 방법이 필요합니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"개발자 수, 개발방법의 변화\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"대규모 서비스라면 여러 기술자가 역할을 분담해지는데 표준화가 필요해집니다.\\n어떤 라이브러리, 프레임워크를 사용하고, 코딩 규약, 버전 관리 등 조정이 필요합니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"대규모 데이터량에 대한 대처\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"데이터가 많으면 데이터를 모두 메모리에서 처리할 수 없어지고, 캐시 미스로 I/O 처리가 많이 발생합니다.\\n어떻게 하면 데이터를 적게 가져가서 최리할 수 있을지 고민이 필요합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"계속 성장하는 서비스와 대규모화의 벽\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"대규모화되면서 어려워지는 다른 점은 서비스 자체도 계속해서 성장하고 규모가 확대해나가는 점입니다.\\n서비스가 사용자가 늘다보면 새로운 서비스도 릴리즈하게 됩니다.\\n그 과정에서 작은 서비스에서는 오픈 소스와 방법을 찾아서 비용 절감을 하고 시행 착오를 겪습니다.\\n이후 규모가 커지면서 시스템 병목지점을 찾고 I/O 처리가 많이 필요한 쪽은 메모리를, CPU 부하는 CPU 성능을 중요시하게 구성합니다.\\n그리고 가상화를 도입해서 서버 가동률과 유지 보수성을 높여 갑니다.\\n서버 인프라, DB 스키마 검색 엔진등을 처리해나가며 개발과 품질 개선을 수행나갑니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"소규모일 때부터 대규모를 가정해서 완벽하게 부하분산을 처리할 수 있는 시스템을 설계하면 비용이 너무 많이 나갑니다.\\n불완전하게 시작하는 경우가 당연히 훨씬 많으며 문제가 복잡해지기 시작했을 때 수정하는 경우가 많습니다.\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"대규모 데이터 처리 입문\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"대규모 데이터로의 쿼리\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"데이터가 커지면 큰 데이터를 조회하면 쿼리를 던져도 결과가 타임아웃 내에 반환하지 못할 수 있습니다.\\n이는 엄청나게 부하를 많이 주는 것 뿐만 아니라, 서비스에도 장애를 일으킵니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"대규모 데이터 처리의 어려운 점\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"어려운 점 중 하나는 '메모리 내에서 계산할 수 없다' 입니다.\\n메모리 내에서 계산할 수 없으면 디스크를 계속 읽어나가면서 검색해야 합니다.\\n당연히 I/O 처리는 큰 병목 지점이 됩니다.\\n메모리와 디스크의 속도 차이는 대략적으로 10^5 ~ 10^6 으로 10만 배에서 100만 배 정도 차이납니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"디스크는 왜 늦을까?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"메모리는 전기적인 부품이기 때문에 물리적 구조와 탐색 속도와 그다지 상관없습니다.\\n하지만 디스크는 헤드를 이동시켜서 읽어낼 부분을 움직이는 물리적인 시간이 필요합니다.\\n따라서 메모리에 전부 올릴 수 있다면 데이터 탐색 시 오버헤드가 거의 없습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"OS 레벨에서의 연구\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"OS에서 디스크 속도를 조금씩 읽어오면 느리기 때문에 4KB 정도씩 한번에 읽어옵니다.\\n이렇게 해서 디스크의 회전횟수를 최소화합니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"전송속도, 버스의 속도차\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"탐색할 때도 속도의 차이가 있지만 CPU로 데이터를 보내는 버스에서도 속도의 차이가 있습니다.\\n메모리에서 CPU로 보낼때는 7.5GB/s 정도라면 디스크는 58MB/s로 전송 속도에도 큰 차이가 납니다.\\n따라서 SSD를 사용해서 탐색속도가 줄더라도 버스 속도를 생각하면 병목이 발생할 수 밖에 없습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Linux 단일 호스트의 분하\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"하나의 서버에서 처리할 수 없을 때 복수의 호스트를 사용하는 것이기에, 하나를 충분히 사용할 수 있어야 합니다.\\n성능을 끌어내는 방법은 서버를 얼마나 사용할 수 있는지 정확하게 파악해야 합니다.\\n여기서 중요한 점은 추측하지 말고 계측해야 하는 것입니다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"병목 규명작업의 기본적인 흐름\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"Load Average 확인\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"top이나 uptime으로 시스템의 부하상황을 load average가 낮은데 문제가 있는 경우 외부의 원인을 찾아봅니다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"CPU, I/O 중 병목 원인 조사\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"load average가 높은 경우 CPU와 I/O 중 어디에 원인이 있는지 확인합니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"top이나 sar로 프로그램이 문제인지, 시스템 프로그램이 원인인지 확인합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"ps로 프로세스나 CPU 사용시간 등을 보며 원인 프로세스를 찾습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"프로세스를 찾은 후 상세하게 조사할 경우 strace나 oprofile로 프로파일링합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"CPU에 부하가 있는 경우는 두 가지 중 하나입니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"디스크나 메모리등 밖의 부분이 원인이 아닙니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"프로그램에서 CPU에 필요이상의 부하가 걸립니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"I/O 부하가 있는 경우\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"특정 프로세스가 극단적으로 메모리를 소비하고 있는지 ps로 확인합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"프로그램의 오류로 메모리를 지나치게 사용하고 있는 경우 개선합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"자체적으로 메모리가 부족한 경우 메모리 증설을 검토합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"OS 튜닝이 기본 성능을 더 뛰어나게 한다기보다 부하 작업을 개선시키는 것으로 보는 것이 좋습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"규모 조정의 요소\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"웹 어플리케이션을 확장시킨다고 하면 CPU 부하의 확장성을 확보하기는 쉽습니다.\\n간단하게 프록시 서버에서 AP서버 그리고 DB 서버로 요청이 이동한다고 생각합니다.\\nDB 서버에선 I/O 부하가 발생하고 AP 서버는 CPU 부하만 발생합니다.\\n따라서 AP 서버 호스트가 동일하게 처리만 하면 분산할 수 있고 요청을 분산해줄 로드 밸런서를 구성하면 됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"하지만 I/O 부하의 경우에는 데이터를 쓸 때 어떻게 동기화를 시킬지의 문제가 생깁니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"대규모 데이터를 다루기 위한 기초지식\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"대규모 데이터는 메모리에서 처리하기 어렵고 디스크는 느리며, 분산 작업 처리는 어렵습니다.\\n이럴 때 어떻게 해결해나갈지 두 가지 관점이 있습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"프로그램의 작성할 때의 요령\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"프로그램 개발의 근간이 되는 기초라는 점에서 전제로서 알아두었으면 하는 것\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"대규모 데이터를 다루는 세가지 급소\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"첫 번째 요령은 '어떻게 하면 메모리에서 처리를 마칠 수 있을까?\\\" 라는 점입니다.\\n단순한 것으로는 알고리즘을 이용해 탐색 횟수를 줄이는 것입니다.\\n다음으로는 데이터를 압축하거나 검색 기술을 이용해 읽는 횟수를 최소화합니다.\\n이렇게 줄어들게 되면 메모리에 캐싱하기도 쉬워집니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"프로그램 개발의 한층 아래 기초\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"프로그램을 만드는 입장에서 위의 기술들이 중요하다면 그 근간에 필요한 지식들이 있습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"OS 캐시\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"분산을 고려한 RDBMS의 운용 방법\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"대규모 환경에서 사용하는 알고리즘과 데이터 구조\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"AP 서버의 경우는 늘리면 늘릴수록 속도가 빨라지지만 DB 서버는 늘리더라도 의미가 없는 경우가 자주 있습니다.\\n따라서 환경에 따라서 어떻게 운용할지 알고 있어야 합니다.\"\n      }), \"\\n\", _jsx(_components.h4, {\n        children: \"Load average\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"sar(System Activity Reporter) 명령어를 사용하면 시간대별 CPU 사용률과 I/O 대기 비율을 확인할 수 있습니다.\\n%user는 사용자 모드의 CPU 사용률을, %system은 시스템 모드에서의 CPU 사용률입니다.\\nI.O의 경우 %iowait로 확인 가능합니다.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"대규모 서비스를 지탱하는 기술 1"},"buildId":"SnfS2hY1xd_gWtYQjQ1Z9","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>