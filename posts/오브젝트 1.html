<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/765fb4fbab0b233a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/765fb4fbab0b233a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1afd36a183130af5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1afd36a183130af5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-46629148a08166c1.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d73c76ad2f51cae7.js" defer=""></script><script src="/_next/static/XivFpzuutAT5YsO2XVez2/_buildManifest.js" defer=""></script><script src="/_next/static/XivFpzuutAT5YsO2XVez2/_ssgManifest.js" defer=""></script><script src="/_next/static/XivFpzuutAT5YsO2XVez2/_middlewareManifest.js" defer=""></script><style id="__jsx-2786876435">a.jsx-2786876435{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
[aria-current].jsx-2786876435:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-3340924647">a.jsx-3340924647{display:block;
margin-left:20px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:120px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
[aria-current].jsx-3340924647:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-3b70050e699e9af6">aside.jsx-3b70050e699e9af6{position:absolute;
right:0;
width:200px;
height:100%}
nav.jsx-3b70050e699e9af6{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
@media (max-width:1080px) {aside.jsx-3b70050e699e9af6{visibility:hidden}}</style><style id="__jsx-18f58d3410611438">article.jsx-18f58d3410611438{display:block;
margin:0 auto;
padding:0 1rem}
@media (max-width:800px) {aside.jsx-18f58d3410611438{position:static;
height:auto}}</style><style id="__jsx-76612a042023d019">footer.jsx-76612a042023d019{background-color:#1e1e1e;
padding:20px;
text-align:center}</style><style id="__jsx-853d05b23ef572e2">.container.jsx-853d05b23ef572e2{position:relative;
padding:0 2rem}
@media (min-width:900px) {.container.jsx-853d05b23ef572e2{position:relative;
max-width:1080px;
padding:0 2rem;
margin-left:auto;
margin-right:auto}}</style></head><body><div id="__next" data-reactroot=""><div class="jsx-853d05b23ef572e2 container"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><div class="jsx-18f58d3410611438"><aside class="jsx-3b70050e699e9af6"><nav class="jsx-3b70050e699e9af6"><a href="#객체지향이란 무엇인가" class="jsx-2786876435"> <!-- -->객체지향이란 무엇인가</a><a href="#프로그래밍 패러다임" class="jsx-2786876435"> <!-- -->프로그래밍 패러다임</a><a href="#객체, 설계" class="jsx-2786876435"> <!-- -->객체, 설계</a><a href="#모듈이 가져야하는 세가지 기능" class="jsx-3340924647"> <!-- -->모듈이 가져야하는 세가지 기능</a><a href="#변경에 취약한 코드" class="jsx-3340924647"> <!-- -->변경에 취약한 코드</a><a href="#캡슐화와 응집도" class="jsx-3340924647"> <!-- -->캡슐화와 응집도</a><a href="#절차지향과의 차이" class="jsx-3340924647"> <!-- -->절차지향과의 차이</a><a href="#바라보는 관점" class="jsx-3340924647"> <!-- -->바라보는 관점</a><a href="#좋은 설계" class="jsx-3340924647"> <!-- -->좋은 설계</a></nav></aside><article class="jsx-18f58d3410611438 Post_container__qv178"><div class="jsx-18f58d3410611438 Post_head__hU8yK"><h1 class="jsx-18f58d3410611438 Post_title__MJ8Hr">오브젝트 (1)</h1><div class="jsx-18f58d3410611438 Post_meta__TGwfg"><img src="/profile.png" alt="profile" class="jsx-18f58d3410611438 Post_avatar__KIFLy"/><div class="jsx-18f58d3410611438 Post_profile__wwScp">ordilov /<!-- --> <!-- -->2022. 3. 19</div></div></div><div id="객체지향이란 무엇인가"><h2>객체지향이란 무엇인가</h2> </div>
<p class="MDX_Paragraph__xqVvo">객체지향의 첫 걸음은 클래스가 아니라 객체를 바라보는 것입니다.
두 번째 걸음은 객체는 독립적인 존재가 아닌 협력하는 공통체로 봅니다.
세 번째 걸음은 객체들에게 얼마나 적절한 역할과 책임을 부여하느냐입니다.
마지막 걸음은 앞의 개념들을 프로그래밍 언어 틀에 담아내는 것입니다.</p>
<div id="프로그래밍 패러다임"><h2>프로그래밍 패러다임</h2> </div>
<p class="MDX_Paragraph__xqVvo">프로그래밍 패러다임을 통해 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유합니다.</p>
<div id="객체, 설계"><h2>객체, 설계</h2> </div>
<p class="MDX_Paragraph__xqVvo">&quot;이론이 먼저일까, 실무가 먼저일까?&quot;
아무것도 없는 상태에서 이론보다는 실무를 관찰한 결과를 바탕으로 이론을 정립합니다.
소프트웨어도 실무에서 반복적으로 적용되된 기법들이 이론화한 것들이 대부분입니다.
따라서 이론처럼 개념을 먼저 보는 것보다 코드 그 자체로 이해하는데 더 도움이 됩니다.</p>
<div id="모듈이 가져야하는 세가지 기능"><h3>모듈이 가져야하는 세가지 기능</h3> </div>
<ul>
<li>실행 중에 제대로 동작</li>
<li>변경을 위해 존재</li>
<li>코드를 읽는 사람과 의사소통</li>
</ul>
<p class="MDX_Paragraph__xqVvo">제대로 동작하더라도 변경이 용이하지 않고 읽기 어려우면 고칠 필요가 있습니다.</p>
<div id="변경에 취약한 코드"><h3>변경에 취약한 코드</h3> </div>
<p class="MDX_Paragraph__xqVvo">객체 사이의 의존성이 있는 경우 변경에 영향을 받을 수 있습니다.
최소한의 의존성을 유지하면서 불필요한 의존성을 제거하는 것이 목표입니다.
의존성이 과한 경우를 가리켜 결합도가 높다고 말합니다.
결합도를 낮추기 위해선 객체들을 자율적인 존재로 만들어야 합니다.</p>
<p class="MDX_Paragraph__xqVvo">자율적으로 만들면서 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 합니다.
캡슐화를 통해 객체 내부 접근을 제한하면 객체와 객체 사이 결합도를 낮출 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo">객체가 의존하는 것은 인터페이스에만 의존하고 구현은 인스턴스로 제공합니다.
인터페이스만 공개하는 것은 결합도를 낮추고 변경하기 쉬운 코드의 가장 기본적인 설계 원칙입니다.</p>
<div id="캡슐화와 응집도"><h3>캡슐화와 응집도</h3> </div>
<p class="MDX_Paragraph__xqVvo">객체가 밀접하게 연관된 작업만 수행하고 연관성 없는 작업은 다른 객체로 위임하면 응집도가 높다고 말합니다.
자율적인 객체를 통해 결합도를 낮추고 응집도를 높일 수 있습니다.</p>
<div id="절차지향과의 차이"><h3>절차지향과의 차이</h3> </div>
<p class="MDX_Paragraph__xqVvo">절차지향에서는 데이터와 프로세스를 구분해서 수동적으로 일을 처리합니다.
객체지향은 데이터를 사용하는 프로세스가 객체 내부에 함께 존재합니다.</p>
<p class="MDX_Paragraph__xqVvo">두 방식의 근본적인 차이는 책임의 이동입니다.
절차지향에서는 프로세스를 실행하는 부분에서 전체의 작업을 도맡아합니다.
객체지향에서는 각 작업을 개별 객체에게 위임시켜 스스로 일을 책임집니다.
즉 데이터를 사용하는 프로세스가 별도의 객체에 있다면 절차형일 확률이 높습니다.</p>
<div id="바라보는 관점"><h3>바라보는 관점</h3> </div>
<p class="MDX_Paragraph__xqVvo">실생활에서 무생물은 수동적인 존재이지만 객체지향에선 능동적인 존재가 됩니다.
사람인 것처럼 의인화해서 무생물도 자율적으로 행동해야 합니다.</p>
<div id="좋은 설계"><h3>좋은 설계</h3> </div>
<ul>
<li>오늘 완성해야하는 기능을 구현하는 코드</li>
<li>동시에 내일 쉽게 변경할 수 있는 코드</li>
</ul>
<p class="MDX_Paragraph__xqVvo">변경을 수용한 설계가 중요한 이유는 요구사항은 항상 변경되기 때문입니다.
개발을 시작하는 시점에서 모든 요구사항을 만족시키는 것은 불가능에 가깝습니다.
또 버그는 변경할 때 추가될 가능성이 높습니다.
버그가 발생하는게 두려워 변경하지 않으려할 수 있기에 유연한 설계가 필요합니다.</p></article></div><footer class="jsx-76612a042023d019"></footer></div><footer class="jsx-76612a042023d019"></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"오브젝트 (1)","date":"2022-03-20 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"오브젝트 1"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      h3: \"h3\",\n      ul: \"ul\",\n      li: \"li\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"객체지향이란 무엇인가\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체지향의 첫 걸음은 클래스가 아니라 객체를 바라보는 것입니다.\\n두 번째 걸음은 객체는 독립적인 존재가 아닌 협력하는 공통체로 봅니다.\\n세 번째 걸음은 객체들에게 얼마나 적절한 역할과 책임을 부여하느냐입니다.\\n마지막 걸음은 앞의 개념들을 프로그래밍 언어 틀에 담아내는 것입니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"프로그래밍 패러다임\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"프로그래밍 패러다임을 통해 개발자 공동체가 동일한 프로그래밍 스타일과 모델을 공유합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"객체, 설계\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"\\\"이론이 먼저일까, 실무가 먼저일까?\\\"\\n아무것도 없는 상태에서 이론보다는 실무를 관찰한 결과를 바탕으로 이론을 정립합니다.\\n소프트웨어도 실무에서 반복적으로 적용되된 기법들이 이론화한 것들이 대부분입니다.\\n따라서 이론처럼 개념을 먼저 보는 것보다 코드 그 자체로 이해하는데 더 도움이 됩니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"모듈이 가져야하는 세가지 기능\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"실행 중에 제대로 동작\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"변경을 위해 존재\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"코드를 읽는 사람과 의사소통\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"제대로 동작하더라도 변경이 용이하지 않고 읽기 어려우면 고칠 필요가 있습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"변경에 취약한 코드\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체 사이의 의존성이 있는 경우 변경에 영향을 받을 수 있습니다.\\n최소한의 의존성을 유지하면서 불필요한 의존성을 제거하는 것이 목표입니다.\\n의존성이 과한 경우를 가리켜 결합도가 높다고 말합니다.\\n결합도를 낮추기 위해선 객체들을 자율적인 존재로 만들어야 합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"자율적으로 만들면서 객체 내부의 세부적인 사항을 감추는 것을 캡슐화라고 합니다.\\n캡슐화를 통해 객체 내부 접근을 제한하면 객체와 객체 사이 결합도를 낮출 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체가 의존하는 것은 인터페이스에만 의존하고 구현은 인스턴스로 제공합니다.\\n인터페이스만 공개하는 것은 결합도를 낮추고 변경하기 쉬운 코드의 가장 기본적인 설계 원칙입니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"캡슐화와 응집도\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체가 밀접하게 연관된 작업만 수행하고 연관성 없는 작업은 다른 객체로 위임하면 응집도가 높다고 말합니다.\\n자율적인 객체를 통해 결합도를 낮추고 응집도를 높일 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"절차지향과의 차이\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"절차지향에서는 데이터와 프로세스를 구분해서 수동적으로 일을 처리합니다.\\n객체지향은 데이터를 사용하는 프로세스가 객체 내부에 함께 존재합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"두 방식의 근본적인 차이는 책임의 이동입니다.\\n절차지향에서는 프로세스를 실행하는 부분에서 전체의 작업을 도맡아합니다.\\n객체지향에서는 각 작업을 개별 객체에게 위임시켜 스스로 일을 책임집니다.\\n즉 데이터를 사용하는 프로세스가 별도의 객체에 있다면 절차형일 확률이 높습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"바라보는 관점\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"실생활에서 무생물은 수동적인 존재이지만 객체지향에선 능동적인 존재가 됩니다.\\n사람인 것처럼 의인화해서 무생물도 자율적으로 행동해야 합니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"좋은 설계\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"오늘 완성해야하는 기능을 구현하는 코드\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"동시에 내일 쉽게 변경할 수 있는 코드\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"변경을 수용한 설계가 중요한 이유는 요구사항은 항상 변경되기 때문입니다.\\n개발을 시작하는 시점에서 모든 요구사항을 만족시키는 것은 불가능에 가깝습니다.\\n또 버그는 변경할 때 추가될 가능성이 높습니다.\\n버그가 발생하는게 두려워 변경하지 않으려할 수 있기에 유연한 설계가 필요합니다.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"오브젝트 1"},"buildId":"XivFpzuutAT5YsO2XVez2","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>