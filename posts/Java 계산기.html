<!DOCTYPE html><html><head><title class="jsx-4bcab05d92a8f337">Ordinary</title><meta charSet="utf-8" class="jsx-4bcab05d92a8f337"/><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-4bcab05d92a8f337"/><meta name="description" content="Blog" class="jsx-4bcab05d92a8f337"/><link rel="icon" href="/favicon.ico" class="jsx-4bcab05d92a8f337"/><meta name="next-head-count" content="5"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-e6f293849517a11b.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-156a56f6810aebf1.js" defer=""></script><script src="/_next/static/VKJQtL-j8tAlXM3ThDAiF/_buildManifest.js" defer=""></script><script src="/_next/static/VKJQtL-j8tAlXM3ThDAiF/_ssgManifest.js" defer=""></script><script src="/_next/static/VKJQtL-j8tAlXM3ThDAiF/_middlewareManifest.js" defer=""></script><style id="__jsx-4bcab05d92a8f337">header.jsx-4bcab05d92a8f337{display:grid;
color:#0070f3;
background-color:#1e1e1e;
grid-template-columns:32fr 40fr 25fr;
grid-template-rows:5rem;
position:fixed;
width:100%;
padding:0.5rem 2rem;
height:5rem;
z-index:300;
opacity:0.95}
input[type="checkbox"].jsx-4bcab05d92a8f337{display:none}
label.jsx-4bcab05d92a8f337{width:2rem;
height:2rem;
border:0.3rem solid #FFFFFF;
border-radius:1rem;
display:inline-block;
margin-top:1.5rem;
margin-left:2rem;
cursor:pointer}
input[type="checkbox"].jsx-4bcab05d92a8f337:checked+label.jsx-4bcab05d92a8f337{border-color:#7bd694}
aside.jsx-4bcab05d92a8f337{position:fixed;
margin-top:5rem}
@media (max-width:1080px) {.bar.jsx-4bcab05d92a8f337{display:none}
.space.jsx-4bcab05d92a8f337{grid-template-columns:1fr}}
.home.jsx-4bcab05d92a8f337{font-size:2.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
padding-left:2rem;
padding-bottom:1rem;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-text-decoration:none;
text-decoration:none}
.about.jsx-4bcab05d92a8f337{font-size:1.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
padding-bottom:1rem;
padding-right:2rem;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-flex-direction:row-reverse;
-ms-flex-direction:row-reverse;
flex-direction:row-reverse}
.category.jsx-4bcab05d92a8f337{display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-flex-direction:row-reverse;
-ms-flex-direction:row-reverse;
flex-direction:row-reverse}</style><style id="__jsx-506446869">a.jsx-506446869{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-506446869:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-2105002209">a.jsx-2105002209{display:block;
margin-left:20px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:120px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-2105002209:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-ba6267904dd67a4c">aside.jsx-ba6267904dd67a4c{position:absolute;
right:0;
padding-left:200px;
width:200px;
height:100%}
nav.jsx-ba6267904dd67a4c{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
ul.jsx-ba6267904dd67a4c{list-style:none}
@media (max-width:1080px) {aside.jsx-ba6267904dd67a4c{visibility:hidden}}</style><style id="__jsx-2bb422412afe9fa4">img.jsx-2bb422412afe9fa4{display:inline;
vertical-align:middle}
span.jsx-2bb422412afe9fa4{color:#BBBBBB;
padding-left:0.5rem;
display:inline;
font-size:1rem;
vertical-align:middle}</style><style id="__jsx-6ec3cf284346852c">article.jsx-6ec3cf284346852c{display:block;
margin:0 auto;
padding:0 1rem}
h1.jsx-6ec3cf284346852c{font-size:3rem;
margin-bottom:5px}
.head.jsx-6ec3cf284346852c{margin-bottom:2rem}
.container.jsx-6ec3cf284346852c{width:100%;
max-width:35rem;
margin:0 auto;
line-height:1.625}
@media (max-width:1080px) {aside.jsx-6ec3cf284346852c{position:static;
height:auto}
.container.jsx-6ec3cf284346852c{max-width:40rem}}</style><style id="__jsx-243dc63d52768b84">.content{max-width:40rem}</style><style id="__jsx-acfe784ee19a4513">.github.jsx-acfe784ee19a4513{font-size:1rem;
display:inline-block;
text-align:center;
width:8rem;
height:2rem;
margin:0 auto}
.github.jsx-acfe784ee19a4513:hover{background-color:#4d4747;
box-shadow:0 0 0.6rem rgb(0 0 0 / 60%);
-webkit-transform:translate(0, -0.4rem);
-moz-transform:translate(0, -0.4rem);
-ms-transform:translate(0, -0.4rem);
transform:translate(0, -0.4rem)}</style><style id="__jsx-43ca208974c5fcc2">footer.jsx-43ca208974c5fcc2{height:6rem;
padding:0 2rem;
text-align:center;
margin:0 auto;
display:grid;
grid-template-columns:1fr 1fr}
span.jsx-43ca208974c5fcc2{font-size:0.8rem;
padding:3rem 0}
@media (min-width:720px) {footer.jsx-43ca208974c5fcc2{max-width:35rem;
padding:0 2rem;
margin:0 auto}}</style><style id="__jsx-1d03646c56579e3c">*{color:#AAA;
box-sizing:border-box}
html, body{padding:0;
margin:0;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
background:#1e1e1e}
a{color:#AAA;
-webkit-text-decoration:none;
text-decoration:none}
main{background:#1e1e1e;
min-height:100vh;
height:100%;
padding:8rem 0 0 0;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center}
strong{color:#a964a7}
code{color:#eb5757;
background:#2c2c2c;
font-weight:bold;
font-size:0.85rem;
border-radius:3px;
padding:0.2em 0.4em;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif}
blockquote{border-left:3px solid currentcolor;
padding-left:1rem;
padding-right:1rem;
width:100%}
article{position:relative}
.hljs{font-size:0.8rem;
background:#333;
font-family:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
display:block;
color:#ddd;
border-radius:5px;
overflow:auto;
padding:1em;
margin:0.6em}
.hljs-doctag, .hljs-meta-keyword, .hljs-name, .hljs-strong{font-weight:bold}
.hljs-code, .hljs-emphasis{font-style:italic}
.hljs-section, .hljs-tag{color:#62c8f3}
.hljs-selector-class, .hljs-selector-id, .hljs-template-variable, .hljs-variable{color:#ade5fc}
.hljs-meta-string, .hljs-string{color:#a2fca2}
.hljs-attr, .hljs-quote, .hljs-selector-attr{color:#7bd694}
.hljs-tag .hljs-attr{color:inherit}
.hljs-attribute, .hljs-title, .hljs-type{color:#ffa}
.hljs-number, .hljs-symbol{color:#d36363}
.hljs-bullet, .hljs-template-tag{color:#b8d8a2}
.hljs-built_in, .hljs-keyword, .hljs-literal, .hljs-selector-tag{color:#fcc28c}
.hljs-code, .hljs-comment, .hljs-formula{color:#888}
.hljs-link, .hljs-selector-pseudo, .hljs-regexp{color:#c6b4f0}
.hljs-meta{color:#fc9b9b}
.hljs-deletion{background:#fc9b9b;
color:#333}
.hljs-addition{background:#a2fca2;
color:#333}
.hljs-operator, .hljs-params, .hljs-property, .hljs-punctuation{}
.hljs-subst{color:#fff}
.hljs a{color:inherit}
.hljs a:focus, .hljs a:hover{color:inherit;
text-decoration:underline}
.hljs mark{background:#555;
color:inherit}</style></head><body><div id="__next" data-reactroot=""><header class="jsx-4bcab05d92a8f337"><div class="jsx-4bcab05d92a8f337 menu bar"><input type="checkbox" id="menu-button" class="jsx-4bcab05d92a8f337"/><label for="menu-button" class="jsx-4bcab05d92a8f337"></label></div><div class="jsx-4bcab05d92a8f337 home"><a href="/">Ordinary</a></div><div class="jsx-4bcab05d92a8f337 about"><a class="jsx-4bcab05d92a8f337" href="/about">About</a></div></header><main><div class="jsx-243dc63d52768b84"><div class="jsx-6ec3cf284346852c"><article class="jsx-6ec3cf284346852c container"><aside class="jsx-ba6267904dd67a4c"><nav class="jsx-ba6267904dd67a4c"><ul class="jsx-ba6267904dd67a4c"><li class="jsx-506446869"><a href="#✅ 요구사항" class="jsx-506446869"> <!-- -->✅ 요구사항</a></li><li class="jsx-506446869"><a href="#객체지향적으로 구성하기" class="jsx-506446869"> <!-- -->객체지향적으로 구성하기</a></li><li class="jsx-506446869"><a href="#객체지향적으로 구현하기" class="jsx-506446869"> <!-- -->객체지향적으로 구현하기</a></li><li class="jsx-2105002209"><a href="#객체지향 생활체조 원칙" class="jsx-2105002209"> <!-- -->객체지향 생활체조 원칙</a></li><li class="jsx-506446869"><a href="#테스트의 중요성" class="jsx-506446869"> <!-- -->테스트의 중요성</a></li><li class="jsx-506446869"><a href="#예외 처리" class="jsx-506446869"> <!-- -->예외 처리</a></li><li class="jsx-506446869"><a href="#확장에 대한 고민" class="jsx-506446869"> <!-- -->확장에 대한 고민</a></li><li class="jsx-506446869"><a href="#정리" class="jsx-506446869"> <!-- -->정리</a></li></ul></nav></aside><div class="jsx-6ec3cf284346852c head"><h1 class="jsx-6ec3cf284346852c">Java 문자열 계산기</h1><div class="jsx-2bb422412afe9fa4"><img src="/profile.png" alt="profile" class="jsx-2bb422412afe9fa4"/><span class="jsx-2bb422412afe9fa4">ordilov<!-- --> / <!-- -->2022. 3. 27</span></div></div><p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">Java 문자열 계산기는 객체지향과 테스트 코드를 연습할 때 많이 이용되는 프로젝트입니다.
간단하게 콘솔로 입출력을 받고 들어온 문자열을 이용해 숫자 계산을 하는 프로그램입니다.
객체지향적으로 구성해보려고 했을 때 어떤 고민을 했는지 공유하려합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">객체를 설계할 때 혼자 고민해서 만들려했지만 어떤 것이 좋은 설계인지 고민하다 시작하는 것부터 힘들었습니다.
저처럼 시작하기 어려운 분들이 봤을 때 도움이 될 수도 있는 방법을 공유하려 합니다.
이렇게 구성하라는 게 아니라 어떤 식으로 생각이 흘러갔는지 봐주시면 감사하겠습니다.</p>
<div id="✅ 요구사항"><h2>✅ 요구사항</h2></div>
<ul>
<li>객체지향적으로 구현하기</li>
<li>+, -, *, / 연산자 계산하기</li>
<li>연산자 우선순위 적용하기</li>
<li>테스트 코드 구현하기</li>
<li>맵 자료구조로 연산 결과 저장하기</li>
</ul>
<div id="객체지향적으로 구성하기"><h2>객체지향적으로 구성하기</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">객체지향적으로 구현하기 위한 제일 첫 번째 방법은 만들려는 객체에 대해서 이해가 필요하다고 생각합니다.
실무에서도 도메인에 대한 지식이 없는데, 설계를 시작한다는 건 오로지 상상과 예측에 맡기는 것이니까요.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">객체에 대해 어렴풋이만 알고 있다고 느끼면, 실제로는 어떤 식으로 구성되어 있는지 검색해보면 도움이 됩니다.
예를 들어 자동차에 대한 프로젝트를 만들어야 하는데 부품에 대해 보디, 바퀴, 엔진 밖에 모르면
객체도 본래의 역할보다 훨씬 크게 나눌 수 밖에 없습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">그래서 저는 계산기를 어떻게 나눠야할지 알기 위해 실제 계산기는 어떤지 찾아보게 되었습니다.
검색해보면 전자 계산기에 대한 내용을 쉽게 찾을 수 있고 구성은 CPU와 비슷하다는 걸 찾을 수 있습니다.
<img class="content" src="/image/calculator/cpu.gif" alt="CPU"/></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">복잡해 보일 수도 있지만 우리가 원하는 건 구성 요소와 객체 간의 관계만 보면 됩니다.
CPU를 계산기라고 생각하고 Input, Output, Memory는 외부에서 계산기가 의존하는 객체로 구성할 수 있습니다.
그리고 CPU 내부나머지 구성을 그대로 가져오겠습니다.</p>
<ul>
<li>Control Unit</li>
<li>Processor</li>
<li>Registers</li>
<li>Combinational Logic</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">흐름은 빨간 색 선이 흐름 제어이고 검은 색 선이 데이터의 이동 흐름입니다.
이 중에서 어떻게 객체끼리 메시지를 보낼지가 중요하므로 빨간색 선 위주로 생각해봤습니다.</p>
<ul>
<li>Input을 받으면 CPU로 문자열을 넘겨 Control Unit에게 명령합니다.</li>
<li>Control Unit은 받은 문자열을 파싱, 검증, 다음 명령 요청, 전체적인 흐름을 맡습니다.</li>
<li>Processor는 Control Unit이 요청하는 Register에 저장이나, Logic을 처리합니다.</li>
<li>Logic이나 Register가 처리하는 연산은 한 번에 하나만 처리합니다.</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">우리가 구성할 패키지도 그림과 동일하게 묶을 수 있습니다.</p>
<ul>
<li>Input과 Output을 I/O 패키지 안에 구성할 수 있습니다.</li>
<li>Main Memory를 Persistence 혹은 Repository 패키지 안에 구성합니다.</li>
<li>Control Unit은 전체적인 흐름을 담당하므로 Controller 패키지 등으로 칭할 수 있습니다.</li>
<li>Processor와 내부 구성은 핵심 기능이므로 Service나 Handler로 칭할 수 있습니다.</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">우리가 원하는 건 계산기에 대해 공부하는 게 아니라 객체지향과 테스트 코드를 공부하는 건데 과하다고 느낄 수 있습니다.
하지만 설계에서 꼼꼼하지 않으면 나중에 구현 중에 구조가 맞는지 고민하게 되고 수정할 일이 많아진다고 생각합니다.
나중에 다시 어떻게 구성할지 고민하는 것보다 확실하게 짚고 넘어가면 구성에 대한 불안은 줄어들었습니다.</p>
<div id="객체지향적으로 구현하기"><h2>객체지향적으로 구현하기</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">처음에 코드를 작성할 때 어떤 코드가 잘 짠 코드인지 구별하기는 힘들다고 느꼈습니다.
하지만 나쁜 코드를 발견하는 방법은 생각보다 쉬웠습니다.
우리가 아플 때도 병을 바로 알아차리지 못합니다. 다만 증상이 보이면 의심해볼 수 있습니다.
코드에도 무슨 문제인지는 잘 모르더라도, 나쁜 코드일 때 보이는 증상들이 있습니다.</p>
<div id="객체지향 생활체조 원칙"><h3>객체지향 생활체조 원칙</h3></div>
<ul>
<li>한 메서드에 오직 한 단계의 들여쓰기만 한다.</li>
<li>else 예약어를 쓰지 않는다.</li>
<li>모든 원시값과 문자열을 포장한다.</li>
<li>한 줄에 점을 하나만 찍는다.</li>
<li>줄여쓰지 않는다.</li>
<li>모든 엔티티는 작게 유지한다.</li>
<li>3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.</li>
<li>일급 컬렉션을 쓴다.</li>
<li>게터/세터/프로퍼티를 쓰지 않는다.</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 원칙들을 지키는데 신경 썼습니다.
그러다 보니 메소드들이 더 간결해지고 책임이 적어지는 걸 확인할 수 있었습니다.
어렵게 느껴졌던 부분은 한 단계의 들여쓰기를 지키는 부분이었습니다.
반복문 안에 조건문이 있는 경우 분리하려고 하다보면 너무 과도하게 분리한 것 아닌가 하는 생각도 들었습니다.
하지만 막상 분리하다보니 분리된 기능을 책임지는 객체를 찾을 수 있었고 원칙들을 지킬 수 있었습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">개념적으로 알기는 하지만 실제로 어떻게 적용해야할지 감이 안오던 SOLID 원칙들이 규칙을 지키다보니 자연스럽게 적용되었습니다.
작을 수록 변경하는 이유는 하나가 되었고, 변경에 유연해졌습니다.
처음에는 하나로 처리할 수 있다고 생각했던 인터페이스들도 기능의 분할에 따라 나뉘어졌습니다.</p>
<div id="테스트의 중요성"><h2>테스트의 중요성</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">처음에 테스트를 작성할 때는 테스트의 중요성을 잘 알지 못했습니다.
당연하게 맞다고 생각되는 테스트들을 작성했고, 처음에 테스트를 먼저 작성해 깨질 때를 제외하고 성공만 했습니다.
중요하다고 하지만 실제로 실감하지는 못했고, 그저 습관처럼 작성했습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">그러다 테스트의 효과를 본 건 리팩토링을 진행할 때 였습니다.
Java의 Stack 클래스를 사용하다가 ArrayDeque로 클래스만 바꿨는데 테스트가 깨졌습니다.
테스트가 실패하지 않았더라면 문제가 있다는 것도 모르고 넘어갔을 겁니다.
다른 부분들도 수정을 할 때마다 일일이 실행해보지 않고 테스트를 돌리는 것만으로도 기존까지의 안전성이 보장되는 것에 안심이 됐습니다.</p>
<div id="예외 처리"><h2>예외 처리</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">어느 프로그램이든 예외적인 입력이 들어오기 마련이고 그에 따른 예외 처리가 필요합니다.
이 때 에러가 발생하는 곳에서 처리할지 아니면 따로 한 곳에서 관리할지 선택이 필요합니다.
위의 구조 같은 경우에서는 나름대로 명확한 답이 있었습니다.
Control Unit이라는 객체에서 한 번에 관리했는데, 그 이유는 실제 구조에서도 에러가 발생했을 때 어떻게 처리할지 담당해서입니다.
이처럼 정상적인 경우가 아니라 문제가 발생하면 어느 객체에서 책임지는 게 좋을지 고민이 필요했습니다.</p>
<div id="확장에 대한 고민"><h2>확장에 대한 고민</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">처음 작성할 때 거의 대부분의 객체에 대해서 인터페이스를 먼저 구현하고 클래스를 구현했습니다.
인터페이스를 구현해 교체가 가능해야할 것 같고, 그래야 확장 가능한 구조라고 생각해서 였습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">하지만 리팩토링을 하면서 오히려 만들었던 인터페이스를 줄이게 되었습니다.
객체가 확장 가능한지 고민하기 앞서서, 확장할 필요가 있는지 고민하는 것이 부족했습니다.
만약 어떻게 변경에 대비할지 고민이라면, 그보다 먼저 변경이 필요할지 생각하는 게 먼저였습니다.</p>
<div id="정리"><h2>정리</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">만약 어떻게 설계를 시작할지 고민이라면 다른 것보다 &#x27;무엇을&#x27; 만드는지에 대해 고민이 필요합니다.
무엇을 만들지 정리가 되었다면 &#x27;어떻게&#x27; 만들지 추상적인 게 아닌 정량적으로 측정가능한 규칙이 필요합니다.
마지막으로 만든 것이 좋은 설계인지 고민이 된다면 &#x27;왜&#x27; 그렇게 생각하는지에 대해 고민해보는게 좋습니다.
자기 자신도 이게 &#x27;왜&#x27; 좋은 설계인지 설명할 수 없다면 남들도 그 점을 찾아낼 수 없을테니까요.</p></article></div></div></main><footer class="jsx-43ca208974c5fcc2"><span class="jsx-43ca208974c5fcc2"><a href="https://github.com/ordilov" class="jsx-acfe784ee19a4513 github">Github 🔗</a></span><span class="jsx-43ca208974c5fcc2">Copyright © Ordilov</span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"Java 문자열 계산기","date":"2022-03-28 00:01:00 +0900","category":"java","tags":["project"],"keywords":["project"],"description":"Java 계산기를 구현하며 어떤 식으로 풀어갔는지 정리합니다.","id":"Java 계산기"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      p: \"p\",\n      h2: \"h2\",\n      ul: \"ul\",\n      li: \"li\",\n      img: \"img\",\n      h3: \"h3\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.p, {\n        children: \"Java 문자열 계산기는 객체지향과 테스트 코드를 연습할 때 많이 이용되는 프로젝트입니다.\\n간단하게 콘솔로 입출력을 받고 들어온 문자열을 이용해 숫자 계산을 하는 프로그램입니다.\\n객체지향적으로 구성해보려고 했을 때 어떤 고민을 했는지 공유하려합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체를 설계할 때 혼자 고민해서 만들려했지만 어떤 것이 좋은 설계인지 고민하다 시작하는 것부터 힘들었습니다.\\n저처럼 시작하기 어려운 분들이 봤을 때 도움이 될 수도 있는 방법을 공유하려 합니다.\\n이렇게 구성하라는 게 아니라 어떤 식으로 생각이 흘러갔는지 봐주시면 감사하겠습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"✅ 요구사항\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"객체지향적으로 구현하기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"+, -, *, / 연산자 계산하기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"연산자 우선순위 적용하기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"테스트 코드 구현하기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"맵 자료구조로 연산 결과 저장하기\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"객체지향적으로 구성하기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체지향적으로 구현하기 위한 제일 첫 번째 방법은 만들려는 객체에 대해서 이해가 필요하다고 생각합니다.\\n실무에서도 도메인에 대한 지식이 없는데, 설계를 시작한다는 건 오로지 상상과 예측에 맡기는 것이니까요.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체에 대해 어렴풋이만 알고 있다고 느끼면, 실제로는 어떤 식으로 구성되어 있는지 검색해보면 도움이 됩니다.\\n예를 들어 자동차에 대한 프로젝트를 만들어야 하는데 부품에 대해 보디, 바퀴, 엔진 밖에 모르면\\n객체도 본래의 역할보다 훨씬 크게 나눌 수 밖에 없습니다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그래서 저는 계산기를 어떻게 나눠야할지 알기 위해 실제 계산기는 어떤지 찾아보게 되었습니다.\\n검색해보면 전자 계산기에 대한 내용을 쉽게 찾을 수 있고 구성은 CPU와 비슷하다는 걸 찾을 수 있습니다.\\n\", _jsx(_components.img, {\n          src: \"/image/calculator/cpu.gif\",\n          alt: \"CPU\"\n        })]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"복잡해 보일 수도 있지만 우리가 원하는 건 구성 요소와 객체 간의 관계만 보면 됩니다.\\nCPU를 계산기라고 생각하고 Input, Output, Memory는 외부에서 계산기가 의존하는 객체로 구성할 수 있습니다.\\n그리고 CPU 내부나머지 구성을 그대로 가져오겠습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Control Unit\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Processor\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Registers\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Combinational Logic\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"흐름은 빨간 색 선이 흐름 제어이고 검은 색 선이 데이터의 이동 흐름입니다.\\n이 중에서 어떻게 객체끼리 메시지를 보낼지가 중요하므로 빨간색 선 위주로 생각해봤습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Input을 받으면 CPU로 문자열을 넘겨 Control Unit에게 명령합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Control Unit은 받은 문자열을 파싱, 검증, 다음 명령 요청, 전체적인 흐름을 맡습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Processor는 Control Unit이 요청하는 Register에 저장이나, Logic을 처리합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Logic이나 Register가 처리하는 연산은 한 번에 하나만 처리합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"우리가 구성할 패키지도 그림과 동일하게 묶을 수 있습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"Input과 Output을 I/O 패키지 안에 구성할 수 있습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Main Memory를 Persistence 혹은 Repository 패키지 안에 구성합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Control Unit은 전체적인 흐름을 담당하므로 Controller 패키지 등으로 칭할 수 있습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"Processor와 내부 구성은 핵심 기능이므로 Service나 Handler로 칭할 수 있습니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"우리가 원하는 건 계산기에 대해 공부하는 게 아니라 객체지향과 테스트 코드를 공부하는 건데 과하다고 느낄 수 있습니다.\\n하지만 설계에서 꼼꼼하지 않으면 나중에 구현 중에 구조가 맞는지 고민하게 되고 수정할 일이 많아진다고 생각합니다.\\n나중에 다시 어떻게 구성할지 고민하는 것보다 확실하게 짚고 넘어가면 구성에 대한 불안은 줄어들었습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"객체지향적으로 구현하기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"처음에 코드를 작성할 때 어떤 코드가 잘 짠 코드인지 구별하기는 힘들다고 느꼈습니다.\\n하지만 나쁜 코드를 발견하는 방법은 생각보다 쉬웠습니다.\\n우리가 아플 때도 병을 바로 알아차리지 못합니다. 다만 증상이 보이면 의심해볼 수 있습니다.\\n코드에도 무슨 문제인지는 잘 모르더라도, 나쁜 코드일 때 보이는 증상들이 있습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"객체지향 생활체조 원칙\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"한 메서드에 오직 한 단계의 들여쓰기만 한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"else 예약어를 쓰지 않는다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"모든 원시값과 문자열을 포장한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"한 줄에 점을 하나만 찍는다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"줄여쓰지 않는다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"모든 엔티티는 작게 유지한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"3개 이상의 인스턴스 변수를 가진 클래스를 쓰지 않는다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"일급 컬렉션을 쓴다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"게터/세터/프로퍼티를 쓰지 않는다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 원칙들을 지키는데 신경 썼습니다.\\n그러다 보니 메소드들이 더 간결해지고 책임이 적어지는 걸 확인할 수 있었습니다.\\n어렵게 느껴졌던 부분은 한 단계의 들여쓰기를 지키는 부분이었습니다.\\n반복문 안에 조건문이 있는 경우 분리하려고 하다보면 너무 과도하게 분리한 것 아닌가 하는 생각도 들었습니다.\\n하지만 막상 분리하다보니 분리된 기능을 책임지는 객체를 찾을 수 있었고 원칙들을 지킬 수 있었습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"개념적으로 알기는 하지만 실제로 어떻게 적용해야할지 감이 안오던 SOLID 원칙들이 규칙을 지키다보니 자연스럽게 적용되었습니다.\\n작을 수록 변경하는 이유는 하나가 되었고, 변경에 유연해졌습니다.\\n처음에는 하나로 처리할 수 있다고 생각했던 인터페이스들도 기능의 분할에 따라 나뉘어졌습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"테스트의 중요성\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"처음에 테스트를 작성할 때는 테스트의 중요성을 잘 알지 못했습니다.\\n당연하게 맞다고 생각되는 테스트들을 작성했고, 처음에 테스트를 먼저 작성해 깨질 때를 제외하고 성공만 했습니다.\\n중요하다고 하지만 실제로 실감하지는 못했고, 그저 습관처럼 작성했습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"그러다 테스트의 효과를 본 건 리팩토링을 진행할 때 였습니다.\\nJava의 Stack 클래스를 사용하다가 ArrayDeque로 클래스만 바꿨는데 테스트가 깨졌습니다.\\n테스트가 실패하지 않았더라면 문제가 있다는 것도 모르고 넘어갔을 겁니다.\\n다른 부분들도 수정을 할 때마다 일일이 실행해보지 않고 테스트를 돌리는 것만으로도 기존까지의 안전성이 보장되는 것에 안심이 됐습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"예외 처리\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"어느 프로그램이든 예외적인 입력이 들어오기 마련이고 그에 따른 예외 처리가 필요합니다.\\n이 때 에러가 발생하는 곳에서 처리할지 아니면 따로 한 곳에서 관리할지 선택이 필요합니다.\\n위의 구조 같은 경우에서는 나름대로 명확한 답이 있었습니다.\\nControl Unit이라는 객체에서 한 번에 관리했는데, 그 이유는 실제 구조에서도 에러가 발생했을 때 어떻게 처리할지 담당해서입니다.\\n이처럼 정상적인 경우가 아니라 문제가 발생하면 어느 객체에서 책임지는 게 좋을지 고민이 필요했습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"확장에 대한 고민\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"처음 작성할 때 거의 대부분의 객체에 대해서 인터페이스를 먼저 구현하고 클래스를 구현했습니다.\\n인터페이스를 구현해 교체가 가능해야할 것 같고, 그래야 확장 가능한 구조라고 생각해서 였습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"하지만 리팩토링을 하면서 오히려 만들었던 인터페이스를 줄이게 되었습니다.\\n객체가 확장 가능한지 고민하기 앞서서, 확장할 필요가 있는지 고민하는 것이 부족했습니다.\\n만약 어떻게 변경에 대비할지 고민이라면, 그보다 먼저 변경이 필요할지 생각하는 게 먼저였습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"정리\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"만약 어떻게 설계를 시작할지 고민이라면 다른 것보다 '무엇을' 만드는지에 대해 고민이 필요합니다.\\n무엇을 만들지 정리가 되었다면 '어떻게' 만들지 추상적인 게 아닌 정량적으로 측정가능한 규칙이 필요합니다.\\n마지막으로 만든 것이 좋은 설계인지 고민이 된다면 '왜' 그렇게 생각하는지에 대해 고민해보는게 좋습니다.\\n자기 자신도 이게 '왜' 좋은 설계인지 설명할 수 없다면 남들도 그 점을 찾아낼 수 없을테니까요.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"Java 계산기"},"buildId":"VKJQtL-j8tAlXM3ThDAiF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>