<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/c0a70d45961d3915.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0a70d45961d3915.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1afd36a183130af5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1afd36a183130af5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-46629148a08166c1.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-35233866829f951d.js" defer=""></script><script src="/_next/static/57A2DKCZy1QwPc-djnB1_/_buildManifest.js" defer=""></script><script src="/_next/static/57A2DKCZy1QwPc-djnB1_/_ssgManifest.js" defer=""></script><script src="/_next/static/57A2DKCZy1QwPc-djnB1_/_middlewareManifest.js" defer=""></script><style id="__jsx-ee3704506c3da47c">aside.jsx-ee3704506c3da47c{position:absolute;
right:0;
width:200px;
height:100%}
nav.jsx-ee3704506c3da47c{top:200px;
margin:0 0 0 40px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
a.jsx-ee3704506c3da47c{display:block;
padding:10px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
@media (max-width:1080px) {aside.jsx-ee3704506c3da47c{visibility:hidden}}</style><style id="__jsx-18f58d3410611438">article.jsx-18f58d3410611438{display:block;
margin:0 auto;
padding:0 1rem}
@media (max-width:800px) {aside.jsx-18f58d3410611438{position:static;
height:auto}}</style><style id="__jsx-76612a042023d019">footer.jsx-76612a042023d019{background-color:#1e1e1e;
padding:20px;
text-align:center}</style><style id="__jsx-853d05b23ef572e2">.container.jsx-853d05b23ef572e2{position:relative;
padding:0 2rem}
@media (min-width:900px) {.container.jsx-853d05b23ef572e2{position:relative;
max-width:1080px;
padding:0 2rem;
margin-left:auto;
margin-right:auto}}</style></head><body><div id="__next" data-reactroot=""><div class="jsx-853d05b23ef572e2 container"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><div class="jsx-18f58d3410611438"><aside class="jsx-ee3704506c3da47c"><nav class="jsx-ee3704506c3da47c"><a href="#전송 계층" class="jsx-ee3704506c3da47c">전송 계층</a><a href="#포트" class="jsx-ee3704506c3da47c">포트</a><a href="#재전송 제어" class="jsx-ee3704506c3da47c">재전송 제어</a><a href="#3 Way HandShaking" class="jsx-ee3704506c3da47c">3 Way HandShaking</a><a href="#4 Way HandShaking" class="jsx-ee3704506c3da47c">4 Way HandShaking</a><a href="#흐름 제어" class="jsx-ee3704506c3da47c">흐름 제어</a><a href="#UDP (User Datagram Protocol)" class="jsx-ee3704506c3da47c">UDP (User Datagram Protocol)</a></nav></aside><article class="jsx-18f58d3410611438 Post_container__qv178"><div class="jsx-18f58d3410611438 Post_head__hU8yK"><h1 class="jsx-18f58d3410611438 Post_title__MJ8Hr">TCP UDP</h1><div class="jsx-18f58d3410611438 Post_meta__TGwfg"><img src="/profile.png" alt="profile" class="jsx-18f58d3410611438 Post_avatar__KIFLy"/><div class="jsx-18f58d3410611438 Post_profile__wwScp">ordilov /<!-- --> <!-- -->2022. 3. 30</div></div></div><div id="전송 계층"><h2>전송 계층</h2> </div>
<p class="MDX_Paragraph__xqVvo">TCP와 UDP는 OSI 7계층이나 TCP/IP 모델 모두에서 <strong>전송 계층</strong>에 해당합니다.
<strong>전송 계층</strong>의 필요성을 알기 위해 간단하게 하위 계층에서 패킷을 보내서 받을 때를 보겠습니다.</p>
<ul>
<li>라우터의 라우팅 기능을 통해 요청한 네트워크 망에 아날로그 신호를 전송합니다.</li>
<li>네트워크 망 내부에서 IP 주소를 이용해 스위치에서 MAC 주소를 찾습니다.</li>
<li>MAC 주소에 도착한 아날로그 신호를 랜 카드에서 데이터 신호로 변환합니다.</li>
</ul>
<blockquote>
<p class="MDX_Paragraph__xqVvo">다른 네트워크 → 라우터 → 네트워크 망 → 스위치 → 컴퓨터</p>
</blockquote>
<p class="MDX_Paragraph__xqVvo">이런 과정을 거쳤을 때 프로그램에서 데이터를 받으려면 해결해야 하는 부분이 남았습니다.</p>
<ol>
<li>어느 프로그램에서 받은 데이터를 사용할 건가?</li>
<li>데이터가 순서대로 전송되지 않으면 어떻게 할건가?</li>
<li>데이터가 라우터나 스위치 등을 거치면서 손상되거나 유실되면 어떻게 할까?</li>
</ol>
<p class="MDX_Paragraph__xqVvo">먼저 어느 프로그램에서 받은 데이터를 사용할 지를 해결합니다.</p>
<div id="포트"><h2>포트</h2> </div>
<p class="MDX_Paragraph__xqVvo">같은 PC 내에서 여러 프로그램을 사용 중일 때 네트워크로 데이터를 받는다면 구분이 필요합니다.
이때 구분을 위해 사용하는 번호가 <strong>포트</strong>입니다.</p>
<p class="MDX_Paragraph__xqVvo">포트는 16비트로 0~65535 숫자까지 가능합니다.
이 중에서 0 ~ 1023 까지를 <strong>well-known ports</strong> 라고 하고 서버에서 주로 사용합니다.
나머지 번호는 클라이언트가 송신할 때 주로 사용합니다.
웹 브라우저에서 요청하는 경우 포트가 자동으로 할당됩니다.</p>
<p class="MDX_Paragraph__xqVvo"><img src="/image/tcp/port.png" alt=""/></p>
<p class="MDX_Paragraph__xqVvo">예를 들어 구글에 Postman으로 요청하면 송신에는 65478 포트를, 수신에는 443 포트가 사용된 걸 볼 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo">전송 계층에서는 응용 계층에서 넘어온 데이터에 <strong>TCP/UDP 헤더</strong>를 합쳐서 다음 계층에 넘깁니다.
이렇게 데이터와 <strong>TCP/UDP 헤더</strong>를 합친 것을 <strong>세그먼트</strong>라고 합니다.
이때 <strong>TCP/UDP 헤더</strong>에는 송신자와 수신자의 포트가 들어갑니다.
포트를 이용하면서 어느 프로그램으로 전달할지 확인할 수 있습니다.
여기까지만 해도 전송 계층의 중요한 목적 중 하나인 어느 프로그램으로 보낼지를 해결했습니다.
다른 기능들은 추가하려면 신뢰성과 효율성 사이에서 트레이드 오프가 필요합니다.
그 중에서 신뢰성을 우선시하는 TCP(Transmission Control Protocol) 기준으로 설명하겠습니다.</p>
<p class="MDX_Paragraph__xqVvo"><img src="/image/tcp/header1.png" alt=""/></p>
<div id="재전송 제어"><h2>재전송 제어</h2> </div>
<p class="MDX_Paragraph__xqVvo">데이터를 한 번에 보낼 수 있으면 좋겠지만 보낼 수 있는 데이터의 크기는 정해져있습니다.
데이터 크기를 크게 보내면 대역폭을 많이 잡아먹게 되고, 데이터가 유실되거나 하는 경우 처리가 힘들어집니다.
데이터를 쪼개서 보내는 단위를 <strong>패킷</strong>이라고 합니다.
패킷의 최대 크기는 65,535로 실제 데이터 크기는 TCP 헤더 크기를 제외한 값이 됩니다.</p>
<p class="MDX_Paragraph__xqVvo">이렇게 쪼개서 보낼 때 네트워크 환경에 따라 데이터의 순서가 다르게 전송될 수 있습니다.
다음 데이터가 먼저 오거나 하는 식으로 말이죠.
이런 조각난 데이터들을 모아서 원본 데이터로 만드려면 <strong>순서</strong>가 필요합니다.
그리고 <strong>순서</strong>대로 모았을 때 오지 않거나 손상된 데이터는 다시 보내줄 수 있어야 합니다.</p>
<p class="MDX_Paragraph__xqVvo">이런 순서를 일련번호를 통해 전송하고, 어디까지 받았는지 응답을 확인 응답 번호에 담아서 전송합니다.
응답 번호로 받지 못한 값이 있다면 일정 시간 후에 다시 재전송해줍니다.
이렇게 제대로 응답받지 못한 것을 다시 받을 수 있게 보장해주는 것을 <strong>재전송 제어</strong>라고 합니다.</p>
<p class="MDX_Paragraph__xqVvo"><img src="/image/tcp/header2.png" alt=""/></p>
<p class="MDX_Paragraph__xqVvo">어디로 보낼지 정했고, 데이터를 쪼개서 어떤 순서로 보낼지 결정했습니다.
이제 어떤 식으로 전송할지 알아보겠습니다.</p>
<div id="3 Way HandShaking"><h2>3 Way HandShaking</h2> </div>
<p class="MDX_Paragraph__xqVvo">안정적으로 데이터를 보내려면 먼저 서버가 정상적으로 동작하는지 확인해야 합니다.
제대로 동작하는지 확인하기 위해 TCP는 <strong>연결</strong>을 합니다.
<strong>연결</strong>은 단순히 개념적인 것으로 데이터를 보내줄 수 있는지 확인하고 응답을 받는 것입니다.
확인과 응답에 대한 정보는 TCP 헤더 중 <strong>코드 비트</strong>에 포함됩니다.</p>
<p class="MDX_Paragraph__xqVvo"><img src="/image/tcp/header3.png" alt=""/></p>
<p class="MDX_Paragraph__xqVvo">코드 비트는 6비트로 구성되어 있는데 <strong>연결</strong>을 위해서 <code>ACK</code>와 <code>SYN</code>이 사용됩니다.</p>
<p class="MDX_Paragraph__xqVvo"><img src="/image/tcp/codebit.png" alt=""/></p>
<ol>
<li>클라이언트가 <strong>연결 요청</strong>을 위해 <code>SYN</code>에 1을 담아 보냅니다.</li>
<li>서버가 <strong>연결 확립</strong>이 가능하면 <code>ACK</code>, <code>SYN</code>에 1을 담아 보냅니다.</li>
<li>클라이언트가 <strong>연결 확립</strong> 응답을 받았다는 응답을 <code>ACK</code>에 1을 담아 보냅니다.</li>
</ol>
<div id="4 Way HandShaking"><h2>4 Way HandShaking</h2> </div>
<p class="MDX_Paragraph__xqVvo">데이터를 끝까지 다 받았는지 확인하기 위해서 연결 종료할 때도 요청을 주고 받습니다.</p>
<ol>
<li>클라이언트가 <strong>연결 종료</strong>을 위해 <code>FIN</code>에 1을 담아 보냅니다.</li>
<li>서버가 <strong>연결 종료 응답</strong>으로 <code>ACK</code>에 1을 담아 보냅니다.</li>
<li>서버가 <strong>연결 종료 요청</strong>으로 <code>FIN</code>에 1을 담아 보냅니다.</li>
<li>클라이언트가 <strong>연결 종료 응답</strong>으로 <code>ACK</code>에 1을 담아 보냅니다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo">클라이언트가 종료를 보내는 경우는 더 이상 요청할 데이터가 없을 때입니다.
서버가 종료를 보내는 경우는 요청한 데이터를 모두 전송했을 때입니다.
이때 3번에서 서버가 <code>FIN</code>을 보내고 클라이언트가 <code>ACK</code>를 보냈다고 해도 일정 시간동안 연결을 유지합니다.
이유는 <code>FIN</code> 이전에 보냈던 데이터들이 다 가지 않았는데 연결을 바로 종료하면 데이터를 다시 받을 수 없습니다.
그래서 <code>FIN</code>을 받은 이후에도 기간을 두고 데이터를 받고 완료하면 연결을 끊습니다.</p>
<p class="MDX_Paragraph__xqVvo">이렇게 연결을 받고 끊는 것까지 가능하면 어느 정도 속도로 데이터를 보내줘야 할까요?</p>
<div id="흐름 제어"><h2>흐름 제어</h2> </div>
<p class="MDX_Paragraph__xqVvo">데이터를 보낼 수 있는 만큼 빠르게 보내주면 좋아보이지만, 처리 속도가 따라주지 않으면 문제가 됩니다.
받을 수 있는지 확인하는 방법으로는 데이터를 받았다는 확인 응답 번호가 오면 다음 일련 번호를 보내는 것입니다.
이런 방식을 <strong>Stop and Wait</strong> 방식이라고 합니다.</p>
<p class="MDX_Paragraph__xqVvo">하지만 이런 식으로 진행하면 대답이 올 때까지 기다렸다가 다시 보내주는 식으로 속도가 굉장히 느립니다.
이를 해결하기 위해 응답이 오지 않아도 어느 크기 정도는 함께 보냅니다.
이렇게 보낸 값들은 앞선 데이터들이 처리되는 동안 <strong>버퍼</strong> 라는 공간에 저장됩니다.
<strong>버퍼</strong>에서 임시적으로 값을 저장할 수 있지만 크기가 정해져있기 때문에 이보다 적은 크기로 받아야 합니다.
이 크기를 TCP 헤더에서 <strong>윈도우 크기</strong>에 담아 보내주며 <strong>3 Way Handshaking</strong> 중에 함께 보내서 크기를 공유합니다.</p>
<p class="MDX_Paragraph__xqVvo"><img src="/image/tcp/header4.png" alt=""/></p>
<div id="UDP (User Datagram Protocol)"><h2>UDP (User Datagram Protocol)</h2> </div>
<p class="MDX_Paragraph__xqVvo">UDP는 TCP와 달리 헤더에 안전성보다 간단하게 구성됩니다.
그만큼 신뢰성은 떨어지지만 오버헤드가 적습니다.
순서가 보장될 필요가 없거나, 데이터가 손실되도 재전송할 필요가 없을 때 사용됩니다.
데이터의 전송 단위도 TCP와 달리 데이터그램이라는 단위로 전송됩니다.
크기는 똑같이 최대 65535 바이트로, 크기가 넘어가면 잘라서 보냅니다.</p>
<p class="MDX_Paragraph__xqVvo"><img src="/image/tcp/udp.png" alt=""/></p></article></div><footer class="jsx-76612a042023d019"></footer></div><footer class="jsx-76612a042023d019"></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"TCP UDP","date":"2022-03-31 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"TCP UDP"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      strong: \"strong\",\n      ul: \"ul\",\n      li: \"li\",\n      blockquote: \"blockquote\",\n      ol: \"ol\",\n      img: \"img\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"전송 계층\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"TCP와 UDP는 OSI 7계층이나 TCP/IP 모델 모두에서 \", _jsx(_components.strong, {\n          children: \"전송 계층\"\n        }), \"에 해당합니다.\\n\", _jsx(_components.strong, {\n          children: \"전송 계층\"\n        }), \"의 필요성을 알기 위해 간단하게 하위 계층에서 패킷을 보내서 받을 때를 보겠습니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"라우터의 라우팅 기능을 통해 요청한 네트워크 망에 아날로그 신호를 전송합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"네트워크 망 내부에서 IP 주소를 이용해 스위치에서 MAC 주소를 찾습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"MAC 주소에 도착한 아날로그 신호를 랜 카드에서 데이터 신호로 변환합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"다른 네트워크 → 라우터 → 네트워크 망 → 스위치 → 컴퓨터\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 과정을 거쳤을 때 프로그램에서 데이터를 받으려면 해결해야 하는 부분이 남았습니다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"어느 프로그램에서 받은 데이터를 사용할 건가?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"데이터가 순서대로 전송되지 않으면 어떻게 할건가?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"데이터가 라우터나 스위치 등을 거치면서 손상되거나 유실되면 어떻게 할까?\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"먼저 어느 프로그램에서 받은 데이터를 사용할 지를 해결합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"포트\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"같은 PC 내에서 여러 프로그램을 사용 중일 때 네트워크로 데이터를 받는다면 구분이 필요합니다.\\n이때 구분을 위해 사용하는 번호가 \", _jsx(_components.strong, {\n          children: \"포트\"\n        }), \"입니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"포트는 16비트로 0~65535 숫자까지 가능합니다.\\n이 중에서 0 ~ 1023 까지를 \", _jsx(_components.strong, {\n          children: \"well-known ports\"\n        }), \" 라고 하고 서버에서 주로 사용합니다.\\n나머지 번호는 클라이언트가 송신할 때 주로 사용합니다.\\n웹 브라우저에서 요청하는 경우 포트가 자동으로 할당됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/port.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"예를 들어 구글에 Postman으로 요청하면 송신에는 65478 포트를, 수신에는 443 포트가 사용된 걸 볼 수 있습니다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"전송 계층에서는 응용 계층에서 넘어온 데이터에 \", _jsx(_components.strong, {\n          children: \"TCP/UDP 헤더\"\n        }), \"를 합쳐서 다음 계층에 넘깁니다.\\n이렇게 데이터와 \", _jsx(_components.strong, {\n          children: \"TCP/UDP 헤더\"\n        }), \"를 합친 것을 \", _jsx(_components.strong, {\n          children: \"세그먼트\"\n        }), \"라고 합니다.\\n이때 \", _jsx(_components.strong, {\n          children: \"TCP/UDP 헤더\"\n        }), \"에는 송신자와 수신자의 포트가 들어갑니다.\\n포트를 이용하면서 어느 프로그램으로 전달할지 확인할 수 있습니다.\\n여기까지만 해도 전송 계층의 중요한 목적 중 하나인 어느 프로그램으로 보낼지를 해결했습니다.\\n다른 기능들은 추가하려면 신뢰성과 효율성 사이에서 트레이드 오프가 필요합니다.\\n그 중에서 신뢰성을 우선시하는 TCP(Transmission Control Protocol) 기준으로 설명하겠습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header1.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"재전송 제어\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"데이터를 한 번에 보낼 수 있으면 좋겠지만 보낼 수 있는 데이터의 크기는 정해져있습니다.\\n데이터 크기를 크게 보내면 대역폭을 많이 잡아먹게 되고, 데이터가 유실되거나 하는 경우 처리가 힘들어집니다.\\n데이터를 쪼개서 보내는 단위를 \", _jsx(_components.strong, {\n          children: \"패킷\"\n        }), \"이라고 합니다.\\n패킷의 최대 크기는 65,535로 실제 데이터 크기는 TCP 헤더 크기를 제외한 값이 됩니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이렇게 쪼개서 보낼 때 네트워크 환경에 따라 데이터의 순서가 다르게 전송될 수 있습니다.\\n다음 데이터가 먼저 오거나 하는 식으로 말이죠.\\n이런 조각난 데이터들을 모아서 원본 데이터로 만드려면 \", _jsx(_components.strong, {\n          children: \"순서\"\n        }), \"가 필요합니다.\\n그리고 \", _jsx(_components.strong, {\n          children: \"순서\"\n        }), \"대로 모았을 때 오지 않거나 손상된 데이터는 다시 보내줄 수 있어야 합니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이런 순서를 일련번호를 통해 전송하고, 어디까지 받았는지 응답을 확인 응답 번호에 담아서 전송합니다.\\n응답 번호로 받지 못한 값이 있다면 일정 시간 후에 다시 재전송해줍니다.\\n이렇게 제대로 응답받지 못한 것을 다시 받을 수 있게 보장해주는 것을 \", _jsx(_components.strong, {\n          children: \"재전송 제어\"\n        }), \"라고 합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header2.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"어디로 보낼지 정했고, 데이터를 쪼개서 어떤 순서로 보낼지 결정했습니다.\\n이제 어떤 식으로 전송할지 알아보겠습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"3 Way HandShaking\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"안정적으로 데이터를 보내려면 먼저 서버가 정상적으로 동작하는지 확인해야 합니다.\\n제대로 동작하는지 확인하기 위해 TCP는 \", _jsx(_components.strong, {\n          children: \"연결\"\n        }), \"을 합니다.\\n\", _jsx(_components.strong, {\n          children: \"연결\"\n        }), \"은 단순히 개념적인 것으로 데이터를 보내줄 수 있는지 확인하고 응답을 받는 것입니다.\\n확인과 응답에 대한 정보는 TCP 헤더 중 \", _jsx(_components.strong, {\n          children: \"코드 비트\"\n        }), \"에 포함됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header3.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"코드 비트는 6비트로 구성되어 있는데 \", _jsx(_components.strong, {\n          children: \"연결\"\n        }), \"을 위해서 \", _jsx(_components.code, {\n          children: \"ACK\"\n        }), \"와 \", _jsx(_components.code, {\n          children: \"SYN\"\n        }), \"이 사용됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/codebit.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 요청\"\n          }), \"을 위해 \", _jsx(_components.code, {\n            children: \"SYN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"서버가 \", _jsx(_components.strong, {\n            children: \"연결 확립\"\n          }), \"이 가능하면 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \", \", _jsx(_components.code, {\n            children: \"SYN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 확립\"\n          }), \" 응답을 받았다는 응답을 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4 Way HandShaking\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"데이터를 끝까지 다 받았는지 확인하기 위해서 연결 종료할 때도 요청을 주고 받습니다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 종료\"\n          }), \"을 위해 \", _jsx(_components.code, {\n            children: \"FIN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"서버가 \", _jsx(_components.strong, {\n            children: \"연결 종료 응답\"\n          }), \"으로 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"서버가 \", _jsx(_components.strong, {\n            children: \"연결 종료 요청\"\n          }), \"으로 \", _jsx(_components.code, {\n            children: \"FIN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 종료 응답\"\n          }), \"으로 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"클라이언트가 종료를 보내는 경우는 더 이상 요청할 데이터가 없을 때입니다.\\n서버가 종료를 보내는 경우는 요청한 데이터를 모두 전송했을 때입니다.\\n이때 3번에서 서버가 \", _jsx(_components.code, {\n          children: \"FIN\"\n        }), \"을 보내고 클라이언트가 \", _jsx(_components.code, {\n          children: \"ACK\"\n        }), \"를 보냈다고 해도 일정 시간동안 연결을 유지합니다.\\n이유는 \", _jsx(_components.code, {\n          children: \"FIN\"\n        }), \" 이전에 보냈던 데이터들이 다 가지 않았는데 연결을 바로 종료하면 데이터를 다시 받을 수 없습니다.\\n그래서 \", _jsx(_components.code, {\n          children: \"FIN\"\n        }), \"을 받은 이후에도 기간을 두고 데이터를 받고 완료하면 연결을 끊습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이렇게 연결을 받고 끊는 것까지 가능하면 어느 정도 속도로 데이터를 보내줘야 할까요?\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"흐름 제어\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"데이터를 보낼 수 있는 만큼 빠르게 보내주면 좋아보이지만, 처리 속도가 따라주지 않으면 문제가 됩니다.\\n받을 수 있는지 확인하는 방법으로는 데이터를 받았다는 확인 응답 번호가 오면 다음 일련 번호를 보내는 것입니다.\\n이런 방식을 \", _jsx(_components.strong, {\n          children: \"Stop and Wait\"\n        }), \" 방식이라고 합니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"하지만 이런 식으로 진행하면 대답이 올 때까지 기다렸다가 다시 보내주는 식으로 속도가 굉장히 느립니다.\\n이를 해결하기 위해 응답이 오지 않아도 어느 크기 정도는 함께 보냅니다.\\n이렇게 보낸 값들은 앞선 데이터들이 처리되는 동안 \", _jsx(_components.strong, {\n          children: \"버퍼\"\n        }), \" 라는 공간에 저장됩니다.\\n\", _jsx(_components.strong, {\n          children: \"버퍼\"\n        }), \"에서 임시적으로 값을 저장할 수 있지만 크기가 정해져있기 때문에 이보다 적은 크기로 받아야 합니다.\\n이 크기를 TCP 헤더에서 \", _jsx(_components.strong, {\n          children: \"윈도우 크기\"\n        }), \"에 담아 보내주며 \", _jsx(_components.strong, {\n          children: \"3 Way Handshaking\"\n        }), \" 중에 함께 보내서 크기를 공유합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header4.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"UDP (User Datagram Protocol)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"UDP는 TCP와 달리 헤더에 안전성보다 간단하게 구성됩니다.\\n그만큼 신뢰성은 떨어지지만 오버헤드가 적습니다.\\n순서가 보장될 필요가 없거나, 데이터가 손실되도 재전송할 필요가 없을 때 사용됩니다.\\n데이터의 전송 단위도 TCP와 달리 데이터그램이라는 단위로 전송됩니다.\\n크기는 똑같이 최대 65535 바이트로, 크기가 넘어가면 잘라서 보냅니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/udp.png\",\n          alt: \"\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"TCP UDP"},"buildId":"57A2DKCZy1QwPc-djnB1_","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>