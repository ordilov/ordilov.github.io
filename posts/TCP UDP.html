<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><meta name="google-site-verification" content="t9jriQOGsOEGOgq2XbZl6_3pnAgAIIlxYDUR8dMKeqI"/><link rel="icon" href="/favicon.ico"/><script async="" src="https://www.googletagmanager.com/gtag/js?id=G-FW6Q1HTD65"></script><script>
                    window.dataLayer = window.dataLayer || [];
                    function gtag(){dataLayer.push(arguments);}
                    gtag('js', new Date());
                    gtag('config', 'G-FW6Q1HTD65', {
                        page_path: window.location.pathname,
                    });
                </script><meta name="next-head-count" content="8"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-fdf8b39fc84e7477.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d163af0f92121e5f.js" defer=""></script><script src="/_next/static/xyUz5fkL3d3Gja13LWnAp/_buildManifest.js" defer=""></script><script src="/_next/static/xyUz5fkL3d3Gja13LWnAp/_ssgManifest.js" defer=""></script><script src="/_next/static/xyUz5fkL3d3Gja13LWnAp/_middlewareManifest.js" defer=""></script><style id="__jsx-112769295">.square-container.jsx-112769295{display:inline-block}
.square.jsx-112769295{display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-justify-content:center;
justify-content:center;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
width:3rem;
height:3rem;
-webkit-transition:-webkit-transform .7s ease-in-out;
transition:transform .7s ease-in-out}
.square.jsx-112769295:hover{-webkit-transform:rotate(90deg);
-moz-transform:rotate(90deg);
-ms-transform:rotate(90deg);
transform:rotate(90deg)}
.sq1.jsx-112769295{position:absolute;
-webkit-transform:rotate(45deg);
-moz-transform:rotate(45deg);
-ms-transform:rotate(45deg);
transform:rotate(45deg);
width:1rem;
height:1rem;
background:#534f4f}
.sq2.jsx-112769295{position:relative;
-webkit-transform:rotate(45deg) skew(45deg);
-moz-transform:rotate(45deg) skew(45deg);
-ms-transform:rotate(45deg) skew(45deg);
transform:rotate(45deg) skew(45deg);
left:0.85rem;
bottom:0.7rem;
width:1rem;
height:0.5rem;
background:#333131}
.sq3.jsx-112769295{position:relative;
-webkit-transform:rotate(-45deg) skew(-45deg);
-moz-transform:rotate(-45deg) skew(-45deg);
-ms-transform:rotate(-45deg) skew(-45deg);
transform:rotate(-45deg) skew(-45deg);
right:0.85rem;
bottom:0.7rem;
width:1rem;
height:0.5rem;
background:#807979}</style><style id="__jsx-d9da5f49743f60bd">header.jsx-d9da5f49743f60bd{display:grid;
color:#0070f3;
background-color:#1e1e1e;
grid-template-columns:30fr 40fr 30fr;
grid-template-rows:2rem;
position:fixed;
width:100%;
padding:0.5rem 2rem;
height:3rem;
z-index:300;
opacity:0.95}
.link.jsx-d9da5f49743f60bd:hover{color:#7bd694}
input[type="checkbox"].jsx-d9da5f49743f60bd{display:none}
label.jsx-d9da5f49743f60bd{width:2rem;
height:2rem;
border:0.3rem solid #DDDDDD;
border-radius:1rem;
display:inline-block;
cursor:pointer}
label.jsx-d9da5f49743f60bd:hover{background-color:#484848;
border-color:#7bd694}
input[type="checkbox"].jsx-d9da5f49743f60bd:checked+label.jsx-d9da5f49743f60bd{border-color:#7bd694}
aside.jsx-d9da5f49743f60bd{position:fixed;
margin-top:5rem}
@media (max-width:1080px) {.bar.jsx-d9da5f49743f60bd{display:none}
header.jsx-d9da5f49743f60bd{grid-template-columns:1fr 1fr}}
.home.jsx-d9da5f49743f60bd{font-size:2rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-text-decoration:none;
text-decoration:none}
.about.jsx-d9da5f49743f60bd{font-size:1.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
margin-left:auto}
.category.jsx-d9da5f49743f60bd{display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center}</style><style id="__jsx-506446869">a.jsx-506446869{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-506446869:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-ba6267904dd67a4c">aside.jsx-ba6267904dd67a4c{position:absolute;
right:0;
padding-left:200px;
width:200px;
height:100%}
nav.jsx-ba6267904dd67a4c{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
ul.jsx-ba6267904dd67a4c{list-style:none}
@media (max-width:1080px) {aside.jsx-ba6267904dd67a4c{visibility:hidden}}</style><style id="__jsx-2bb422412afe9fa4">img.jsx-2bb422412afe9fa4{display:inline;
vertical-align:middle}
span.jsx-2bb422412afe9fa4{color:#BBBBBB;
padding-left:0.5rem;
display:inline;
font-size:1rem;
vertical-align:middle}</style><style id="__jsx-1181861c1ce622ba">.carbon.jsx-1181861c1ce622ba{display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-box-pack:start;
-ms-flex-pack:start;
-webkit-justify-content:flex-start;
justify-content:flex-start;
margin-bottom:1em}
.red.jsx-1181861c1ce622ba{background:#eb5757;
border:0.5px solid #2c2c2c;
width:0.75em;
height:0.75em;
margin:0.5em 0.375em 0.5em 0;
border-radius:50%}
.yellow.jsx-1181861c1ce622ba{background:#f9a825;
border:0.5px solid #2c2c2c;
width:0.75em;
height:0.75em;
margin:0.5em 0.375em 0.5em 0;
border-radius:50%}
.green.jsx-1181861c1ce622ba{background:#55ef3f;
border:0.5px solid #2c2c2c;
width:0.75em;
height:0.75em;
margin:0.5em 0.375em 0.5em 0;
border-radius:50%}</style><style id="__jsx-6ec3cf284346852c">article.jsx-6ec3cf284346852c{display:block;
margin:0 auto;
padding:0 1rem}
h1.jsx-6ec3cf284346852c{font-size:3rem;
margin-bottom:5px}
.head.jsx-6ec3cf284346852c{margin-bottom:2rem}
.container.jsx-6ec3cf284346852c{width:100%;
max-width:35rem;
margin:0 auto;
line-height:1.625}
@media (max-width:1080px) {aside.jsx-6ec3cf284346852c{position:static;
height:auto}
.container.jsx-6ec3cf284346852c{max-width:40rem}}</style><style id="__jsx-243dc63d52768b84">.content{max-width:40rem}</style><style id="__jsx-acfe784ee19a4513">.github.jsx-acfe784ee19a4513{font-size:1rem;
display:inline-block;
text-align:center;
width:8rem;
height:2rem;
margin:0 auto}
.github.jsx-acfe784ee19a4513:hover{background-color:#4d4747;
box-shadow:0 0 0.6rem rgb(0 0 0 / 60%);
-webkit-transform:translate(0, -0.4rem);
-moz-transform:translate(0, -0.4rem);
-ms-transform:translate(0, -0.4rem);
transform:translate(0, -0.4rem)}</style><style id="__jsx-43ca208974c5fcc2">footer.jsx-43ca208974c5fcc2{height:6rem;
padding:0 2rem;
text-align:center;
margin:0 auto;
display:grid;
grid-template-columns:1fr 1fr}
span.jsx-43ca208974c5fcc2{font-size:0.8rem;
padding:3rem 0}
@media (min-width:720px) {footer.jsx-43ca208974c5fcc2{max-width:35rem;
padding:0 2rem;
margin:0 auto}}</style><style id="__jsx-13c39c1d02046747">*{color:#AAA;
box-sizing:border-box}
html, body{padding:0;
margin:0;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
background:#1e1e1e}
a{color:#AAA;
-webkit-text-decoration:none;
text-decoration:none}
main{background:#1e1e1e;
min-height:100vh;
height:100%;
padding:8rem 0 0 0;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center}
strong{color:#a964a7}
code{color:#eb5757;
background:#2c2c2c;
font-weight:bold;
font-size:0.85rem;
border-radius:3px;
padding:0.2em 0.4em;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif}
blockquote{border-left:3px solid currentcolor;
padding-left:1rem;
padding-right:1rem;
width:100%}
article{position:relative}
.hljs{font-size:0.8rem;
background:#333;
font-family:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
display:block;
color:#ddd;
border-radius:5px;
overflow:auto;
padding:1em;
margin:0.6em}
.hljs-doctag, .hljs-meta-keyword, .hljs-name, .hljs-strong{font-weight:bold}
.hljs-code, .hljs-emphasis{font-style:italic}
.hljs-section, .hljs-tag{color:#62c8f3}
.hljs-selector-class, .hljs-selector-id, .hljs-template-variable, .hljs-variable{color:#ade5fc}
.hljs-meta-string, .hljs-string{color:#a2fca2}
.hljs-attr, .hljs-quote, .hljs-selector-attr{color:#7bd694}
.hljs-tag .hljs-attr{color:inherit}
.hljs-attribute, .hljs-title, .hljs-type{color:#ffa}
.hljs-number, .hljs-symbol{color:#d36363}
.hljs-bullet, .hljs-template-tag{color:#b8d8a2}
.hljs-built_in, .hljs-keyword, .hljs-literal, .hljs-selector-tag{color:#fcc28c}
.hljs-code, .hljs-comment, .hljs-formula{color:#888}
.hljs-link, .hljs-selector-pseudo, .hljs-regexp{color:#c6b4f0}
.hljs-meta{color:#fc9b9b}
.hljs-deletion{background:#fc9b9b;
color:#333}
.hljs-addition{background:#a2fca2;
color:#333}
.hljs-operator, .hljs-params, .hljs-property, .hljs-punctuation{}
.hljs-subst{color:#fff}
.hljs a{color:inherit}
.hljs a:focus, .hljs a:hover{color:inherit;
text-decoration:underline}
.hljs mark{background:#555;
color:inherit}</style></head><body><div id="__next" data-reactroot=""><header class="jsx-d9da5f49743f60bd"><div class="jsx-d9da5f49743f60bd menu bar"><input type="checkbox" id="menu-button" class="jsx-d9da5f49743f60bd"/><label for="menu-button" class="jsx-d9da5f49743f60bd"></label></div><div class="jsx-d9da5f49743f60bd home"><span class="jsx-d9da5f49743f60bd link">Ordinary</span></div><div id="about" class="jsx-d9da5f49743f60bd about"><span class="jsx-d9da5f49743f60bd link"><div class="jsx-112769295 square-container"><div class="jsx-112769295 square"><div class="jsx-112769295 sq1"></div><div class="jsx-112769295 sq2"></div><div class="jsx-112769295 sq3"></div></div></div>About</span></div></header><main><h1></h1><div class="jsx-243dc63d52768b84"><div class="jsx-6ec3cf284346852c"><article class="jsx-6ec3cf284346852c container"><aside class="jsx-ba6267904dd67a4c"><nav class="jsx-ba6267904dd67a4c"><ul class="jsx-ba6267904dd67a4c"><li class="jsx-506446869"><a href="#전송 계층" class="jsx-506446869"> <!-- -->전송 계층</a></li><li class="jsx-506446869"><a href="#포트" class="jsx-506446869"> <!-- -->포트</a></li><li class="jsx-506446869"><a href="#재전송 제어" class="jsx-506446869"> <!-- -->재전송 제어</a></li><li class="jsx-506446869"><a href="#3 Way HandShaking" class="jsx-506446869"> <!-- -->3 Way HandShaking</a></li><li class="jsx-506446869"><a href="#4 Way HandShaking" class="jsx-506446869"> <!-- -->4 Way HandShaking</a></li><li class="jsx-506446869"><a href="#흐름 제어" class="jsx-506446869"> <!-- -->흐름 제어</a></li><li class="jsx-506446869"><a href="#UDP (User Datagram Protocol)" class="jsx-506446869"> <!-- -->UDP (User Datagram Protocol)</a></li></ul></nav></aside><div class="jsx-6ec3cf284346852c head"><h1 class="jsx-6ec3cf284346852c">TCP UDP</h1><div class="jsx-2bb422412afe9fa4"><img src="/profile.png" alt="profile" class="jsx-2bb422412afe9fa4"/><span class="jsx-2bb422412afe9fa4">ordilov<!-- --> / <!-- -->2022. 3. 30</span></div></div><div id="전송 계층"><h2>전송 계층</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">TCP와 UDP는 OSI 7계층이나 TCP/IP 모델 모두에서 <strong>전송 계층</strong>에 해당합니다.
<strong>전송 계층</strong>의 필요성을 알기 위해 간단하게 하위 계층에서 패킷을 보내서 받을 때를 보겠습니다.</p>
<ul>
<li>라우터의 라우팅 기능을 통해 요청한 네트워크 망에 아날로그 신호를 전송합니다.</li>
<li>네트워크 망 내부에서 IP 주소를 이용해 스위치에서 MAC 주소를 찾습니다.</li>
<li>MAC 주소에 도착한 아날로그 신호를 랜 카드에서 데이터 신호로 변환합니다.</li>
</ul>
<blockquote>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">다른 네트워크 → 라우터 → 네트워크 망 → 스위치 → 컴퓨터</p>
</blockquote>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이런 과정을 거쳤을 때 프로그램에서 데이터를 받으려면 해결해야 하는 부분이 남았습니다.</p>
<ol>
<li>어느 프로그램에서 받은 데이터를 사용할 건가?</li>
<li>데이터가 순서대로 전송되지 않으면 어떻게 할건가?</li>
<li>데이터가 라우터나 스위치 등을 거치면서 손상되거나 유실되면 어떻게 할까?</li>
</ol>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">먼저 어느 프로그램에서 받은 데이터를 사용할 지를 해결합니다.</p>
<div id="포트"><h2>포트</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">같은 PC 내에서 여러 프로그램을 사용 중일 때 네트워크로 데이터를 받는다면 구분이 필요합니다.
이때 구분을 위해 사용하는 번호가 <strong>포트</strong>입니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">포트는 16비트로 0~65535 숫자까지 가능합니다.
이 중에서 0 ~ 1023 까지를 <strong>well-known ports</strong> 라고 하고 서버에서 주로 사용합니다.
나머지 번호는 클라이언트가 송신할 때 주로 사용합니다.
웹 브라우저에서 요청하는 경우 포트가 자동으로 할당됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/tcp/port.png" alt=""/></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">예를 들어 구글에 Postman으로 요청하면 송신에는 65478 포트를, 수신에는 443 포트가 사용된 걸 볼 수 있습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">전송 계층에서는 응용 계층에서 넘어온 데이터에 <strong>TCP/UDP 헤더</strong>를 합쳐서 다음 계층에 넘깁니다.
이렇게 데이터와 <strong>TCP/UDP 헤더</strong>를 합친 것을 <strong>세그먼트</strong>라고 합니다.
이때 <strong>TCP/UDP 헤더</strong>에는 송신자와 수신자의 포트가 들어갑니다.
포트를 이용하면서 어느 프로그램으로 전달할지 확인할 수 있습니다.
여기까지만 해도 전송 계층의 중요한 목적 중 하나인 어느 프로그램으로 보낼지를 해결했습니다.
다른 기능들은 추가하려면 신뢰성과 효율성 사이에서 트레이드 오프가 필요합니다.
그 중에서 신뢰성을 우선시하는 TCP(Transmission Control Protocol) 기준으로 설명하겠습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/tcp/header1.png" alt=""/></p>
<div id="재전송 제어"><h2>재전송 제어</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">데이터를 한 번에 보낼 수 있으면 좋겠지만 보낼 수 있는 데이터의 크기는 정해져있습니다.
데이터 크기를 크게 보내면 대역폭을 많이 잡아먹게 되고, 데이터가 유실되거나 하는 경우 처리가 힘들어집니다.
데이터를 쪼개서 보내는 단위를 <strong>패킷</strong>이라고 합니다.
패킷의 최대 크기는 65,535로 실제 데이터 크기는 TCP 헤더 크기를 제외한 값이 됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이렇게 쪼개서 보낼 때 네트워크 환경에 따라 데이터의 순서가 다르게 전송될 수 있습니다.
다음 데이터가 먼저 오거나 하는 식으로 말이죠.
이런 조각난 데이터들을 모아서 원본 데이터로 만드려면 <strong>순서</strong>가 필요합니다.
그리고 <strong>순서</strong>대로 모았을 때 오지 않거나 손상된 데이터는 다시 보내줄 수 있어야 합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이런 순서를 일련번호를 통해 전송하고, 어디까지 받았는지 응답을 확인 응답 번호에 담아서 전송합니다.
응답 번호로 받지 못한 값이 있다면 일정 시간 후에 다시 재전송해줍니다.
이렇게 제대로 응답받지 못한 것을 다시 받을 수 있게 보장해주는 것을 <strong>재전송 제어</strong>라고 합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/tcp/header2.png" alt=""/></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">어디로 보낼지 정했고, 데이터를 쪼개서 어떤 순서로 보낼지 결정했습니다.
이제 어떤 식으로 전송할지 알아보겠습니다.</p>
<div id="3 Way HandShaking"><h2>3 Way HandShaking</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">안정적으로 데이터를 보내려면 먼저 서버가 정상적으로 동작하는지 확인해야 합니다.
제대로 동작하는지 확인하기 위해 TCP는 <strong>연결</strong>을 합니다.
<strong>연결</strong>은 단순히 개념적인 것으로 데이터를 보내줄 수 있는지 확인하고 응답을 받는 것입니다.
확인과 응답에 대한 정보는 TCP 헤더 중 <strong>코드 비트</strong>에 포함됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/tcp/header3.png" alt=""/></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">코드 비트는 6비트로 구성되어 있는데 <strong>연결</strong>을 위해서 <code class="jsx-1181861c1ce622ba ">ACK</code>와 <code class="jsx-1181861c1ce622ba ">SYN</code>이 사용됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/tcp/codebit.png" alt=""/></p>
<ol>
<li>클라이언트가 <strong>연결 요청</strong>을 위해 <code class="jsx-1181861c1ce622ba ">SYN</code>에 1을 담아 보냅니다.</li>
<li>서버가 <strong>연결 확립</strong>이 가능하면 <code class="jsx-1181861c1ce622ba ">ACK</code>, <code class="jsx-1181861c1ce622ba ">SYN</code>에 1을 담아 보냅니다.</li>
<li>클라이언트가 <strong>연결 확립</strong> 응답을 받았다는 응답을 <code class="jsx-1181861c1ce622ba ">ACK</code>에 1을 담아 보냅니다.</li>
</ol>
<div id="4 Way HandShaking"><h2>4 Way HandShaking</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">데이터를 끝까지 다 받았는지 확인하기 위해서 연결 종료할 때도 요청을 주고 받습니다.</p>
<ol>
<li>클라이언트가 <strong>연결 종료</strong>을 위해 <code class="jsx-1181861c1ce622ba ">FIN</code>에 1을 담아 보냅니다.</li>
<li>서버가 <strong>연결 종료 응답</strong>으로 <code class="jsx-1181861c1ce622ba ">ACK</code>에 1을 담아 보냅니다.</li>
<li>서버가 <strong>연결 종료 요청</strong>으로 <code class="jsx-1181861c1ce622ba ">FIN</code>에 1을 담아 보냅니다.</li>
<li>클라이언트가 <strong>연결 종료 응답</strong>으로 <code class="jsx-1181861c1ce622ba ">ACK</code>에 1을 담아 보냅니다.</li>
</ol>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">클라이언트가 종료를 보내는 경우는 더 이상 요청할 데이터가 없을 때입니다.
서버가 종료를 보내는 경우는 요청한 데이터를 모두 전송했을 때입니다.
이때 3번에서 서버가 <code class="jsx-1181861c1ce622ba ">FIN</code>을 보내고 클라이언트가 <code class="jsx-1181861c1ce622ba ">ACK</code>를 보냈다고 해도 일정 시간동안 연결을 유지합니다.
이유는 <code class="jsx-1181861c1ce622ba ">FIN</code> 이전에 보냈던 데이터들이 다 가지 않았는데 연결을 바로 종료하면 데이터를 다시 받을 수 없습니다.
그래서 <code class="jsx-1181861c1ce622ba ">FIN</code>을 받은 이후에도 기간을 두고 데이터를 받고 완료하면 연결을 끊습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이렇게 연결을 받고 끊는 것까지 가능하면 어느 정도 속도로 데이터를 보내줘야 할까요?</p>
<div id="흐름 제어"><h2>흐름 제어</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">데이터를 보낼 수 있는 만큼 빠르게 보내주면 좋아보이지만, 처리 속도가 따라주지 않으면 문제가 됩니다.
받을 수 있는지 확인하는 방법으로는 데이터를 받았다는 확인 응답 번호가 오면 다음 일련 번호를 보내는 것입니다.
이런 방식을 <strong>Stop and Wait</strong> 방식이라고 합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">하지만 이런 식으로 진행하면 대답이 올 때까지 기다렸다가 다시 보내주는 식으로 속도가 굉장히 느립니다.
이를 해결하기 위해 응답이 오지 않아도 어느 크기 정도는 함께 보냅니다.
이렇게 보낸 값들은 앞선 데이터들이 처리되는 동안 <strong>버퍼</strong> 라는 공간에 저장됩니다.
<strong>버퍼</strong>에서 임시적으로 값을 저장할 수 있지만 크기가 정해져있기 때문에 이보다 적은 크기로 받아야 합니다.
이 크기를 TCP 헤더에서 <strong>윈도우 크기</strong>에 담아 보내주며 <strong>3 Way Handshaking</strong> 중에 함께 보내서 크기를 공유합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/tcp/header4.png" alt=""/></p>
<div id="UDP (User Datagram Protocol)"><h2>UDP (User Datagram Protocol)</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">UDP는 TCP와 달리 헤더에 안전성보다 간단하게 구성됩니다.
그만큼 신뢰성은 떨어지지만 오버헤드가 적습니다.
순서가 보장될 필요가 없거나, 데이터가 손실되도 재전송할 필요가 없을 때 사용됩니다.
데이터의 전송 단위도 TCP와 달리 데이터그램이라는 단위로 전송됩니다.
크기는 똑같이 최대 65535 바이트로, 크기가 넘어가면 잘라서 보냅니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/tcp/udp.png" alt=""/></p></article></div></div></main><footer class="jsx-43ca208974c5fcc2"><span class="jsx-43ca208974c5fcc2"><a href="https://github.com/ordilov" class="jsx-acfe784ee19a4513 github">Github 🔗</a></span><span class="jsx-43ca208974c5fcc2">Copyright © Ordilov</span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"TCP UDP","date":"2022-03-31 00:01:00 +0900","category":"web","tags":["backend"],"keywords":["backend"],"description":"TCP와 UDP의 차이점을 알아봅니다.","id":"TCP UDP"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      strong: \"strong\",\n      ul: \"ul\",\n      li: \"li\",\n      blockquote: \"blockquote\",\n      ol: \"ol\",\n      img: \"img\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"전송 계층\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"TCP와 UDP는 OSI 7계층이나 TCP/IP 모델 모두에서 \", _jsx(_components.strong, {\n          children: \"전송 계층\"\n        }), \"에 해당합니다.\\n\", _jsx(_components.strong, {\n          children: \"전송 계층\"\n        }), \"의 필요성을 알기 위해 간단하게 하위 계층에서 패킷을 보내서 받을 때를 보겠습니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"라우터의 라우팅 기능을 통해 요청한 네트워크 망에 아날로그 신호를 전송합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"네트워크 망 내부에서 IP 주소를 이용해 스위치에서 MAC 주소를 찾습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"MAC 주소에 도착한 아날로그 신호를 랜 카드에서 데이터 신호로 변환합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"다른 네트워크 → 라우터 → 네트워크 망 → 스위치 → 컴퓨터\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 과정을 거쳤을 때 프로그램에서 데이터를 받으려면 해결해야 하는 부분이 남았습니다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"어느 프로그램에서 받은 데이터를 사용할 건가?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"데이터가 순서대로 전송되지 않으면 어떻게 할건가?\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"데이터가 라우터나 스위치 등을 거치면서 손상되거나 유실되면 어떻게 할까?\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"먼저 어느 프로그램에서 받은 데이터를 사용할 지를 해결합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"포트\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"같은 PC 내에서 여러 프로그램을 사용 중일 때 네트워크로 데이터를 받는다면 구분이 필요합니다.\\n이때 구분을 위해 사용하는 번호가 \", _jsx(_components.strong, {\n          children: \"포트\"\n        }), \"입니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"포트는 16비트로 0~65535 숫자까지 가능합니다.\\n이 중에서 0 ~ 1023 까지를 \", _jsx(_components.strong, {\n          children: \"well-known ports\"\n        }), \" 라고 하고 서버에서 주로 사용합니다.\\n나머지 번호는 클라이언트가 송신할 때 주로 사용합니다.\\n웹 브라우저에서 요청하는 경우 포트가 자동으로 할당됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/port.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"예를 들어 구글에 Postman으로 요청하면 송신에는 65478 포트를, 수신에는 443 포트가 사용된 걸 볼 수 있습니다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"전송 계층에서는 응용 계층에서 넘어온 데이터에 \", _jsx(_components.strong, {\n          children: \"TCP/UDP 헤더\"\n        }), \"를 합쳐서 다음 계층에 넘깁니다.\\n이렇게 데이터와 \", _jsx(_components.strong, {\n          children: \"TCP/UDP 헤더\"\n        }), \"를 합친 것을 \", _jsx(_components.strong, {\n          children: \"세그먼트\"\n        }), \"라고 합니다.\\n이때 \", _jsx(_components.strong, {\n          children: \"TCP/UDP 헤더\"\n        }), \"에는 송신자와 수신자의 포트가 들어갑니다.\\n포트를 이용하면서 어느 프로그램으로 전달할지 확인할 수 있습니다.\\n여기까지만 해도 전송 계층의 중요한 목적 중 하나인 어느 프로그램으로 보낼지를 해결했습니다.\\n다른 기능들은 추가하려면 신뢰성과 효율성 사이에서 트레이드 오프가 필요합니다.\\n그 중에서 신뢰성을 우선시하는 TCP(Transmission Control Protocol) 기준으로 설명하겠습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header1.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"재전송 제어\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"데이터를 한 번에 보낼 수 있으면 좋겠지만 보낼 수 있는 데이터의 크기는 정해져있습니다.\\n데이터 크기를 크게 보내면 대역폭을 많이 잡아먹게 되고, 데이터가 유실되거나 하는 경우 처리가 힘들어집니다.\\n데이터를 쪼개서 보내는 단위를 \", _jsx(_components.strong, {\n          children: \"패킷\"\n        }), \"이라고 합니다.\\n패킷의 최대 크기는 65,535로 실제 데이터 크기는 TCP 헤더 크기를 제외한 값이 됩니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이렇게 쪼개서 보낼 때 네트워크 환경에 따라 데이터의 순서가 다르게 전송될 수 있습니다.\\n다음 데이터가 먼저 오거나 하는 식으로 말이죠.\\n이런 조각난 데이터들을 모아서 원본 데이터로 만드려면 \", _jsx(_components.strong, {\n          children: \"순서\"\n        }), \"가 필요합니다.\\n그리고 \", _jsx(_components.strong, {\n          children: \"순서\"\n        }), \"대로 모았을 때 오지 않거나 손상된 데이터는 다시 보내줄 수 있어야 합니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이런 순서를 일련번호를 통해 전송하고, 어디까지 받았는지 응답을 확인 응답 번호에 담아서 전송합니다.\\n응답 번호로 받지 못한 값이 있다면 일정 시간 후에 다시 재전송해줍니다.\\n이렇게 제대로 응답받지 못한 것을 다시 받을 수 있게 보장해주는 것을 \", _jsx(_components.strong, {\n          children: \"재전송 제어\"\n        }), \"라고 합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header2.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"어디로 보낼지 정했고, 데이터를 쪼개서 어떤 순서로 보낼지 결정했습니다.\\n이제 어떤 식으로 전송할지 알아보겠습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"3 Way HandShaking\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"안정적으로 데이터를 보내려면 먼저 서버가 정상적으로 동작하는지 확인해야 합니다.\\n제대로 동작하는지 확인하기 위해 TCP는 \", _jsx(_components.strong, {\n          children: \"연결\"\n        }), \"을 합니다.\\n\", _jsx(_components.strong, {\n          children: \"연결\"\n        }), \"은 단순히 개념적인 것으로 데이터를 보내줄 수 있는지 확인하고 응답을 받는 것입니다.\\n확인과 응답에 대한 정보는 TCP 헤더 중 \", _jsx(_components.strong, {\n          children: \"코드 비트\"\n        }), \"에 포함됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header3.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"코드 비트는 6비트로 구성되어 있는데 \", _jsx(_components.strong, {\n          children: \"연결\"\n        }), \"을 위해서 \", _jsx(_components.code, {\n          children: \"ACK\"\n        }), \"와 \", _jsx(_components.code, {\n          children: \"SYN\"\n        }), \"이 사용됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/codebit.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 요청\"\n          }), \"을 위해 \", _jsx(_components.code, {\n            children: \"SYN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"서버가 \", _jsx(_components.strong, {\n            children: \"연결 확립\"\n          }), \"이 가능하면 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \", \", _jsx(_components.code, {\n            children: \"SYN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 확립\"\n          }), \" 응답을 받았다는 응답을 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4 Way HandShaking\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"데이터를 끝까지 다 받았는지 확인하기 위해서 연결 종료할 때도 요청을 주고 받습니다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 종료\"\n          }), \"을 위해 \", _jsx(_components.code, {\n            children: \"FIN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"서버가 \", _jsx(_components.strong, {\n            children: \"연결 종료 응답\"\n          }), \"으로 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"서버가 \", _jsx(_components.strong, {\n            children: \"연결 종료 요청\"\n          }), \"으로 \", _jsx(_components.code, {\n            children: \"FIN\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"클라이언트가 \", _jsx(_components.strong, {\n            children: \"연결 종료 응답\"\n          }), \"으로 \", _jsx(_components.code, {\n            children: \"ACK\"\n          }), \"에 1을 담아 보냅니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"클라이언트가 종료를 보내는 경우는 더 이상 요청할 데이터가 없을 때입니다.\\n서버가 종료를 보내는 경우는 요청한 데이터를 모두 전송했을 때입니다.\\n이때 3번에서 서버가 \", _jsx(_components.code, {\n          children: \"FIN\"\n        }), \"을 보내고 클라이언트가 \", _jsx(_components.code, {\n          children: \"ACK\"\n        }), \"를 보냈다고 해도 일정 시간동안 연결을 유지합니다.\\n이유는 \", _jsx(_components.code, {\n          children: \"FIN\"\n        }), \" 이전에 보냈던 데이터들이 다 가지 않았는데 연결을 바로 종료하면 데이터를 다시 받을 수 없습니다.\\n그래서 \", _jsx(_components.code, {\n          children: \"FIN\"\n        }), \"을 받은 이후에도 기간을 두고 데이터를 받고 완료하면 연결을 끊습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이렇게 연결을 받고 끊는 것까지 가능하면 어느 정도 속도로 데이터를 보내줘야 할까요?\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"흐름 제어\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"데이터를 보낼 수 있는 만큼 빠르게 보내주면 좋아보이지만, 처리 속도가 따라주지 않으면 문제가 됩니다.\\n받을 수 있는지 확인하는 방법으로는 데이터를 받았다는 확인 응답 번호가 오면 다음 일련 번호를 보내는 것입니다.\\n이런 방식을 \", _jsx(_components.strong, {\n          children: \"Stop and Wait\"\n        }), \" 방식이라고 합니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"하지만 이런 식으로 진행하면 대답이 올 때까지 기다렸다가 다시 보내주는 식으로 속도가 굉장히 느립니다.\\n이를 해결하기 위해 응답이 오지 않아도 어느 크기 정도는 함께 보냅니다.\\n이렇게 보낸 값들은 앞선 데이터들이 처리되는 동안 \", _jsx(_components.strong, {\n          children: \"버퍼\"\n        }), \" 라는 공간에 저장됩니다.\\n\", _jsx(_components.strong, {\n          children: \"버퍼\"\n        }), \"에서 임시적으로 값을 저장할 수 있지만 크기가 정해져있기 때문에 이보다 적은 크기로 받아야 합니다.\\n이 크기를 TCP 헤더에서 \", _jsx(_components.strong, {\n          children: \"윈도우 크기\"\n        }), \"에 담아 보내주며 \", _jsx(_components.strong, {\n          children: \"3 Way Handshaking\"\n        }), \" 중에 함께 보내서 크기를 공유합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/header4.png\",\n          alt: \"\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"UDP (User Datagram Protocol)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"UDP는 TCP와 달리 헤더에 안전성보다 간단하게 구성됩니다.\\n그만큼 신뢰성은 떨어지지만 오버헤드가 적습니다.\\n순서가 보장될 필요가 없거나, 데이터가 손실되도 재전송할 필요가 없을 때 사용됩니다.\\n데이터의 전송 단위도 TCP와 달리 데이터그램이라는 단위로 전송됩니다.\\n크기는 똑같이 최대 65535 바이트로, 크기가 넘어가면 잘라서 보냅니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/tcp/udp.png\",\n          alt: \"\"\n        })\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"TCP UDP"},"buildId":"xyUz5fkL3d3Gja13LWnAp","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>