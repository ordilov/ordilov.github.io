<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/eb02e362203cb1e5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/eb02e362203cb1e5.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8560289fc67afa8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8560289fc67afa8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-10d16e51767f2eb7.js" defer=""></script><script src="/_next/static/chunks/132-c8ad25a4bdd62a00.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4c91ca1952ea948f.js" defer=""></script><script src="/_next/static/CuTA3bAVY3vPO5b2gv4l6/_buildManifest.js" defer=""></script><script src="/_next/static/CuTA3bAVY3vPO5b2gv4l6/_ssgManifest.js" defer=""></script><script src="/_next/static/CuTA3bAVY3vPO5b2gv4l6/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Home_container__97eC3"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><article class="Post_container__qv178"><div class="Post_head__hU8yK"><h1 class="Post_title__MJ8Hr">문제 해결 전략 5</h1><div class="Post_meta__TGwfg"><img src="/profile.png" class="Post_avatar__KIFLy" alt="profile"/><div class="Post_profile__wwScp">ordilov /<!-- --> <!-- -->6/23/202</div></div></div><div style="--size:20pt" class="MDX_Heading__T63mn">5.1 도입</div>
<p class="MDX_Paragraph__xqVvo"><strong>알고리즘의 정당성 증명</strong></p>
<p class="MDX_Paragraph__xqVvo">알고리즘이 문제를 제대로 해결하나 어떻게 알까요?<br/>
<!-- -->단위테스트를 이용해 여러 입력으로 확인해 볼 수 있습니다.<br/>
<!-- -->이 경우 문제가 있음을 증명할 수 있습니다.<br/>
<!-- -->하지만 문제가 없다는 것을 증명할 수는 없습니다.<br/>
<!-- -->따라서 정확한 증명을 위해서는 수학적 기법이 필요합니다.</p>
<p class="MDX_Paragraph__xqVvo">증명이 필요한 이유는 알고리즘을 유도하는데 통찰을 담고 있습니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">5.2 수학적 귀납법과 반복문 불변식</div>
<p class="MDX_Paragraph__xqVvo">100개의 도미노가 순서대로 놓여있습니다.<br/>
<!-- -->우리가 두 가지 사실을 안다고 가정합니다.</p>
<ul>
<li>첫 번째 도미노는 직접 손으로 밀어 쓸어트린다.</li>
<li>한 도미노가 쓰러지면 다음 도미노는 반드시 쓰러진다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">그러면 마지막 도미노는 반드시 쓰러지게 됩니다.<br/>
<!-- -->수학적 귀납법은 이와 같은 반복적인 구조를 증명합니다.<br/>
<!-- -->귀납적 증명은 세 단계로 나누어집니다.</p>
<ul>
<li>단계 나누기: 증명하고 싶은 사실을 여러 단계로 나눕니다.</li>
<li>첫 단계 증명: 첫 단계에서 증명의 성립을 보입니다.</li>
<li>귀납 증명: 하나가 성립하면 다음 단계도 성립함을 보입니다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">사다리 게임을 예로 들어보겠습니다.<br/>
<!-- -->사다리 게임에서 어떻게 맨 위와 아래가 1대1 매칭이 될까요?</p>
<ul>
<li>
<p class="MDX_Paragraph__xqVvo"><strong>단계 나누기</strong><br/>
<!-- -->텅 빈 N개의 세로줄에서 시작합니다.<br/>
<!-- -->원하는 사다리가 될 때 하나씩 가로 줄을 긋습니다.</p>
</li>
<li>
<p class="MDX_Paragraph__xqVvo"><strong>첫 단계 증명</strong><br/>
<!-- -->텅 빈 N개의 세로 줄에서 위와 아래는 1대1 매칭 됩니다.</p>
</li>
<li>
<p class="MDX_Paragraph__xqVvo"><strong>귀납 증명</strong><br/>
<!-- -->가로줄을 그어 두 개의 세로줄이 연결되었습니다.<br/>
<!-- -->이 때 세로 두 줄의 결과는 바뀌게 됩니다.<br/>
<!-- -->결과가 바뀌어도 1대1 매칭이 유지되는 것을 확인했습니다.</p>
</li>
</ul>
<div style="--size:18pt" class="MDX_Heading__T63mn">반복문 불변식</div>
<p class="MDX_Paragraph__xqVvo">알고리즘은 대부분 반복 요소가 있기에 <strong>귀납법</strong>은 자주 쓰입니다.<br/>
<!-- -->이 때 <strong>반복문 불변식</strong>이 유용하게 쓰입니다.<br/>
<!-- -->반복문의 내용이 한 번 실행될 때마다 중간 결과가 나옵니다.<br/>
<!-- -->결과가 우리가 원하는 답 위에 잘 있는지 명시하는 조건입니다.<br/>
<!-- -->반복문이 마지막에 정답을 계산하려면 이 식이 변하면 안됩니다.</p>
<ol>
<li>반복문 진입시에 불변식이 성립함을 보인다.</li>
<li>반복문 내용이 불변식을 깨트리지 않음을 보인다.</li>
<li>반복문 종료 시에 불변식이 성립하면 정답을 구한 것이다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo"><strong>이진 탐색과 반복문 불변식</strong></p>
<pre><code class="hljs language-java"><span class="hljs-comment">// list[-1] 은 -INF, list[size]는 INF로 가정</span>
<span class="hljs-type">int</span> <span class="hljs-title hljs-function">binsearch</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list, <span class="hljs-type">int</span> x)</span>{
    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();
    <span class="hljs-type">int</span> <span class="hljs-variable">lo</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>, hi = size;

    <span class="hljs-comment">// 반복문 불변식 1: lo &lt; hi</span>
    <span class="hljs-comment">// 반복문 불변식 2: A[lo] &lt; x &lt;= A[hi]</span>
    <span class="hljs-comment">// 여기부터 불변식이 성립</span>
    <span class="hljs-keyword">while</span>(lo + <span class="hljs-number">1</span> &lt; hi){
        System.out.println(<span class="hljs-string">&quot;lo : &quot;</span> + lo + <span class="hljs-string">&quot; hi : &quot;</span> + hi);
        <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lo + hi) / <span class="hljs-number">2</span>;
        <span class="hljs-keyword">if</span>(list.get(mid) &lt; x)
            lo = mid;
        <span class="hljs-type">else</span>
            <span class="hljs-variable">hi</span> <span class="hljs-operator">=</span> mid;
        <span class="hljs-comment">// 끝날때도 성립</span>
    }

    <span class="hljs-keyword">return</span> hi;
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">while문은 두 개의 불변식을 유지합니다.</p>
<p class="MDX_Paragraph__xqVvo">첫 번째는 lo &lt; hi입니다.</p>
<p class="MDX_Paragraph__xqVvo">두 번쨰는</p>
<div style="--size:24pt" class="MDX_Heading__T63mn"><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>l</mi><mi>o</mi><mo stretchy="false">]</mo><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mo>=</mo><mi>A</mi><mo stretchy="false">[</mo><mi>h</mi><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[lo] &lt; x &lt;= A[hi]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.01968em">l</span><span class="mord mathnormal">o</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">hi</span><span class="mclose">]</span></span></span></span></span></div>
<p class="MDX_Paragraph__xqVvo">입니다.
그렇다면 만족하는 사실이 있습니다.</p>
<ul>
<li>lo + 1 = hi: while문이 종료할 때 lo + 1 &gt;= hi입니다.<br/>
<!-- -->불변식이 만족하고 있으니 lo &lt; hi 로 lo + 1 = hi입니다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">즉 반복문의 정당성은 다음과 같이 증명할 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>초기 조건</strong></p>
<p class="MDX_Paragraph__xqVvo">while문이 시작될 때 lo = -1, hi = size 입니다.<br/>
<!-- -->size가 0이더라도 조건 1은 만족하고, while문은 건너뜁니다.<br/>
<!-- -->list[-1]은 -INF, list[size]는 INF로 조건 2도 만족합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>유지 조건</strong></p>
<p class="MDX_Paragraph__xqVvo"><strong>조건 1</strong></p>
<p class="MDX_Paragraph__xqVvo">while문 내부가 불변식이 깨트리지 않는 것을 보여줍니다.<br/>
<!-- -->while문 내부에 들어왔으면 lo와 hi는 2 이상 차이납니다.<br/>
<!-- -->mid는 중간 값으로 mid에 lo, hi 상관 없이 1은 만족합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>조건 2</strong></p>
<p class="MDX_Paragraph__xqVvo">lo나 hi가 mid로 바뀌어도 조건 2를 만족합니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">5.3 귀류법</div>
<p class="MDX_Paragraph__xqVvo">기차에 규정 인원보다 많은 인원이 예약했습니다.<br/>
<!-- -->역을 지날 때마다 더 탑승하면 문제가 생깁니다.<br/>
<!-- -->이 때 어느 승객을 빼는 게 최선일까요?<br/>
<!-- -->바로 가장 멀리 가는 사람들입니다.<br/>
<!-- -->이 질문을 답하기 위해선 반대로 가정해봐야 합니다.<br/>
<!-- -->빨리 내리는 사람은 내쫓아도 멀리 가는 사람은 남아있습니다.<br/>
<!-- -->결국 새로운 사람이 타면 인원이 초과되는 건 마찬가지입니다.<br/>
<!-- -->이런 식으로 반대로 가정하는 방법이 <strong>귀류법</strong> 입니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>책장 쌓기</strong>
책장을 여러 개 쌓아 올리려고 합니다.<br/>
<!-- -->각 책장마다 버틸 수 있는 무게 M과 자신의 무게 W가 주어집니다.<br/>
<!-- -->이 때 가장 높이 쌓으려면 몇 개나 쌓을 수 있을까요?<br/>
<!-- -->단 책장 위에 쌓은 W의 합은 M을 넘어서는 안됩니다.<br/>
<!-- -->이 문제를 풀려면 먼저 어떤 순서로 쌓을지 고민해야 합니다.</p>
<p class="MDX_Paragraph__xqVvo">W순으로 정렬해야할까요? M순으로 정렬해야 할까요?<br/>
<!-- -->답은 W+M이 큰 것부터 아래에 놓아야 합니다.<br/>
<!-- -->이를 증명하기 위해 귀류법을 사용합니다.<br/>
<!-- -->W+M이 더 큰 책장 a가 더 작은 책장 b 위에 있습니다.<br/>
<!-- -->이 때 두 책장을 항상 바꿀 수 있다면 가정이 맞습니다.</p>
<blockquote>
<p class="MDX_Paragraph__xqVvo">Ma + Wa &gt; Mb + Wb</p>
</blockquote>
<p class="MDX_Paragraph__xqVvo">둘을 바꿔도 Ma가 버티는 걸 보여주기 위해 Ma만 남깁니다.</p>
<blockquote>
<p class="MDX_Paragraph__xqVvo">Ma &gt; Mb + Wb - Wa</p>
</blockquote>
<p class="MDX_Paragraph__xqVvo">Mb가 아래 있으면 Wa와 그 위 X를 견딘다는 의미입니다.</p>
<blockquote>
<p class="MDX_Paragraph__xqVvo">Ma &gt; Mb + Wb - Wa &gt;= (Wa + X) + Wb - Wa</p>
</blockquote>
<p class="MDX_Paragraph__xqVvo">Wa를 제외하면 다음이 남습니다.</p>
<blockquote>
<p class="MDX_Paragraph__xqVvo">Ma &gt; X + Wb</p>
</blockquote>
<p class="MDX_Paragraph__xqVvo">이 말은 Ma는 X+Wb를 버틸 수 있다는 의미이지요.<br/>
<!-- -->즉 a와 b를 언제나 바꿔도 무관하다는 말입니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">5.4 다른 기술들</div>
<div style="--size:18pt" class="MDX_Heading__T63mn">비둘기집의 원리</div>
<p class="MDX_Paragraph__xqVvo">비둘기 집의 원리는 다음과 같습니다.</p>
<blockquote>
<p class="MDX_Paragraph__xqVvo">10마리의 비둘기가 9개의 비둘기 집에 있다.<br/>
<!-- -->그렇다면 2마리 이상 있는 비둘기집은 반드시 존재한다.</p>
</blockquote>
<div style="--size:18pt" class="MDX_Heading__T63mn">동전 뒤집기</div>
<p class="MDX_Paragraph__xqVvo">100개의 동전이 있을 때 F개는 앞면, 100-F개는 뒷면입니다.<br/>
<!-- -->동전들을 모두 앞면으로 바꾸려고 합니다.<br/>
<!-- -->한 번 뒤집을 때 X개의 동전을 뒤집어야합니다.<br/>
<!-- -->같은 동전을 두 번 뒤집는 것은 상관없습니다.<br/>
<!-- -->최소로 동전을 뒤집으려면 답의 상한은 얼마일까요?</p>
<p class="MDX_Paragraph__xqVvo">답은 100입니다.<br/>
<!-- -->동전을 뒤집을 때마다 앞면의 개수를 적는다고 합시다.<br/>
<!-- -->답에서 동전을 101번 뒤집는 경우 F까지 합쳐 102개를 적게 됩니다.<br/>
<!-- -->이는 0~100까지 101개를 넘어가므로 중복이 있다는 뜻입니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">순환 소수 찾기</div>
<p class="MDX_Paragraph__xqVvo">분수 a/b가 있는 경우 실수 연산이 아닌 소수로 출력합니다.<br/>
<!-- -->3/8의 경우 0.375 처럼 말이지요.<br/>
<!-- -->그런데 1/11의 경우 0.090909..로 계속 반복됩니다.<br/>
<!-- -->이럴 때 무한 소수라는 사실을 어떻게 알까요?<br/>
<!-- -->나눗셈을 할 시 a = (a%b) * 10을 반복하게 됩니다.<br/>
<!-- -->이 때 a%b는 [0...b-1] 범위의 값을 갖습니다.<br/>
<!-- -->즉 b+1번 반복되도 종료되지 않으면 순환 소수입니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">구성적 증명</div>
<p class="MDX_Paragraph__xqVvo">여태까지는 안되면 안된다는 걸 증명해 보였습니다.<br/>
<!-- -->다음은 만들어서 예를 들어 답을 제시하는 것입니다.<br/>
<!-- -->하늘을 날 수 있는 교통 수단을 만들 수 있는 것을 증명합니다.<br/>
<!-- -->모든 물리 법칙에서 된다는 걸 증명하기 어렵습니다.<br/>
<!-- -->비행기를 만들어 실제로 보여주는 방법입니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">안정적 결혼 문제</div>
<p class="MDX_Paragraph__xqVvo">n명의 여성과 남성이 단체 미팅을 합니다.<br/>
<!-- -->게임을 진행하는 동안 우선순위를 맘 속에 정했습니다.<br/>
<!-- -->남자 여자 1호끼리, 남자 여자 2호끼리 짝이 되었습니다.<br/>
<!-- -->그런데 남자 1호는 여자 2호를 더 선호했습니다.<br/>
<!-- -->남자 2호도 여자 1호를 더 선호했습니다.<br/>
<!-- -->이런 일이 안생기려면 어떤 방법이 있을까요?</p>
<p class="MDX_Paragraph__xqVvo">이를 안되는 경우가 없다는 걸 증명하긴 어렵습니다.<br/>
<!-- -->다만 되는 경우를 만들어서 보여줄 수 있습니다.</p>
<ol>
<li>처음에 여성이 자신이 선호하는 남성 앞에 섭니다.</li>
<li>남성이 가장 맘에 드는 여성을 고르고 나머지는 돌아갑니다.</li>
<li>다음으로 마음에 드는 남성 앞에 섭니다.</li>
<li>남성은 더 마음에 드는 여성인 경우 교체합니다.</li>
<li>여성이 남지 않을 때까지 3,4번을 반복합니다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo"><strong>종료 증명</strong></p>
<p class="MDX_Paragraph__xqVvo">각 여성은 최대 n명 앞에 서고 종료합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>모든 사람이 짝을 찾는지 증명</strong></p>
<p class="MDX_Paragraph__xqVvo">남성은 반드시 한 명은 선택하게 됩니다.<br/>
<!-- -->더 우선순위가 높은 여성이 온 경우 교체할 수 있습니다.<br/>
<!-- -->짝에 실패하면 더 낮은 순위로 내려가다보면 다 짝이 됩니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>짝들의 안정성</strong></p>
<p class="MDX_Paragraph__xqVvo">두 남녀가 서로 자신의 짝보다 더 맞는 사람이 있을까요?<br/>
<!-- -->여성은 우선순위대로 짝을 시도해보게 됩니다.<br/>
<!-- -->즉 짝이 안되었으면 이미 떨어졌다는 이야기입니다.<br/>
<!-- -->남성의 경우 더 맘에 들면 교체할 수 있습니다.<br/>
<!-- -->그런데 교체하지 않았다는 건 우선순위가 높은 쪽입니다.</p></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"문제 해결 전략 5","date":"2021-06-24 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"문제-해결-전략-5"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      strong: \"strong\",\n      br: \"br\",\n      ul: \"ul\",\n      li: \"li\",\n      h3: \"h3\",\n      ol: \"ol\",\n      pre: \"pre\",\n      code: \"code\",\n      span: \"span\",\n      h1: \"h1\",\n      math: \"math\",\n      semantics: \"semantics\",\n      mrow: \"mrow\",\n      mi: \"mi\",\n      mo: \"mo\",\n      annotation: \"annotation\",\n      blockquote: \"blockquote\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"5.1 도입\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"알고리즘의 정당성 증명\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"알고리즘이 문제를 제대로 해결하나 어떻게 알까요?\", _jsx(_components.br, {}), \"\\n\", \"단위테스트를 이용해 여러 입력으로 확인해 볼 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"이 경우 문제가 있음을 증명할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 문제가 없다는 것을 증명할 수는 없습니다.\", _jsx(_components.br, {}), \"\\n\", \"따라서 정확한 증명을 위해서는 수학적 기법이 필요합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"증명이 필요한 이유는 알고리즘을 유도하는데 통찰을 담고 있습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"5.2 수학적 귀납법과 반복문 불변식\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"100개의 도미노가 순서대로 놓여있습니다.\", _jsx(_components.br, {}), \"\\n\", \"우리가 두 가지 사실을 안다고 가정합니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"첫 번째 도미노는 직접 손으로 밀어 쓸어트린다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"한 도미노가 쓰러지면 다음 도미노는 반드시 쓰러진다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"그러면 마지막 도미노는 반드시 쓰러지게 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"수학적 귀납법은 이와 같은 반복적인 구조를 증명합니다.\", _jsx(_components.br, {}), \"\\n\", \"귀납적 증명은 세 단계로 나누어집니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"단계 나누기: 증명하고 싶은 사실을 여러 단계로 나눕니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"첫 단계 증명: 첫 단계에서 증명의 성립을 보입니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"귀납 증명: 하나가 성립하면 다음 단계도 성립함을 보입니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"사다리 게임을 예로 들어보겠습니다.\", _jsx(_components.br, {}), \"\\n\", \"사다리 게임에서 어떻게 맨 위와 아래가 1대1 매칭이 될까요?\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"단계 나누기\"\n            }), _jsx(_components.br, {}), \"\\n\", \"텅 빈 N개의 세로줄에서 시작합니다.\", _jsx(_components.br, {}), \"\\n\", \"원하는 사다리가 될 때 하나씩 가로 줄을 긋습니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"첫 단계 증명\"\n            }), _jsx(_components.br, {}), \"\\n\", \"텅 빈 N개의 세로 줄에서 위와 아래는 1대1 매칭 됩니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [_jsx(_components.strong, {\n              children: \"귀납 증명\"\n            }), _jsx(_components.br, {}), \"\\n\", \"가로줄을 그어 두 개의 세로줄이 연결되었습니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때 세로 두 줄의 결과는 바뀌게 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"결과가 바뀌어도 1대1 매칭이 유지되는 것을 확인했습니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"반복문 불변식\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"알고리즘은 대부분 반복 요소가 있기에 \", _jsx(_components.strong, {\n          children: \"귀납법\"\n        }), \"은 자주 쓰입니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때 \", _jsx(_components.strong, {\n          children: \"반복문 불변식\"\n        }), \"이 유용하게 쓰입니다.\", _jsx(_components.br, {}), \"\\n\", \"반복문의 내용이 한 번 실행될 때마다 중간 결과가 나옵니다.\", _jsx(_components.br, {}), \"\\n\", \"결과가 우리가 원하는 답 위에 잘 있는지 명시하는 조건입니다.\", _jsx(_components.br, {}), \"\\n\", \"반복문이 마지막에 정답을 계산하려면 이 식이 변하면 안됩니다.\"]\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"반복문 진입시에 불변식이 성립함을 보인다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"반복문 내용이 불변식을 깨트리지 않음을 보인다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"반복문 종료 시에 불변식이 성립하면 정답을 구한 것이다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"이진 탐색과 반복문 불변식\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// list[-1] 은 -INF, list[size]는 INF로 가정\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"binsearch\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(LinkedList\u003cInteger\u003e list, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" x)\"]\n          }), \"{\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"size\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" list.size();\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"lo\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" -\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \", hi = size;\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 반복문 불변식 1: lo \u003c hi\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 반복문 불변식 2: A[lo] \u003c x \u003c= A[hi]\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 여기부터 불변식이 성립\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"while\"\n          }), \"(lo + \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \" \u003c hi){\\n        System.out.println(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"lo : \\\"\"\n          }), \" + lo + \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\" hi : \\\"\"\n          }), \" + hi);\\n        \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"mid\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" (lo + hi) / \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"2\"\n          }), \";\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \"(list.get(mid) \u003c x)\\n            lo = mid;\\n        \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"else\"\n          }), \"\\n            \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"hi\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" mid;\\n        \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 끝날때도 성립\"\n          }), \"\\n    }\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" hi;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"while문은 두 개의 불변식을 유지합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"첫 번째는 lo \u003c hi입니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"두 번쨰는\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      children: \"A\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"[\"\n                    }), _jsx(_components.mi, {\n                      children: \"l\"\n                    }), _jsx(_components.mi, {\n                      children: \"o\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"]\"\n                    }), _jsx(_components.mo, {\n                      children: \"\u003c\"\n                    }), _jsx(_components.mi, {\n                      children: \"x\"\n                    }), _jsx(_components.mo, {\n                      children: \"\u003c\"\n                    }), _jsx(_components.mo, {\n                      children: \"=\"\n                    }), _jsx(_components.mi, {\n                      children: \"A\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"[\"\n                    }), _jsx(_components.mi, {\n                      children: \"h\"\n                    }), _jsx(_components.mi, {\n                      children: \"i\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"]\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"A[lo] \u003c x \u003c= A[hi]\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"A\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"[\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.01968em\"\n                  },\n                  children: \"l\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"o\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \"]\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"\u003c\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.5782em\",\n                    verticalAlign: \"-0.0391em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"x\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"\u003c=\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"A\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"[\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"hi\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \"]\"\n                })]\n              })]\n            })]\n          })\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"입니다.\\n그렇다면 만족하는 사실이 있습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"lo + 1 = hi: while문이 종료할 때 lo + 1 \u003e= hi입니다.\", _jsx(_components.br, {}), \"\\n\", \"불변식이 만족하고 있으니 lo \u003c hi 로 lo + 1 = hi입니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"즉 반복문의 정당성은 다음과 같이 증명할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"초기 조건\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"while문이 시작될 때 lo = -1, hi = size 입니다.\", _jsx(_components.br, {}), \"\\n\", \"size가 0이더라도 조건 1은 만족하고, while문은 건너뜁니다.\", _jsx(_components.br, {}), \"\\n\", \"list[-1]은 -INF, list[size]는 INF로 조건 2도 만족합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"유지 조건\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"조건 1\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"while문 내부가 불변식이 깨트리지 않는 것을 보여줍니다.\", _jsx(_components.br, {}), \"\\n\", \"while문 내부에 들어왔으면 lo와 hi는 2 이상 차이납니다.\", _jsx(_components.br, {}), \"\\n\", \"mid는 중간 값으로 mid에 lo, hi 상관 없이 1은 만족합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"조건 2\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"lo나 hi가 mid로 바뀌어도 조건 2를 만족합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"5.3 귀류법\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"기차에 규정 인원보다 많은 인원이 예약했습니다.\", _jsx(_components.br, {}), \"\\n\", \"역을 지날 때마다 더 탑승하면 문제가 생깁니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때 어느 승객을 빼는 게 최선일까요?\", _jsx(_components.br, {}), \"\\n\", \"바로 가장 멀리 가는 사람들입니다.\", _jsx(_components.br, {}), \"\\n\", \"이 질문을 답하기 위해선 반대로 가정해봐야 합니다.\", _jsx(_components.br, {}), \"\\n\", \"빨리 내리는 사람은 내쫓아도 멀리 가는 사람은 남아있습니다.\", _jsx(_components.br, {}), \"\\n\", \"결국 새로운 사람이 타면 인원이 초과되는 건 마찬가지입니다.\", _jsx(_components.br, {}), \"\\n\", \"이런 식으로 반대로 가정하는 방법이 \", _jsx(_components.strong, {\n          children: \"귀류법\"\n        }), \" 입니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"책장 쌓기\"\n        }), \"\\n책장을 여러 개 쌓아 올리려고 합니다.\", _jsx(_components.br, {}), \"\\n\", \"각 책장마다 버틸 수 있는 무게 M과 자신의 무게 W가 주어집니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때 가장 높이 쌓으려면 몇 개나 쌓을 수 있을까요?\", _jsx(_components.br, {}), \"\\n\", \"단 책장 위에 쌓은 W의 합은 M을 넘어서는 안됩니다.\", _jsx(_components.br, {}), \"\\n\", \"이 문제를 풀려면 먼저 어떤 순서로 쌓을지 고민해야 합니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"W순으로 정렬해야할까요? M순으로 정렬해야 할까요?\", _jsx(_components.br, {}), \"\\n\", \"답은 W+M이 큰 것부터 아래에 놓아야 합니다.\", _jsx(_components.br, {}), \"\\n\", \"이를 증명하기 위해 귀류법을 사용합니다.\", _jsx(_components.br, {}), \"\\n\", \"W+M이 더 큰 책장 a가 더 작은 책장 b 위에 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때 두 책장을 항상 바꿀 수 있다면 가정이 맞습니다.\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Ma + Wa \u003e Mb + Wb\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"둘을 바꿔도 Ma가 버티는 걸 보여주기 위해 Ma만 남깁니다.\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Ma \u003e Mb + Wb - Wa\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Mb가 아래 있으면 Wa와 그 위 X를 견딘다는 의미입니다.\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Ma \u003e Mb + Wb - Wa \u003e= (Wa + X) + Wb - Wa\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Wa를 제외하면 다음이 남습니다.\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"Ma \u003e X + Wb\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이 말은 Ma는 X+Wb를 버틸 수 있다는 의미이지요.\", _jsx(_components.br, {}), \"\\n\", \"즉 a와 b를 언제나 바꿔도 무관하다는 말입니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"5.4 다른 기술들\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"비둘기집의 원리\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"비둘기 집의 원리는 다음과 같습니다.\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsxs(_components.p, {\n          children: [\"10마리의 비둘기가 9개의 비둘기 집에 있다.\", _jsx(_components.br, {}), \"\\n\", \"그렇다면 2마리 이상 있는 비둘기집은 반드시 존재한다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"동전 뒤집기\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"100개의 동전이 있을 때 F개는 앞면, 100-F개는 뒷면입니다.\", _jsx(_components.br, {}), \"\\n\", \"동전들을 모두 앞면으로 바꾸려고 합니다.\", _jsx(_components.br, {}), \"\\n\", \"한 번 뒤집을 때 X개의 동전을 뒤집어야합니다.\", _jsx(_components.br, {}), \"\\n\", \"같은 동전을 두 번 뒤집는 것은 상관없습니다.\", _jsx(_components.br, {}), \"\\n\", \"최소로 동전을 뒤집으려면 답의 상한은 얼마일까요?\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"답은 100입니다.\", _jsx(_components.br, {}), \"\\n\", \"동전을 뒤집을 때마다 앞면의 개수를 적는다고 합시다.\", _jsx(_components.br, {}), \"\\n\", \"답에서 동전을 101번 뒤집는 경우 F까지 합쳐 102개를 적게 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"이는 0~100까지 101개를 넘어가므로 중복이 있다는 뜻입니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"순환 소수 찾기\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"분수 a/b가 있는 경우 실수 연산이 아닌 소수로 출력합니다.\", _jsx(_components.br, {}), \"\\n\", \"3/8의 경우 0.375 처럼 말이지요.\", _jsx(_components.br, {}), \"\\n\", \"그런데 1/11의 경우 0.090909..로 계속 반복됩니다.\", _jsx(_components.br, {}), \"\\n\", \"이럴 때 무한 소수라는 사실을 어떻게 알까요?\", _jsx(_components.br, {}), \"\\n\", \"나눗셈을 할 시 a = (a%b) * 10을 반복하게 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때 a%b는 [0...b-1] 범위의 값을 갖습니다.\", _jsx(_components.br, {}), \"\\n\", \"즉 b+1번 반복되도 종료되지 않으면 순환 소수입니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"구성적 증명\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"여태까지는 안되면 안된다는 걸 증명해 보였습니다.\", _jsx(_components.br, {}), \"\\n\", \"다음은 만들어서 예를 들어 답을 제시하는 것입니다.\", _jsx(_components.br, {}), \"\\n\", \"하늘을 날 수 있는 교통 수단을 만들 수 있는 것을 증명합니다.\", _jsx(_components.br, {}), \"\\n\", \"모든 물리 법칙에서 된다는 걸 증명하기 어렵습니다.\", _jsx(_components.br, {}), \"\\n\", \"비행기를 만들어 실제로 보여주는 방법입니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"안정적 결혼 문제\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"n명의 여성과 남성이 단체 미팅을 합니다.\", _jsx(_components.br, {}), \"\\n\", \"게임을 진행하는 동안 우선순위를 맘 속에 정했습니다.\", _jsx(_components.br, {}), \"\\n\", \"남자 여자 1호끼리, 남자 여자 2호끼리 짝이 되었습니다.\", _jsx(_components.br, {}), \"\\n\", \"그런데 남자 1호는 여자 2호를 더 선호했습니다.\", _jsx(_components.br, {}), \"\\n\", \"남자 2호도 여자 1호를 더 선호했습니다.\", _jsx(_components.br, {}), \"\\n\", \"이런 일이 안생기려면 어떤 방법이 있을까요?\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이를 안되는 경우가 없다는 걸 증명하긴 어렵습니다.\", _jsx(_components.br, {}), \"\\n\", \"다만 되는 경우를 만들어서 보여줄 수 있습니다.\"]\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"처음에 여성이 자신이 선호하는 남성 앞에 섭니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"남성이 가장 맘에 드는 여성을 고르고 나머지는 돌아갑니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"다음으로 마음에 드는 남성 앞에 섭니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"남성은 더 마음에 드는 여성인 경우 교체합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"여성이 남지 않을 때까지 3,4번을 반복합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"종료 증명\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"각 여성은 최대 n명 앞에 서고 종료합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"모든 사람이 짝을 찾는지 증명\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"남성은 반드시 한 명은 선택하게 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"더 우선순위가 높은 여성이 온 경우 교체할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"짝에 실패하면 더 낮은 순위로 내려가다보면 다 짝이 됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"짝들의 안정성\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"두 남녀가 서로 자신의 짝보다 더 맞는 사람이 있을까요?\", _jsx(_components.br, {}), \"\\n\", \"여성은 우선순위대로 짝을 시도해보게 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"즉 짝이 안되었으면 이미 떨어졌다는 이야기입니다.\", _jsx(_components.br, {}), \"\\n\", \"남성의 경우 더 맘에 들면 교체할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"그런데 교체하지 않았다는 건 우선순위가 높은 쪽입니다.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"문제-해결-전략-5"},"buildId":"CuTA3bAVY3vPO5b2gv4l6","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>