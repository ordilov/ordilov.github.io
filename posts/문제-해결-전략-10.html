<!DOCTYPE html><html><head><title class="jsx-f32a99b3114a7438">Ordinary</title><meta charSet="utf-8" class="jsx-f32a99b3114a7438"/><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-f32a99b3114a7438"/><meta name="description" content="Blog" class="jsx-f32a99b3114a7438"/><link rel="icon" href="/favicon.ico" class="jsx-f32a99b3114a7438"/><meta name="next-head-count" content="5"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-eb88e49c0426c1e9.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-a40a0e24ed5e8e99.js" defer=""></script><script src="/_next/static/GkZqC6CVl3oCvuLDsgDOS/_buildManifest.js" defer=""></script><script src="/_next/static/GkZqC6CVl3oCvuLDsgDOS/_ssgManifest.js" defer=""></script><script src="/_next/static/GkZqC6CVl3oCvuLDsgDOS/_middlewareManifest.js" defer=""></script><style id="__jsx-f32a99b3114a7438">header.jsx-f32a99b3114a7438{display:grid;
color:#0070f3;
background-color:#1e1e1e;
border-bottom:1px solid #e5e5e5;
grid-template-columns:1fr 1fr;
grid-template-rows:5rem;
position:fixed;
width:100%;
left:25%;
height:5rem;
z-index:300;
opacity:0.95}
.home.jsx-f32a99b3114a7438{font-family:'rudiment', serif;
font-size:3rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-text-decoration:none;
text-decoration:none}
.about.jsx-f32a99b3114a7438{font-family:'rudiment', serif;
font-size:1.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-flex-direction:row-reverse;
-ms-flex-direction:row-reverse;
flex-direction:row-reverse}
.category.jsx-f32a99b3114a7438{display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-flex-direction:row-reverse;
-ms-flex-direction:row-reverse;
flex-direction:row-reverse}
@media (min-width:720px) {header.jsx-f32a99b3114a7438{max-width:50rem;
padding:0 2rem;
margin:0 auto}}</style><style id="__jsx-506446869">a.jsx-506446869{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-506446869:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-2105002209">a.jsx-2105002209{display:block;
margin-left:20px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:120px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-2105002209:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-ba6267904dd67a4c">aside.jsx-ba6267904dd67a4c{position:absolute;
right:0;
padding-left:200px;
width:200px;
height:100%}
nav.jsx-ba6267904dd67a4c{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
ul.jsx-ba6267904dd67a4c{list-style:none}
@media (max-width:1080px) {aside.jsx-ba6267904dd67a4c{visibility:hidden}}</style><style id="__jsx-66c5b3c4cf32749c">img.jsx-66c5b3c4cf32749c{display:inline;
vertical-align:middle}
span.jsx-66c5b3c4cf32749c{color:#BBBBBB;
padding-left:0.5rem;
display:inline;
vertical-align:middle}</style><style id="__jsx-477b66404f654573">article.jsx-477b66404f654573{display:block;
margin:0 auto;
padding:0 1rem}
h1.jsx-477b66404f654573{font-size:30pt;
margin-bottom:5px}
.head.jsx-477b66404f654573{margin-bottom:2rem}
.container.jsx-477b66404f654573{width:100%;
max-width:720px;
margin:0 auto;
line-height:1.625}
@media (min-width:720px) {.container.jsx-477b66404f654573{padding:0 2rem;
margin:0 auto}}
@media (max-width:800px) {aside.jsx-477b66404f654573{position:static;
height:auto}}</style><style id="__jsx-5a92e9cb5e0cf5e5">.github.jsx-5a92e9cb5e0cf5e5{font-family:'rudiment', serif;
font-size:1.2rem;
display:inline-block;
text-align:center;
width:8rem;
height:2rem;
margin:0 auto}
.github.jsx-5a92e9cb5e0cf5e5:hover{background-color:#4d4747;
box-shadow:0 0 0.6rem rgb(0 0 0 / 60%);
-webkit-transform:translate(0, -0.4rem);
-moz-transform:translate(0, -0.4rem);
-ms-transform:translate(0, -0.4rem);
transform:translate(0, -0.4rem)}</style><style id="__jsx-d894c386b3e00b94">footer.jsx-d894c386b3e00b94{height:6rem;
padding:0 2rem;
text-align:center;
margin:0 auto;
display:grid;
grid-template-columns:1fr 1fr}
span.jsx-d894c386b3e00b94{font-family:'rudiment', serif;
font-size:1.2rem;
padding:2rem 0}
@media (min-width:720px) {footer.jsx-d894c386b3e00b94{max-width:50rem;
padding:0 2rem;
margin:0 auto}}</style><style id="__jsx-aff36dde830b1a84">*{color:white;
box-sizing:border-box}
@font-face {font-family:rudiment;
font-display:auto;
src:url('/font/rudiment.ttf')}
html, body{padding:0;
margin:0;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
background:#1e1e1e}
a{color:inherit;
-webkit-text-decoration:none;
text-decoration:none}
main{background:#1e1e1e;
min-height:100vh;
height:100%;
padding:8rem 0 0 0;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center}
strong{color:#a964a7}
code{color:#3fd0c0;
font-weight:bold;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif}
blockquote{border:3px solid #27a9e3;
margin-left:0;
margin-right:0;
padding-left:20px;
padding-right:20px;
border-left:12px solid #27a9e3;
border-radius:5px}
article{position:relative}
.hljs{font-size:0.9rem;
background:#333;
font-family:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
display:block;
color:#fff;
border-radius:5px;
overflow:auto;
padding:1em;
margin:0.6em}
.hljs-doctag, .hljs-meta-keyword, .hljs-name, .hljs-strong{font-weight:bold}
.hljs-code, .hljs-emphasis{font-style:italic}
.hljs-section, .hljs-tag{color:#62c8f3}
.hljs-selector-class, .hljs-selector-id, .hljs-template-variable, .hljs-variable{color:#ade5fc}
.hljs-meta-string, .hljs-string{color:#a2fca2}
.hljs-attr, .hljs-quote, .hljs-selector-attr{color:#7bd694}
.hljs-tag .hljs-attr{color:inherit}
.hljs-attribute, .hljs-title, .hljs-type{color:#ffa}
.hljs-number, .hljs-symbol{color:#d36363}
.hljs-bullet, .hljs-template-tag{color:#b8d8a2}
.hljs-built_in, .hljs-keyword, .hljs-literal, .hljs-selector-tag{color:#fcc28c}
.hljs-code, .hljs-comment, .hljs-formula{color:#888}
.hljs-link, .hljs-selector-pseudo, .hljs-regexp{color:#c6b4f0}
.hljs-meta{color:#fc9b9b}
.hljs-deletion{background:#fc9b9b;
color:#333}
.hljs-addition{background:#a2fca2;
color:#333}
.hljs-operator, .hljs-params, .hljs-property, .hljs-punctuation{}
.hljs-subst{color:#fff}
.hljs a{color:inherit}
.hljs a:focus, .hljs a:hover{color:inherit;
text-decoration:underline}
.hljs mark{background:#555;
color:inherit}</style></head><body><div id="__next" data-reactroot=""><header class="jsx-f32a99b3114a7438"><div class="jsx-f32a99b3114a7438 home"><a href="/">Ordinary</a></div><div class="jsx-f32a99b3114a7438 about"><a class="jsx-f32a99b3114a7438" href="/about">About</a></div></header><main><div class="jsx-18cc8619c204c37c"><div class="jsx-477b66404f654573"><article class="jsx-477b66404f654573 container"><aside class="jsx-ba6267904dd67a4c"><nav class="jsx-ba6267904dd67a4c"><ul class="jsx-ba6267904dd67a4c"><li class="jsx-506446869"><a href="#10.1 도입" class="jsx-506446869"> <!-- -->10.1 도입</a></li><li class="jsx-506446869"><a href="#10.2 문제: 도시락 데우기" class="jsx-506446869"> <!-- -->10.2 문제: 도시락 데우기</a></li><li class="jsx-506446869"><a href="#10.3 풀이: 도시락 데우기" class="jsx-506446869"> <!-- -->10.3 풀이: 도시락 데우기</a></li><li class="jsx-506446869"><a href="#10.4 문제: 문자열 합치기" class="jsx-506446869"> <!-- -->10.4 문제: 문자열 합치기</a></li><li class="jsx-506446869"><a href="#10.5 풀이: 문자열 합치기" class="jsx-506446869"> <!-- -->10.5 풀이: 문자열 합치기</a></li><li class="jsx-2105002209"><a href="#이론적 배경: 허프만 코드" class="jsx-2105002209"> <!-- -->이론적 배경: 허프만 코드</a></li><li class="jsx-506446869"><a href="#10.6 문제: 미나스 아노르" class="jsx-506446869"> <!-- -->10.6 문제: 미나스 아노르</a></li><li class="jsx-506446869"><a href="#10.7 풀이: 미나스 아노르" class="jsx-506446869"> <!-- -->10.7 풀이: 미나스 아노르</a></li></ul></nav></aside><div class="jsx-477b66404f654573 head"><h1 class="jsx-477b66404f654573">문제 해결 전략 10</h1><div class="jsx-66c5b3c4cf32749c"><img src="/profile.png" alt="profile" class="jsx-66c5b3c4cf32749c"/><span class="jsx-66c5b3c4cf32749c">ordilov<!-- --> / <!-- -->2021. 6. 23</span></div></div><div id="10.1 도입"><h2>10.1 도입</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">탐욕법은 가장 직관적인 설계 패러다임 중 하나입니다.
탐욕법은 재귀호출처럼 여러 개의 조각으로 쪼개고 답을 만들어나갑니다.
다른 점은 모든 선택지를 고려하는 방법과 달리 지금 당장 좋은 것만 선택합니다.
모든 경우를 다 고려하지 않기 때문에 최적해가 나오지 않을 수 있습니다.
따라서 탐욕법은 크게 다음 두 가지 경우에 사용합니다.</p>
<ol>
<li>탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제인 경우</li>
<li>시간이나 공간적 제약으로 다른 방법으로 최적해를 구하기 어려운 경우</li>
</ol>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">탐욕적 알고리즘은 보통 1번 용도로만 사용됩니다.
탐욕법이 개념적으로는 간단하지만 문제에 따라 어려워질 수 있습니다.
문제를 탐욕적으로 해결하는 방법이 여러개일 때 무엇을 선택할지 알아야 합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>예제: 회의실 예약</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">탐욕법이 유용하게 사용되는 문제 중 유명한 예로 활동 선택 문제가 있습니다.
회의실이 하나밖에 없는데 n개의 팀이 각각 회의하고 싶은 시간이 있습니다.
두 팀이 같이 회의실을 쓸 수 없기에 서로 겹치지 않는 회의만 고라냅니다.
최대 몇개나 선택할 수 있을까요?</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>무식하게 풀 수 있을까?</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 문제에는 답이 여러가지 있을 수 있습니다.
겹치지 않는 회의들의 집합은 모두 이 문제의 답이 될겁니다.
이때 우리가 원하는 가장 좋은 답, 최적해는 크기가 가장 큰 부분 집합입니다.
이 문제를 무식하게 푸는 방법은 모든 경우를 다 만들어냅니다.
다만 크기가 n이므로 집합의 수는 2^n이 되기에 시간제약이 있습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>탐욕적 알고리즘의 구상</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이런 문제를 탐욕적으로 해결하는 방법을 몇 가지 떠올릴 수 있습니다.
길이가 가장 짧은 회의부터 하나하나 순회하면서 추가할 수 있습니다.
이 방법은 사용 가능한 시간을 최대화하려하기에 그럴듯해보입니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">원칙적으론 그럴듯해 보이지만 예외인 경우가 많습니다.
이 문제를 해결하는 탐욕적인 방법은 길이와 상관없이 먼저 끝나는 회의를 택합니다.
가장 먼저 끝나는 회의를 택하고 겹치는 것은 지우고 다시 반복합니다.</p>
<ol>
<li>목록 S에 남은 회의 중 가장 일찍 끝나는 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">S_min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord mathnormal">in</span></span></span></span></span>을 선택한다.</li>
<li><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">S_min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord mathnormal">in</span></span></span></span></span>과 겹치는 회의를 S에서 모두 지운다.</li>
<li>S가 텅 빌 때까지 반복한다.</li>
</ol>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 쪽은 오히려 좀 덜 직관적입니다.
이렇게 해서 가장 많은 회의를 택할 수 있을까요?</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>정당성의 증명: 탐욕적 선택 속성</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">탐욕적 알고리즘의 정장성 증명은 많은 경우 일정한 패턴을 가집니다.
증명 패턴은 탐욕적인 알고리즘의 최적해를 구할 수 있는 두 가지 속성을 보입니다.
처음으로 증명해야할 속성은 모든 답을 구하지 않고 최적해를 구하는 것입니다.
이 속성은 매우 중요하므로 탐욕적 선택 속성이라 부릅니다.
회의실 문제에서 탐욕적 선택 속성은 다음 조건입니다.</p>
<blockquote>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">가장 종료 시간이 빠른 회의를 포함하는 최적해가 반드시 존재한다.</p>
</blockquote>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">S의 최적해 중에 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">S_min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord mathnormal">in</span></span></span></span></span>을 포함하지 않는 답이 있다고 가정합니다.
이 답은 서로 겹치지 않는 회의의 목록인데 이 목록의 첫 번째 회의를 지웁니다.
그리고 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">S_min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord mathnormal">in</span></span></span></span></span>을 포함하는 회의를 넣으면 겹치지 않습니다.
즉 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>S</mi><mi>m</mi></msub><mi>i</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">S_min</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em"><span style="top:-2.55em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">m</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mord mathnormal">in</span></span></span></span></span>을 포함해도 최적해는 항상 존재하게 됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>최적 부분 구조</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이렇게 탐욕적 방법으로 최적해를 구할 수 있다고 증명이 끝나지 않습니다.
항상 최적의 선택을 해서 전체 문제의 최적해를 구할 수 있어야 합니다.
이것은 당연해 보이지만 경우에 따라 성립하지 않습니다.
첫 번째 선택을 하고 나서 부분 문제는 최적이 아닌 경우입니다.
이 두번째 속성을 최적 부분 구조라고 부릅니다.
다행히 대부분의 문제에서 이 부분은 증명하지 않아도 당연히 맞습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>구현</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">우리가 설명한 알고리즘에서 하나를 선택하면 겹치는 회의를 모두 지웁니다.
설명은 간단하지만 구현을 하면 시간 복잡도는 O(n^2) 이 걸리는 작업입니다.
이 알고리즘을 쉽고 바르게 구현하려면 회의를 종료시간으로 정렬해둡니다.
이 때 정렬된 첫번째 회의는 무조건 선택 가능합니다.
그 후 겹치는 회의를 찾을 필요 없이 정렬된 것에서 안겹치는 부분을 찾습니다.
이런 식으로 구성하면 O(nlogn)의 시간복잡도를 가지게 됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>난 동적 계획법으로 풀었는데?</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 문제는 동적 계획법으로도 풀 수 있을 것 같습니다.</p>
<blockquote>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">schedule(idx) = meeting[idx] 혹은 그 이전 끝나는 회의들 중 선택 가능한 최대</p>
</blockquote>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">schedule()은 매 단계예서 meeting[idx]를 선택할지 여부를 결정합니다.
선택하지 않은 경우는 캐시에 저장하게 될 것입니다.
이 경우에도 시간 복잡도는 비슷하게 소요됩니다.
이 문제뿐만 아니라 대부분의 탐욕법은 동적 계획법으로 풀 수 있습니다.
다만 탐욕법을 사용했을 때 메모리나 시간을 아낄 수 있습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>예제: 출전 순서 정하기</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">프로그래밍 대회 결승전이 이틀 앞으로 다가왔습니다.
각 팀은 n명씩의 코더들로 구성되어 있고 결승전에서 1:1 경기가 치뤄집니다.
더 많은 승리를 가져간팀이 우승하며 대회전날 출전 선수를 알려줘야합니다.
한국팀 감독이 러시아팀 출전 순서를 알아냈습니다.
각 실력을 rating으로 표현할 때 항상 rating이 높은 선수가 승리합니다.
rating이 같은 경우 우리팀이 이긴다고 가정합니다.
상대방의 순서를 알 때 어느 순서대로 보내야 승수를 최대화할까요?</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>무식하게 풀 수 있을까?</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">n명의 선수가 있으니 이 문제에 답에는 n!개가 있습니다.
완전 탐색으로도 풀 수 있지만 n이 커지면 불가능합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>그렇다면 동적계획법은 어떨까?</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">n!개의 답을 모두 생성하는 동적계획법은 가능합니다.
각 한국팀 선수를 이미 순서에 추가했는지 여부를 담은 taken을 지정합니다.
taken에 포함된 true 수로 다음 경기 선수도 정할 수 있습니다.
최종 O(n*2^n)시간이 걸리게 됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>탐욕적 알고리즘의 구상</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">n이 100명이라면 동적 계획법보다 빠른 방법이 필요합니다.
탐욕적 알고리즘을 설계하는 좋은 방법은 손으로 간단하게 풀어봅니다.
이 문제를 풀 수 있는 탐욕적 알고리즘에는 여러가지가 있습니다.
그 중 하나는 이길 수 있는 선수 중 가장 레이팅이 낮은 선수를 보냅니다.
모든 선수가 이길 수 없는 경우 레이팅이 가장 낮은 선수를 보냅니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>탐욕적 선택 속성 증명</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 알고리즘은 분명 합리적으로 보입니다.
어차피 질 경기라면 가장 낮은 레이팅이 낮은 선수를 보내는게 이득입니다.
이길 수 있는 경기라도 레이팅이 높은 선수는 아끼는게 좋습니다.
이 방법의 정당성 증명을 위해 최적해가 존재함을 증명합니다.
먼저 이 경기를 질 수 밖에 없는 경우를 고려합니다.
상대방 선수가 모든 우리 팀 선수보다 레이팅이 높은 경우 지게됩니다.
이 경기에 가장 레이팅이 낮은 선수 A 대신 B를 내보내는 최적해를 가정합니다.
A가 x를 상대하고 있는 경우 둘을 바꾸게 되면 x는 항상 더 높은 수 B를 만납니다.
따라서 승수가 줄어들 일은 없게 됩니다.
다음으로는 이길 수 있는 경우를 고려합니다.
상대팀 선수보다 레이팅이 높거나 같은 우리 선수가 있다면 승리합니다.
승리할 수 있는 선수 중 레이팅이 가장 낮은 A대신 B를 내는 최적해를 가정합니다.
여기서 둘을 바꾸게 되면 A를 만나는 상대는 더 낮은 레이팅을 상대하게 됩니다.
따라서 어느 경우이든 알고리즘을 통해 최적해를 보장합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>최적 부분 구조 증명</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">첫번째 경기를 선택하고 나면 남은 선수들도 반복하게 됩니다.</p>
<div id="10.2 문제: 도시락 데우기"><h2>10.2 문제: 도시락 데우기</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">도시락 업체에서 n개의 도시락을 주문했습니다.
주문량이 많아서 여러 종류의 도시락을 주문해서 냉장고에 넣었습니다.
점심시간에 도시락을 먹는데 전자레인지로 데우려고 합니다.
전자레인지에 도시락을 한번에 하나만 데울 수 있습니다.
i번째 도시락을 데우는데 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>초가 걸리고 먹는데 <span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>e</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">e_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5806em;vertical-align:-0.15em"></span><span class="mord"><span class="mord mathnormal">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span></span></span></span></span>초가 걸립니다.
도시락을 두 번에 나눠서 데울 수는 없습니다.
도시락을 데운 이에 사람들은 음식을 바로 먹습니다.
원석이는 점심을 먹는 시간을 최소화하고 싶습니다.
점심을 먹는데 걸리는 시간은 데우는 시간부터 다 먹는 시간까지입니다.
어느 순서로 도시락을 데워야 점심시간을 가장 빨리 마칠까요?</p>
<div id="10.3 풀이: 도시락 데우기"><h2>10.3 풀이: 도시락 데우기</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이런 형태의 스케줄링 문제는 탐욕법 문제의 단골 손님입니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>최소화해야 할 값</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">일단 최소화해 할 값을 정의해봅시다.
도시락을 먹을 때까지 걸리는 시간은 지금까지 데운 도시락 시간 + 먹는 시간입니다.
우리는 그 중 가장 늦게 먹는 도시락의 시간을 최소화하려고 합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>탐욕적 알고리즘의 구상</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">단순한 형태의 문제를 고려해보면 답의 구조를 짐작할 수 있습니다.
모든 도시락을 먹는데 같은 시간 C가 걸린다고 가정해 봅시다.
그러면 어떤 순서로 도시락을 데우던 간에 점심시간의 길이는 정해져있습니다.
모든 도시락을 데우는 시간 + 도시락 하나를 먹는 시간의 합이 될 것입니다.
마지막에 데우는 도시락을 결국 마지막에 먹게 될것입니다.
n-1개의 도시락 사이에서 먹는데 오래 걸리는 1개가 있다고 생각해봅니다.
이 때 오래 걸리는 걸 먼제 데우는 게 나을까요 아니면 나중에 데우는 게 나을까요?
먼저 데우는게 먹는 시간을 고려하면 낫다고 판단됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>탐욕적 선택 속성 증명</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">먹는데 오래 걸리는 도시락을 먼저 데우는 게 최적해인걸 증명해봅니다.
빨리 먹을 수 있는 도시락을 먼저 데우는 최적해가 있다고 가정합니다.
이때 먼저 데우는 도시락을 오래 걸리는 도시락과 바꿀 수 있으면 증명됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">둘의 순서를 바꾸더라도 데우는 시간은 어느 도시락이나 달라지지 않습니다.
따라서 먹는 시간만 고려하면 됩니다.
둘의 순서를 바꾸더라도 마지막 먹는 시간은 더 짧아집니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>최적 부분 구조 증명</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">첫번째 도시락을 정하고 나면 나머지 도시락들을 배치해야합니다.
나머지 도시락들도 먹는데 걸리는 시간을 정하면 최적의 선택이 됩니다.</p>
<div id="10.4 문제: 문자열 합치기"><h2>10.4 문제: 문자열 합치기</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">C언어의 큰 문제점 중 하나는 언어 차원에서 문자열 변수형을 지원하지 않습니다.
C에서는 문자 배열로 문자열을 표현하되 \0으로 문자열 끝을 지정합니다.
이래서는 문자열의 길을 쉽게 알기 힘듭니다.
이런 문제 중 하나로 문자열을 조작하는 함수들의 동작 시간이 불필요하게 커집니다.
strcat() 같은 함수는 반복문을 통해 문자열의 길이 만큼 수행됩니다.</p>
<pre><code class="hljs language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">strcat</span><span class="hljs-params">(<span class="hljs-type">char</span>* dest, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* src)</span> {
 <span class="hljs-comment">// dest 의 마지막 위치를 찾는다</span>
 <span class="hljs-keyword">while</span>(*dest) ++dest;
 <span class="hljs-comment">// src 를 한 글자씩 dest 에 옮겨 붙인다</span>
 <span class="hljs-keyword">while</span>(*src) *(dest++) = *(src++);
 <span class="hljs-comment">// 문자열의 끝을 알리는 \0 을 추가한다</span>
 *dest = <span class="hljs-number">0</span>;
}
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 함수를 이용해 n개의 문자열을 순서와 상관없이 합쳐서 하나로 만들려고합니다.
순서와 상관없다는 말은 al,go,spot 을 spotalgo 로 합치든 alspotgo도 됩니다.
그러나 문자열을 합치는 순서에 따라 전체 비용이 달라질 수 있습니다.
<code>al</code> <code>go</code>를 합치고 (2+2) spot을 합치면 (4+4), (4+8) = 12의 비용이 듭니다.
<code>al</code> <code>spot</code>을 합치고 (2+4) 이것을 go에 합치면 (6+2), (6+8) = 14의 비용이 듭니다.
n개의 문자열들의 길이가 주어질 때 필요한 최소 비용을 찾습니다.</p>
<div id="10.5 풀이: 문자열 합치기"><h2>10.5 풀이: 문자열 합치기</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 문제에 대한 직관을 얻는 좋은 방법은 문자열 합치는 과정을 그림으로 그립니다.
그리는 방법 중에 트리와 같은 형태로 문자열을 합치는 과정을 표현할 수 있습니다.
사각형은 각 단계마다 합친 결과로 원은 입력 문자열로 표현할 수 있습니다.
문자열을 합치는데 드는 비용은 결과 문자열의 길이와 같습니다.
따라서 총 비용은 사각형의 숫자들의 총합이 됩니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>탐욕적 알고리즘의 구상</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">문자열을 병할할 때마다 병함되는 문자열들의 총 길이가 전체 비용에 더해집니다.
합쳐진 결과 문자열의 길이를 원래 입력에 주어졌던 문자열별로 나눌 수 있습니다.
한 문장열로 인해 발생하는 총 비용은 문자열의 길이와 병합되는 횟수의 곱입니다.
즉 문자열의 길이가 길수록 적게 병합되는 위치에 있어야합니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>알고리즘 설계하기</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">탐욕적 알고리즘은 문제의 답을 여러 조각으로 나눠 조각마다 한가지 선택을 합니다.
이 문제에서는 한 조각마다 두 문자열을 합치는 선택을 합니다.
문자열 목록에서 두개를 고르고 이들을 합치고 다시 문자열 목록에 추가합니다.
문자열이 길면 길수록 병합 과정이 짧으면 유리하다는 점을 생각합니다.
항상 가장 짧은 두개를 먼저 병합하면 어떨까라고 생각해볼 수 있습니다.
이것이 최적해를 찾아낼 수 있을까요?</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>정당성 증명</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">우선 탐욕적 선택 속성부터 증명해 보도록 하겠습니다.
탐욕적 알고리즘은 매 단계마다 가장 짧은 두 문자열을 합치는 것을 반복합니다.
증명을 위해서 기존처럼 귀류법을 통해 증명할 수 있습니다.
문제의 최적해가 가장 짧은 a와 b를 합친 경우가 아닐 때로 가정합니다.
a와 b가 최초로 합쳐지는 문자열을 X라고 가정합니다.
문자열이 어느 순서로 합쳐지든 합쳐지는 순간의 길이는 일정합니다.
길이가 상관없다면 비용에서 차이가 나는 부분은 병합 횟수입니다.
a와 처음 합쳐지는 문자열을 x라고 가정합니다.
x와 b를 바꾼다면 비용은 어떻게 달라질까요?
만약 a와 b의 병합까지의 횟수가 같다면 달라지지 않습니다.
하지만 둘의 거리가 다르다면 달라지게 됩니다.
a가 b보다 거리가 멀다고 하면 b보다 비용이 큰 x가 더 적게 나오게 됩니다.
즉 바꿨을 때 비용은 더 줄어들 수 밖에 없습니다.
따라서 가장 작은 두 개를 합쳐나가는 게 가장 비용이 적습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>구현</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이렇게 만든 탐욕적 알고리즘은 문자열의 길이 목록을 유지해야합니다.
그러면서 최소길이를 골라내고 새 길이를 추가하는 과정을 거칩니다.
이와 같은 동작을 효율적으로 구현해주는 것이 우선순위 큐입니다.
우선순위 큐는 집합에서 가장 작은 원소를 찾고 추가하는 과정을 O(logn)에 합니다.
n이 작은 경우 어떤 자료구조를 사용해도 가능하기는 합니다.
전체 구현을 하면 문자열을 전부 돌아야 하므로 n번을 돌아야합니다.
전체 과정을 합치면 O(nlogn)의 수행시간을 가집니다.</p>
<div id="이론적 배경: 허프만 코드"><h3>이론적 배경: 허프만 코드</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 문제는 사실 탐욕적 알고리즘으로 유명한 허프만 코드 알고리즘입니다.
허프만 코드는 가변 길이 인코딩 테이블을 만드는 방법입니다.
여러 압축 알고리즘에 종종 사용됩니다.
가변 길이 인코딩은 원문의 각 글자를 서로 길이가 다른 비트 패턴으로 바꿉니다.
이로써 원문의 길이를 줄일 수 있습니다.
자주 출현하는 글자는 더 짧은 패턴으로 줄이게 배당할 수 있습니다.
원문에 출현하는 글자들의 출현 빈도가 주어질때 예상길이를 최소화합니다.</p>
<div id="10.6 문제: 미나스 아노르"><h2>10.6 문제: 미나스 아노르</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">도시 미나스 아노르에는 반지름이 8키로미터인 원형 성벽 람마스 에코르가 있습니다.
도시 전체를 감싸는 거대한 성벽에는 n개의 초소가 배치되어 있습니다.
각 초소들은 해당 위치를 중심으로 반지름 r의 원 내부를 감시합니다.
최소의 인원으로 성벽의 모든 부분을 감시하려 합니다.
성벽의 모든 부분을 감시하기 위해 필요한 최소한의 병사의 수를 계산합니다.</p>
<div id="10.7 풀이: 미나스 아노르"><h2>10.7 풀이: 미나스 아노르</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">기하 문제이면서 실수 좌표를 다루는 문제는 까다롭습니다.
기하 문제에는 수많은 예외들이 있고 실수 연산은 오류가 나기 쉽습니다.
다행히 이 문제에서는 입력에 주어지는 실수가 조금 달라져도 값이 같습니다.
그 뜻은 초소의 감시 범위의 끝이 경계에 정확히 일치하지 않느다는 의미입니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><strong>중심각 구간으로 원을 덮는 문제</strong></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">처음해야 할 일은 2차원 평뭔의 도형을 우리가 다루기 쉽게 변형합니다.
지금 주어진 것으로는 초소로 성벽 전체를 감시할 수 있나 알기도 어렵습니다.
각 초소에서 감시할 수 있는 성벽은 전체 중 일부분입니다.
초소가 감시할 수 있는 범위 중 성벽 부분을 호로 생각할 수 있습니다.
부채꼴 모양으로 생각했을 때 이 호 부분을 중심각 기준으로 생각할 수 있습니다.
원의 반지름은 이 호의 중앙에서 끝까지의 범위가 될 것입니다.</p></article></div></div></main><footer class="jsx-d894c386b3e00b94"><span class="jsx-d894c386b3e00b94"><a href="https://github.com/ordilov" class="jsx-5a92e9cb5e0cf5e5 github">Github 🔗</a></span><span class="jsx-d894c386b3e00b94">Copyright © Ordilov</span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"문제 해결 전략 10","date":"2021-06-24 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"문제-해결-전략-10"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      ol: \"ol\",\n      li: \"li\",\n      strong: \"strong\",\n      span: \"span\",\n      math: \"math\",\n      semantics: \"semantics\",\n      mrow: \"mrow\",\n      msub: \"msub\",\n      mi: \"mi\",\n      annotation: \"annotation\",\n      blockquote: \"blockquote\",\n      pre: \"pre\",\n      code: \"code\",\n      h3: \"h3\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"10.1 도입\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"탐욕법은 가장 직관적인 설계 패러다임 중 하나입니다.\\n탐욕법은 재귀호출처럼 여러 개의 조각으로 쪼개고 답을 만들어나갑니다.\\n다른 점은 모든 선택지를 고려하는 방법과 달리 지금 당장 좋은 것만 선택합니다.\\n모든 경우를 다 고려하지 않기 때문에 최적해가 나오지 않을 수 있습니다.\\n따라서 탐욕법은 크게 다음 두 가지 경우에 사용합니다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"탐욕법을 사용해도 항상 최적해를 구할 수 있는 문제인 경우\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"시간이나 공간적 제약으로 다른 방법으로 최적해를 구하기 어려운 경우\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"탐욕적 알고리즘은 보통 1번 용도로만 사용됩니다.\\n탐욕법이 개념적으로는 간단하지만 문제에 따라 어려워질 수 있습니다.\\n문제를 탐욕적으로 해결하는 방법이 여러개일 때 무엇을 선택할지 알아야 합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"예제: 회의실 예약\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"탐욕법이 유용하게 사용되는 문제 중 유명한 예로 활동 선택 문제가 있습니다.\\n회의실이 하나밖에 없는데 n개의 팀이 각각 회의하고 싶은 시간이 있습니다.\\n두 팀이 같이 회의실을 쓸 수 없기에 서로 겹치지 않는 회의만 고라냅니다.\\n최대 몇개나 선택할 수 있을까요?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"무식하게 풀 수 있을까?\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 문제에는 답이 여러가지 있을 수 있습니다.\\n겹치지 않는 회의들의 집합은 모두 이 문제의 답이 될겁니다.\\n이때 우리가 원하는 가장 좋은 답, 최적해는 크기가 가장 큰 부분 집합입니다.\\n이 문제를 무식하게 푸는 방법은 모든 경우를 다 만들어냅니다.\\n다만 크기가 n이므로 집합의 수는 2^n이 되기에 시간제약이 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"탐욕적 알고리즘의 구상\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 문제를 탐욕적으로 해결하는 방법을 몇 가지 떠올릴 수 있습니다.\\n길이가 가장 짧은 회의부터 하나하나 순회하면서 추가할 수 있습니다.\\n이 방법은 사용 가능한 시간을 최대화하려하기에 그럴듯해보입니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"원칙적으론 그럴듯해 보이지만 예외인 경우가 많습니다.\\n이 문제를 해결하는 탐욕적인 방법은 길이와 상관없이 먼저 끝나는 회의를 택합니다.\\n가장 먼저 끝나는 회의를 택하고 겹치는 것은 지우고 다시 반복합니다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"목록 S에 남은 회의 중 가장 일찍 끝나는 \", _jsx(_components.span, {\n            className: \"math math-inline\",\n            children: _jsxs(_components.span, {\n              className: \"katex\",\n              children: [_jsx(_components.span, {\n                className: \"katex-mathml\",\n                children: _jsx(_components.math, {\n                  xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                  children: _jsxs(_components.semantics, {\n                    children: [_jsxs(_components.mrow, {\n                      children: [_jsxs(_components.msub, {\n                        children: [_jsx(_components.mi, {\n                          children: \"S\"\n                        }), _jsx(_components.mi, {\n                          children: \"m\"\n                        })]\n                      }), _jsx(_components.mi, {\n                        children: \"i\"\n                      }), _jsx(_components.mi, {\n                        children: \"n\"\n                      })]\n                    }), _jsx(_components.annotation, {\n                      encoding: \"application/x-tex\",\n                      children: \"S_min\"\n                    })]\n                  })\n                })\n              }), _jsx(_components.span, {\n                className: \"katex-html\",\n                \"aria-hidden\": \"true\",\n                children: _jsxs(_components.span, {\n                  className: \"base\",\n                  children: [_jsx(_components.span, {\n                    className: \"strut\",\n                    style: {\n                      height: \"0.8333em\",\n                      verticalAlign: \"-0.15em\"\n                    }\n                  }), _jsxs(_components.span, {\n                    className: \"mord\",\n                    children: [_jsx(_components.span, {\n                      className: \"mord mathnormal\",\n                      style: {\n                        marginRight: \"0.05764em\"\n                      },\n                      children: \"S\"\n                    }), _jsx(_components.span, {\n                      className: \"msupsub\",\n                      children: _jsxs(_components.span, {\n                        className: \"vlist-t vlist-t2\",\n                        children: [_jsxs(_components.span, {\n                          className: \"vlist-r\",\n                          children: [_jsx(_components.span, {\n                            className: \"vlist\",\n                            style: {\n                              height: \"0.1514em\"\n                            },\n                            children: _jsxs(_components.span, {\n                              style: {\n                                top: \"-2.55em\",\n                                marginLeft: \"-0.0576em\",\n                                marginRight: \"0.05em\"\n                              },\n                              children: [_jsx(_components.span, {\n                                className: \"pstrut\",\n                                style: {\n                                  height: \"2.7em\"\n                                }\n                              }), _jsx(_components.span, {\n                                className: \"sizing reset-size6 size3 mtight\",\n                                children: _jsx(_components.span, {\n                                  className: \"mord mathnormal mtight\",\n                                  children: \"m\"\n                                })\n                              })]\n                            })\n                          }), _jsx(_components.span, {\n                            className: \"vlist-s\",\n                            children: \"​\"\n                          })]\n                        }), _jsx(_components.span, {\n                          className: \"vlist-r\",\n                          children: _jsx(_components.span, {\n                            className: \"vlist\",\n                            style: {\n                              height: \"0.15em\"\n                            },\n                            children: _jsx(_components.span, {})\n                          })\n                        })]\n                      })\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    children: \"in\"\n                  })]\n                })\n              })]\n            })\n          }), \"을 선택한다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.span, {\n            className: \"math math-inline\",\n            children: _jsxs(_components.span, {\n              className: \"katex\",\n              children: [_jsx(_components.span, {\n                className: \"katex-mathml\",\n                children: _jsx(_components.math, {\n                  xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                  children: _jsxs(_components.semantics, {\n                    children: [_jsxs(_components.mrow, {\n                      children: [_jsxs(_components.msub, {\n                        children: [_jsx(_components.mi, {\n                          children: \"S\"\n                        }), _jsx(_components.mi, {\n                          children: \"m\"\n                        })]\n                      }), _jsx(_components.mi, {\n                        children: \"i\"\n                      }), _jsx(_components.mi, {\n                        children: \"n\"\n                      })]\n                    }), _jsx(_components.annotation, {\n                      encoding: \"application/x-tex\",\n                      children: \"S_min\"\n                    })]\n                  })\n                })\n              }), _jsx(_components.span, {\n                className: \"katex-html\",\n                \"aria-hidden\": \"true\",\n                children: _jsxs(_components.span, {\n                  className: \"base\",\n                  children: [_jsx(_components.span, {\n                    className: \"strut\",\n                    style: {\n                      height: \"0.8333em\",\n                      verticalAlign: \"-0.15em\"\n                    }\n                  }), _jsxs(_components.span, {\n                    className: \"mord\",\n                    children: [_jsx(_components.span, {\n                      className: \"mord mathnormal\",\n                      style: {\n                        marginRight: \"0.05764em\"\n                      },\n                      children: \"S\"\n                    }), _jsx(_components.span, {\n                      className: \"msupsub\",\n                      children: _jsxs(_components.span, {\n                        className: \"vlist-t vlist-t2\",\n                        children: [_jsxs(_components.span, {\n                          className: \"vlist-r\",\n                          children: [_jsx(_components.span, {\n                            className: \"vlist\",\n                            style: {\n                              height: \"0.1514em\"\n                            },\n                            children: _jsxs(_components.span, {\n                              style: {\n                                top: \"-2.55em\",\n                                marginLeft: \"-0.0576em\",\n                                marginRight: \"0.05em\"\n                              },\n                              children: [_jsx(_components.span, {\n                                className: \"pstrut\",\n                                style: {\n                                  height: \"2.7em\"\n                                }\n                              }), _jsx(_components.span, {\n                                className: \"sizing reset-size6 size3 mtight\",\n                                children: _jsx(_components.span, {\n                                  className: \"mord mathnormal mtight\",\n                                  children: \"m\"\n                                })\n                              })]\n                            })\n                          }), _jsx(_components.span, {\n                            className: \"vlist-s\",\n                            children: \"​\"\n                          })]\n                        }), _jsx(_components.span, {\n                          className: \"vlist-r\",\n                          children: _jsx(_components.span, {\n                            className: \"vlist\",\n                            style: {\n                              height: \"0.15em\"\n                            },\n                            children: _jsx(_components.span, {})\n                          })\n                        })]\n                      })\n                    })]\n                  }), _jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    children: \"in\"\n                  })]\n                })\n              })]\n            })\n          }), \"과 겹치는 회의를 S에서 모두 지운다.\"]\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"S가 텅 빌 때까지 반복한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 쪽은 오히려 좀 덜 직관적입니다.\\n이렇게 해서 가장 많은 회의를 택할 수 있을까요?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"정당성의 증명: 탐욕적 선택 속성\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"탐욕적 알고리즘의 정장성 증명은 많은 경우 일정한 패턴을 가집니다.\\n증명 패턴은 탐욕적인 알고리즘의 최적해를 구할 수 있는 두 가지 속성을 보입니다.\\n처음으로 증명해야할 속성은 모든 답을 구하지 않고 최적해를 구하는 것입니다.\\n이 속성은 매우 중요하므로 탐욕적 선택 속성이라 부릅니다.\\n회의실 문제에서 탐욕적 선택 속성은 다음 조건입니다.\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"가장 종료 시간이 빠른 회의를 포함하는 최적해가 반드시 존재한다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"S의 최적해 중에 \", _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsxs(_components.msub, {\n                      children: [_jsx(_components.mi, {\n                        children: \"S\"\n                      }), _jsx(_components.mi, {\n                        children: \"m\"\n                      })]\n                    }), _jsx(_components.mi, {\n                      children: \"i\"\n                    }), _jsx(_components.mi, {\n                      children: \"n\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"S_min\"\n                  })]\n                })\n              })\n            }), _jsx(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.8333em\",\n                    verticalAlign: \"-0.15em\"\n                  }\n                }), _jsxs(_components.span, {\n                  className: \"mord\",\n                  children: [_jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    style: {\n                      marginRight: \"0.05764em\"\n                    },\n                    children: \"S\"\n                  }), _jsx(_components.span, {\n                    className: \"msupsub\",\n                    children: _jsxs(_components.span, {\n                      className: \"vlist-t vlist-t2\",\n                      children: [_jsxs(_components.span, {\n                        className: \"vlist-r\",\n                        children: [_jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.1514em\"\n                          },\n                          children: _jsxs(_components.span, {\n                            style: {\n                              top: \"-2.55em\",\n                              marginLeft: \"-0.0576em\",\n                              marginRight: \"0.05em\"\n                            },\n                            children: [_jsx(_components.span, {\n                              className: \"pstrut\",\n                              style: {\n                                height: \"2.7em\"\n                              }\n                            }), _jsx(_components.span, {\n                              className: \"sizing reset-size6 size3 mtight\",\n                              children: _jsx(_components.span, {\n                                className: \"mord mathnormal mtight\",\n                                children: \"m\"\n                              })\n                            })]\n                          })\n                        }), _jsx(_components.span, {\n                          className: \"vlist-s\",\n                          children: \"​\"\n                        })]\n                      }), _jsx(_components.span, {\n                        className: \"vlist-r\",\n                        children: _jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.15em\"\n                          },\n                          children: _jsx(_components.span, {})\n                        })\n                      })]\n                    })\n                  })]\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"in\"\n                })]\n              })\n            })]\n          })\n        }), \"을 포함하지 않는 답이 있다고 가정합니다.\\n이 답은 서로 겹치지 않는 회의의 목록인데 이 목록의 첫 번째 회의를 지웁니다.\\n그리고 \", _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsxs(_components.msub, {\n                      children: [_jsx(_components.mi, {\n                        children: \"S\"\n                      }), _jsx(_components.mi, {\n                        children: \"m\"\n                      })]\n                    }), _jsx(_components.mi, {\n                      children: \"i\"\n                    }), _jsx(_components.mi, {\n                      children: \"n\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"S_min\"\n                  })]\n                })\n              })\n            }), _jsx(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.8333em\",\n                    verticalAlign: \"-0.15em\"\n                  }\n                }), _jsxs(_components.span, {\n                  className: \"mord\",\n                  children: [_jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    style: {\n                      marginRight: \"0.05764em\"\n                    },\n                    children: \"S\"\n                  }), _jsx(_components.span, {\n                    className: \"msupsub\",\n                    children: _jsxs(_components.span, {\n                      className: \"vlist-t vlist-t2\",\n                      children: [_jsxs(_components.span, {\n                        className: \"vlist-r\",\n                        children: [_jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.1514em\"\n                          },\n                          children: _jsxs(_components.span, {\n                            style: {\n                              top: \"-2.55em\",\n                              marginLeft: \"-0.0576em\",\n                              marginRight: \"0.05em\"\n                            },\n                            children: [_jsx(_components.span, {\n                              className: \"pstrut\",\n                              style: {\n                                height: \"2.7em\"\n                              }\n                            }), _jsx(_components.span, {\n                              className: \"sizing reset-size6 size3 mtight\",\n                              children: _jsx(_components.span, {\n                                className: \"mord mathnormal mtight\",\n                                children: \"m\"\n                              })\n                            })]\n                          })\n                        }), _jsx(_components.span, {\n                          className: \"vlist-s\",\n                          children: \"​\"\n                        })]\n                      }), _jsx(_components.span, {\n                        className: \"vlist-r\",\n                        children: _jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.15em\"\n                          },\n                          children: _jsx(_components.span, {})\n                        })\n                      })]\n                    })\n                  })]\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"in\"\n                })]\n              })\n            })]\n          })\n        }), \"을 포함하는 회의를 넣으면 겹치지 않습니다.\\n즉 \", _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsxs(_components.msub, {\n                      children: [_jsx(_components.mi, {\n                        children: \"S\"\n                      }), _jsx(_components.mi, {\n                        children: \"m\"\n                      })]\n                    }), _jsx(_components.mi, {\n                      children: \"i\"\n                    }), _jsx(_components.mi, {\n                      children: \"n\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"S_min\"\n                  })]\n                })\n              })\n            }), _jsx(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.8333em\",\n                    verticalAlign: \"-0.15em\"\n                  }\n                }), _jsxs(_components.span, {\n                  className: \"mord\",\n                  children: [_jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    style: {\n                      marginRight: \"0.05764em\"\n                    },\n                    children: \"S\"\n                  }), _jsx(_components.span, {\n                    className: \"msupsub\",\n                    children: _jsxs(_components.span, {\n                      className: \"vlist-t vlist-t2\",\n                      children: [_jsxs(_components.span, {\n                        className: \"vlist-r\",\n                        children: [_jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.1514em\"\n                          },\n                          children: _jsxs(_components.span, {\n                            style: {\n                              top: \"-2.55em\",\n                              marginLeft: \"-0.0576em\",\n                              marginRight: \"0.05em\"\n                            },\n                            children: [_jsx(_components.span, {\n                              className: \"pstrut\",\n                              style: {\n                                height: \"2.7em\"\n                              }\n                            }), _jsx(_components.span, {\n                              className: \"sizing reset-size6 size3 mtight\",\n                              children: _jsx(_components.span, {\n                                className: \"mord mathnormal mtight\",\n                                children: \"m\"\n                              })\n                            })]\n                          })\n                        }), _jsx(_components.span, {\n                          className: \"vlist-s\",\n                          children: \"​\"\n                        })]\n                      }), _jsx(_components.span, {\n                        className: \"vlist-r\",\n                        children: _jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.15em\"\n                          },\n                          children: _jsx(_components.span, {})\n                        })\n                      })]\n                    })\n                  })]\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"in\"\n                })]\n              })\n            })]\n          })\n        }), \"을 포함해도 최적해는 항상 존재하게 됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"최적 부분 구조\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이렇게 탐욕적 방법으로 최적해를 구할 수 있다고 증명이 끝나지 않습니다.\\n항상 최적의 선택을 해서 전체 문제의 최적해를 구할 수 있어야 합니다.\\n이것은 당연해 보이지만 경우에 따라 성립하지 않습니다.\\n첫 번째 선택을 하고 나서 부분 문제는 최적이 아닌 경우입니다.\\n이 두번째 속성을 최적 부분 구조라고 부릅니다.\\n다행히 대부분의 문제에서 이 부분은 증명하지 않아도 당연히 맞습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"구현\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"우리가 설명한 알고리즘에서 하나를 선택하면 겹치는 회의를 모두 지웁니다.\\n설명은 간단하지만 구현을 하면 시간 복잡도는 O(n^2) 이 걸리는 작업입니다.\\n이 알고리즘을 쉽고 바르게 구현하려면 회의를 종료시간으로 정렬해둡니다.\\n이 때 정렬된 첫번째 회의는 무조건 선택 가능합니다.\\n그 후 겹치는 회의를 찾을 필요 없이 정렬된 것에서 안겹치는 부분을 찾습니다.\\n이런 식으로 구성하면 O(nlogn)의 시간복잡도를 가지게 됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"난 동적 계획법으로 풀었는데?\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 문제는 동적 계획법으로도 풀 수 있을 것 같습니다.\"\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"schedule(idx) = meeting[idx] 혹은 그 이전 끝나는 회의들 중 선택 가능한 최대\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"schedule()은 매 단계예서 meeting[idx]를 선택할지 여부를 결정합니다.\\n선택하지 않은 경우는 캐시에 저장하게 될 것입니다.\\n이 경우에도 시간 복잡도는 비슷하게 소요됩니다.\\n이 문제뿐만 아니라 대부분의 탐욕법은 동적 계획법으로 풀 수 있습니다.\\n다만 탐욕법을 사용했을 때 메모리나 시간을 아낄 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"예제: 출전 순서 정하기\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"프로그래밍 대회 결승전이 이틀 앞으로 다가왔습니다.\\n각 팀은 n명씩의 코더들로 구성되어 있고 결승전에서 1:1 경기가 치뤄집니다.\\n더 많은 승리를 가져간팀이 우승하며 대회전날 출전 선수를 알려줘야합니다.\\n한국팀 감독이 러시아팀 출전 순서를 알아냈습니다.\\n각 실력을 rating으로 표현할 때 항상 rating이 높은 선수가 승리합니다.\\nrating이 같은 경우 우리팀이 이긴다고 가정합니다.\\n상대방의 순서를 알 때 어느 순서대로 보내야 승수를 최대화할까요?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"무식하게 풀 수 있을까?\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"n명의 선수가 있으니 이 문제에 답에는 n!개가 있습니다.\\n완전 탐색으로도 풀 수 있지만 n이 커지면 불가능합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"그렇다면 동적계획법은 어떨까?\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"n!개의 답을 모두 생성하는 동적계획법은 가능합니다.\\n각 한국팀 선수를 이미 순서에 추가했는지 여부를 담은 taken을 지정합니다.\\ntaken에 포함된 true 수로 다음 경기 선수도 정할 수 있습니다.\\n최종 O(n*2^n)시간이 걸리게 됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"탐욕적 알고리즘의 구상\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"n이 100명이라면 동적 계획법보다 빠른 방법이 필요합니다.\\n탐욕적 알고리즘을 설계하는 좋은 방법은 손으로 간단하게 풀어봅니다.\\n이 문제를 풀 수 있는 탐욕적 알고리즘에는 여러가지가 있습니다.\\n그 중 하나는 이길 수 있는 선수 중 가장 레이팅이 낮은 선수를 보냅니다.\\n모든 선수가 이길 수 없는 경우 레이팅이 가장 낮은 선수를 보냅니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"탐욕적 선택 속성 증명\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 알고리즘은 분명 합리적으로 보입니다.\\n어차피 질 경기라면 가장 낮은 레이팅이 낮은 선수를 보내는게 이득입니다.\\n이길 수 있는 경기라도 레이팅이 높은 선수는 아끼는게 좋습니다.\\n이 방법의 정당성 증명을 위해 최적해가 존재함을 증명합니다.\\n먼저 이 경기를 질 수 밖에 없는 경우를 고려합니다.\\n상대방 선수가 모든 우리 팀 선수보다 레이팅이 높은 경우 지게됩니다.\\n이 경기에 가장 레이팅이 낮은 선수 A 대신 B를 내보내는 최적해를 가정합니다.\\nA가 x를 상대하고 있는 경우 둘을 바꾸게 되면 x는 항상 더 높은 수 B를 만납니다.\\n따라서 승수가 줄어들 일은 없게 됩니다.\\n다음으로는 이길 수 있는 경우를 고려합니다.\\n상대팀 선수보다 레이팅이 높거나 같은 우리 선수가 있다면 승리합니다.\\n승리할 수 있는 선수 중 레이팅이 가장 낮은 A대신 B를 내는 최적해를 가정합니다.\\n여기서 둘을 바꾸게 되면 A를 만나는 상대는 더 낮은 레이팅을 상대하게 됩니다.\\n따라서 어느 경우이든 알고리즘을 통해 최적해를 보장합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"최적 부분 구조 증명\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"첫번째 경기를 선택하고 나면 남은 선수들도 반복하게 됩니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"10.2 문제: 도시락 데우기\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"도시락 업체에서 n개의 도시락을 주문했습니다.\\n주문량이 많아서 여러 종류의 도시락을 주문해서 냉장고에 넣었습니다.\\n점심시간에 도시락을 먹는데 전자레인지로 데우려고 합니다.\\n전자레인지에 도시락을 한번에 하나만 데울 수 있습니다.\\ni번째 도시락을 데우는데 \", _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsx(_components.mrow, {\n                    children: _jsxs(_components.msub, {\n                      children: [_jsx(_components.mi, {\n                        children: \"m\"\n                      }), _jsx(_components.mi, {\n                        children: \"i\"\n                      })]\n                    })\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"m_i\"\n                  })]\n                })\n              })\n            }), _jsx(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.5806em\",\n                    verticalAlign: \"-0.15em\"\n                  }\n                }), _jsxs(_components.span, {\n                  className: \"mord\",\n                  children: [_jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    children: \"m\"\n                  }), _jsx(_components.span, {\n                    className: \"msupsub\",\n                    children: _jsxs(_components.span, {\n                      className: \"vlist-t vlist-t2\",\n                      children: [_jsxs(_components.span, {\n                        className: \"vlist-r\",\n                        children: [_jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.3117em\"\n                          },\n                          children: _jsxs(_components.span, {\n                            style: {\n                              top: \"-2.55em\",\n                              marginLeft: \"0em\",\n                              marginRight: \"0.05em\"\n                            },\n                            children: [_jsx(_components.span, {\n                              className: \"pstrut\",\n                              style: {\n                                height: \"2.7em\"\n                              }\n                            }), _jsx(_components.span, {\n                              className: \"sizing reset-size6 size3 mtight\",\n                              children: _jsx(_components.span, {\n                                className: \"mord mathnormal mtight\",\n                                children: \"i\"\n                              })\n                            })]\n                          })\n                        }), _jsx(_components.span, {\n                          className: \"vlist-s\",\n                          children: \"​\"\n                        })]\n                      }), _jsx(_components.span, {\n                        className: \"vlist-r\",\n                        children: _jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.15em\"\n                          },\n                          children: _jsx(_components.span, {})\n                        })\n                      })]\n                    })\n                  })]\n                })]\n              })\n            })]\n          })\n        }), \"초가 걸리고 먹는데 \", _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsx(_components.mrow, {\n                    children: _jsxs(_components.msub, {\n                      children: [_jsx(_components.mi, {\n                        children: \"e\"\n                      }), _jsx(_components.mi, {\n                        children: \"i\"\n                      })]\n                    })\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"e_i\"\n                  })]\n                })\n              })\n            }), _jsx(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.5806em\",\n                    verticalAlign: \"-0.15em\"\n                  }\n                }), _jsxs(_components.span, {\n                  className: \"mord\",\n                  children: [_jsx(_components.span, {\n                    className: \"mord mathnormal\",\n                    children: \"e\"\n                  }), _jsx(_components.span, {\n                    className: \"msupsub\",\n                    children: _jsxs(_components.span, {\n                      className: \"vlist-t vlist-t2\",\n                      children: [_jsxs(_components.span, {\n                        className: \"vlist-r\",\n                        children: [_jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.3117em\"\n                          },\n                          children: _jsxs(_components.span, {\n                            style: {\n                              top: \"-2.55em\",\n                              marginLeft: \"0em\",\n                              marginRight: \"0.05em\"\n                            },\n                            children: [_jsx(_components.span, {\n                              className: \"pstrut\",\n                              style: {\n                                height: \"2.7em\"\n                              }\n                            }), _jsx(_components.span, {\n                              className: \"sizing reset-size6 size3 mtight\",\n                              children: _jsx(_components.span, {\n                                className: \"mord mathnormal mtight\",\n                                children: \"i\"\n                              })\n                            })]\n                          })\n                        }), _jsx(_components.span, {\n                          className: \"vlist-s\",\n                          children: \"​\"\n                        })]\n                      }), _jsx(_components.span, {\n                        className: \"vlist-r\",\n                        children: _jsx(_components.span, {\n                          className: \"vlist\",\n                          style: {\n                            height: \"0.15em\"\n                          },\n                          children: _jsx(_components.span, {})\n                        })\n                      })]\n                    })\n                  })]\n                })]\n              })\n            })]\n          })\n        }), \"초가 걸립니다.\\n도시락을 두 번에 나눠서 데울 수는 없습니다.\\n도시락을 데운 이에 사람들은 음식을 바로 먹습니다.\\n원석이는 점심을 먹는 시간을 최소화하고 싶습니다.\\n점심을 먹는데 걸리는 시간은 데우는 시간부터 다 먹는 시간까지입니다.\\n어느 순서로 도시락을 데워야 점심시간을 가장 빨리 마칠까요?\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"10.3 풀이: 도시락 데우기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 형태의 스케줄링 문제는 탐욕법 문제의 단골 손님입니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"최소화해야 할 값\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"일단 최소화해 할 값을 정의해봅시다.\\n도시락을 먹을 때까지 걸리는 시간은 지금까지 데운 도시락 시간 + 먹는 시간입니다.\\n우리는 그 중 가장 늦게 먹는 도시락의 시간을 최소화하려고 합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"탐욕적 알고리즘의 구상\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"단순한 형태의 문제를 고려해보면 답의 구조를 짐작할 수 있습니다.\\n모든 도시락을 먹는데 같은 시간 C가 걸린다고 가정해 봅시다.\\n그러면 어떤 순서로 도시락을 데우던 간에 점심시간의 길이는 정해져있습니다.\\n모든 도시락을 데우는 시간 + 도시락 하나를 먹는 시간의 합이 될 것입니다.\\n마지막에 데우는 도시락을 결국 마지막에 먹게 될것입니다.\\nn-1개의 도시락 사이에서 먹는데 오래 걸리는 1개가 있다고 생각해봅니다.\\n이 때 오래 걸리는 걸 먼제 데우는 게 나을까요 아니면 나중에 데우는 게 나을까요?\\n먼저 데우는게 먹는 시간을 고려하면 낫다고 판단됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"탐욕적 선택 속성 증명\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"먹는데 오래 걸리는 도시락을 먼저 데우는 게 최적해인걸 증명해봅니다.\\n빨리 먹을 수 있는 도시락을 먼저 데우는 최적해가 있다고 가정합니다.\\n이때 먼저 데우는 도시락을 오래 걸리는 도시락과 바꿀 수 있으면 증명됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"둘의 순서를 바꾸더라도 데우는 시간은 어느 도시락이나 달라지지 않습니다.\\n따라서 먹는 시간만 고려하면 됩니다.\\n둘의 순서를 바꾸더라도 마지막 먹는 시간은 더 짧아집니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"최적 부분 구조 증명\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"첫번째 도시락을 정하고 나면 나머지 도시락들을 배치해야합니다.\\n나머지 도시락들도 먹는데 걸리는 시간을 정하면 최적의 선택이 됩니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"10.4 문제: 문자열 합치기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"C언어의 큰 문제점 중 하나는 언어 차원에서 문자열 변수형을 지원하지 않습니다.\\nC에서는 문자 배열로 문자열을 표현하되 \\\\0으로 문자열 끝을 지정합니다.\\n이래서는 문자열의 길을 쉽게 알기 힘듭니다.\\n이런 문제 중 하나로 문자열을 조작하는 함수들의 동작 시간이 불필요하게 커집니다.\\nstrcat() 같은 함수는 반복문을 통해 문자열의 길이 만큼 수행됩니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-c\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"strcat\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"char\"\n            }), \"* dest, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"const\"\n            }), \" \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"char\"\n            }), \"* src)\"]\n          }), \" {\\n \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// dest 의 마지막 위치를 찾는다\"\n          }), \"\\n \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"while\"\n          }), \"(*dest) ++dest;\\n \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// src 를 한 글자씩 dest 에 옮겨 붙인다\"\n          }), \"\\n \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"while\"\n          }), \"(*src) *(dest++) = *(src++);\\n \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 문자열의 끝을 알리는 \\\\0 을 추가한다\"\n          }), \"\\n *dest = \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이 함수를 이용해 n개의 문자열을 순서와 상관없이 합쳐서 하나로 만들려고합니다.\\n순서와 상관없다는 말은 al,go,spot 을 spotalgo 로 합치든 alspotgo도 됩니다.\\n그러나 문자열을 합치는 순서에 따라 전체 비용이 달라질 수 있습니다.\\n\", _jsx(_components.code, {\n          children: \"al\"\n        }), \" \", _jsx(_components.code, {\n          children: \"go\"\n        }), \"를 합치고 (2+2) spot을 합치면 (4+4), (4+8) = 12의 비용이 듭니다.\\n\", _jsx(_components.code, {\n          children: \"al\"\n        }), \" \", _jsx(_components.code, {\n          children: \"spot\"\n        }), \"을 합치고 (2+4) 이것을 go에 합치면 (6+2), (6+8) = 14의 비용이 듭니다.\\nn개의 문자열들의 길이가 주어질 때 필요한 최소 비용을 찾습니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"10.5 풀이: 문자열 합치기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 문제에 대한 직관을 얻는 좋은 방법은 문자열 합치는 과정을 그림으로 그립니다.\\n그리는 방법 중에 트리와 같은 형태로 문자열을 합치는 과정을 표현할 수 있습니다.\\n사각형은 각 단계마다 합친 결과로 원은 입력 문자열로 표현할 수 있습니다.\\n문자열을 합치는데 드는 비용은 결과 문자열의 길이와 같습니다.\\n따라서 총 비용은 사각형의 숫자들의 총합이 됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"탐욕적 알고리즘의 구상\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문자열을 병할할 때마다 병함되는 문자열들의 총 길이가 전체 비용에 더해집니다.\\n합쳐진 결과 문자열의 길이를 원래 입력에 주어졌던 문자열별로 나눌 수 있습니다.\\n한 문장열로 인해 발생하는 총 비용은 문자열의 길이와 병합되는 횟수의 곱입니다.\\n즉 문자열의 길이가 길수록 적게 병합되는 위치에 있어야합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"알고리즘 설계하기\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"탐욕적 알고리즘은 문제의 답을 여러 조각으로 나눠 조각마다 한가지 선택을 합니다.\\n이 문제에서는 한 조각마다 두 문자열을 합치는 선택을 합니다.\\n문자열 목록에서 두개를 고르고 이들을 합치고 다시 문자열 목록에 추가합니다.\\n문자열이 길면 길수록 병합 과정이 짧으면 유리하다는 점을 생각합니다.\\n항상 가장 짧은 두개를 먼저 병합하면 어떨까라고 생각해볼 수 있습니다.\\n이것이 최적해를 찾아낼 수 있을까요?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"정당성 증명\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"우선 탐욕적 선택 속성부터 증명해 보도록 하겠습니다.\\n탐욕적 알고리즘은 매 단계마다 가장 짧은 두 문자열을 합치는 것을 반복합니다.\\n증명을 위해서 기존처럼 귀류법을 통해 증명할 수 있습니다.\\n문제의 최적해가 가장 짧은 a와 b를 합친 경우가 아닐 때로 가정합니다.\\na와 b가 최초로 합쳐지는 문자열을 X라고 가정합니다.\\n문자열이 어느 순서로 합쳐지든 합쳐지는 순간의 길이는 일정합니다.\\n길이가 상관없다면 비용에서 차이가 나는 부분은 병합 횟수입니다.\\na와 처음 합쳐지는 문자열을 x라고 가정합니다.\\nx와 b를 바꾼다면 비용은 어떻게 달라질까요?\\n만약 a와 b의 병합까지의 횟수가 같다면 달라지지 않습니다.\\n하지만 둘의 거리가 다르다면 달라지게 됩니다.\\na가 b보다 거리가 멀다고 하면 b보다 비용이 큰 x가 더 적게 나오게 됩니다.\\n즉 바꿨을 때 비용은 더 줄어들 수 밖에 없습니다.\\n따라서 가장 작은 두 개를 합쳐나가는 게 가장 비용이 적습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"구현\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이렇게 만든 탐욕적 알고리즘은 문자열의 길이 목록을 유지해야합니다.\\n그러면서 최소길이를 골라내고 새 길이를 추가하는 과정을 거칩니다.\\n이와 같은 동작을 효율적으로 구현해주는 것이 우선순위 큐입니다.\\n우선순위 큐는 집합에서 가장 작은 원소를 찾고 추가하는 과정을 O(logn)에 합니다.\\nn이 작은 경우 어떤 자료구조를 사용해도 가능하기는 합니다.\\n전체 구현을 하면 문자열을 전부 돌아야 하므로 n번을 돌아야합니다.\\n전체 과정을 합치면 O(nlogn)의 수행시간을 가집니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"이론적 배경: 허프만 코드\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 문제는 사실 탐욕적 알고리즘으로 유명한 허프만 코드 알고리즘입니다.\\n허프만 코드는 가변 길이 인코딩 테이블을 만드는 방법입니다.\\n여러 압축 알고리즘에 종종 사용됩니다.\\n가변 길이 인코딩은 원문의 각 글자를 서로 길이가 다른 비트 패턴으로 바꿉니다.\\n이로써 원문의 길이를 줄일 수 있습니다.\\n자주 출현하는 글자는 더 짧은 패턴으로 줄이게 배당할 수 있습니다.\\n원문에 출현하는 글자들의 출현 빈도가 주어질때 예상길이를 최소화합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"10.6 문제: 미나스 아노르\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"도시 미나스 아노르에는 반지름이 8키로미터인 원형 성벽 람마스 에코르가 있습니다.\\n도시 전체를 감싸는 거대한 성벽에는 n개의 초소가 배치되어 있습니다.\\n각 초소들은 해당 위치를 중심으로 반지름 r의 원 내부를 감시합니다.\\n최소의 인원으로 성벽의 모든 부분을 감시하려 합니다.\\n성벽의 모든 부분을 감시하기 위해 필요한 최소한의 병사의 수를 계산합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"10.7 풀이: 미나스 아노르\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"기하 문제이면서 실수 좌표를 다루는 문제는 까다롭습니다.\\n기하 문제에는 수많은 예외들이 있고 실수 연산은 오류가 나기 쉽습니다.\\n다행히 이 문제에서는 입력에 주어지는 실수가 조금 달라져도 값이 같습니다.\\n그 뜻은 초소의 감시 범위의 끝이 경계에 정확히 일치하지 않느다는 의미입니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"중심각 구간으로 원을 덮는 문제\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"처음해야 할 일은 2차원 평뭔의 도형을 우리가 다루기 쉽게 변형합니다.\\n지금 주어진 것으로는 초소로 성벽 전체를 감시할 수 있나 알기도 어렵습니다.\\n각 초소에서 감시할 수 있는 성벽은 전체 중 일부분입니다.\\n초소가 감시할 수 있는 범위 중 성벽 부분을 호로 생각할 수 있습니다.\\n부채꼴 모양으로 생각했을 때 이 호 부분을 중심각 기준으로 생각할 수 있습니다.\\n원의 반지름은 이 호의 중앙에서 끝까지의 범위가 될 것입니다.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"문제-해결-전략-10"},"buildId":"GkZqC6CVl3oCvuLDsgDOS","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>