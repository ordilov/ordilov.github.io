<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/f30e95c4ef9a5ce6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f30e95c4ef9a5ce6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8560289fc67afa8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8560289fc67afa8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-10d16e51767f2eb7.js" defer=""></script><script src="/_next/static/chunks/132-c8ad25a4bdd62a00.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4c91ca1952ea948f.js" defer=""></script><script src="/_next/static/KYz5P89J7mv6UfMYwsAwY/_buildManifest.js" defer=""></script><script src="/_next/static/KYz5P89J7mv6UfMYwsAwY/_ssgManifest.js" defer=""></script><script src="/_next/static/KYz5P89J7mv6UfMYwsAwY/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Home_container__97eC3"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><article class="Post_container__qv178"><div class="Post_head__hU8yK"><h1 class="Post_title__MJ8Hr">문제 해결 전략 2</h1><div class="Post_meta__TGwfg"><img src="/profile.png" class="Post_avatar__KIFLy" alt="profile"/><div class="Post_profile__wwScp">ordilov /<!-- --> <!-- -->6/23/202</div></div></div><div style="--size:24pt" class="MDX_Heading__T63mn">문제 해결 개관</div>
<div style="--size:20pt" class="MDX_Heading__T63mn">2.1 도입</div>
<p class="MDX_Paragraph__xqVvo">무작정 알고리즘을 외우고 문제를 푼다고 실력이 쌓일까요?<br/>
<!-- -->추상적 개념은 단순 반복으로 향상하기 어려습니다.</p>
<p class="MDX_Paragraph__xqVvo">그래서 사람들은 주로 두 단계에서 머무릅니다.</p>
<ul>
<li>기계적으로 문제를 풀면서 감을 익히기</li>
<li>막연한 시도 반복</li>
</ul>
<p class="MDX_Paragraph__xqVvo">채를 휘둘러 공을 치는 것은 누구나 할 수 있습니다.<br/>
<!-- -->여러번 치다 보면 감을 잡을 수도 있습니다.<br/>
<!-- -->하지만 무작정 공을 여러 번 친다고 쉽게 늘지 않습니다.<br/>
<!-- -->실력을 늘리려면 휘두르는 과정을 나누고 개선해야 합니다.</p>
<p class="MDX_Paragraph__xqVvo">마찬가지로 좋은 문제 해결자는 생각을 해야합니다.<br/>
<!-- -->그리고 문제를 푸는 게 아닌 푸는 기술을 연마해야 합니다.</p>
<ul>
<li>자신이 어떤 방식으로 해결하는지 의식</li>
<li>어떤 부분을 개선할지 파악</li>
</ul>
<div style="--size:20pt" class="MDX_Heading__T63mn">2.2 문제 해결 과정</div>
<p class="MDX_Paragraph__xqVvo"><strong>파인만 알고리즘</strong></p>
<ol>
<li>칠판에 문제를 적는다.</li>
<li>골똘히 생각한다.</li>
<li>칠판에 답안을 적는다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo">단순하지만 배울 점이 있습니다.</p>
<ul>
<li>문제를 해결하기 위해 과정을 세분화</li>
<li>문제를 적으면서 문제를 읽고 이해하고 재정의</li>
</ul>
<div style="--size:18pt" class="MDX_Heading__T63mn">어떻게 문제를 풀 것인가</div>
<ol>
<li>문제를 읽고 이해한다.</li>
<li>문제를 익숙한 용어로 재정의한다.</li>
<li>어떻게 해결할지 계획을 세운다.</li>
<li>계획을 검증한다.</li>
<li>프로그램으로 구현한다.</li>
<li>어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo"><strong>1단계: 문제를 읽고 이해하기</strong></p>
<p class="MDX_Paragraph__xqVvo">문제를 꼼꼼히 읽고 제약 조건 제대로 이해합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>2단계: 재정의와 추상화</strong></p>
<p class="MDX_Paragraph__xqVvo">문제를 직관적으로 이해하기 위해 자신의 언어로 작성합니다.</p>
<p class="MDX_Paragraph__xqVvo">현실 세계의 복잡한 개념을 본질만 남기고 축약하는 추상화합니다.</p>
<p class="MDX_Paragraph__xqVvo">어떻게 추상화하느냐에 따라 문제의 난이도가 변동합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>3단계: 계획 세우기</strong></p>
<p class="MDX_Paragraph__xqVvo">알고리즘과 자료구조를 선택합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>4단계: 계획 검증하기</strong></p>
<p class="MDX_Paragraph__xqVvo">알고리즘이 요구조건 수행하는지 증명합니다.</p>
<p class="MDX_Paragraph__xqVvo">수행에 걸리는 시간과 메모리 제한 사항 충족 확인합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>5단계: 계획 수행하기</strong></p>
<p class="MDX_Paragraph__xqVvo">구현을 정확하고 효율적으로 작성합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>6단계: 회고하기</strong></p>
<p class="MDX_Paragraph__xqVvo">문제와 함께 자신의 경험 기록으로 남깁니다.</p>
<p class="MDX_Paragraph__xqVvo">해법과 어떤 방식으로 접근했고 찾는데 결정적이었던 깨달음 기록합니다.</p>
<p class="MDX_Paragraph__xqVvo">틀렸을 때는 어떤 실수를 했는지 기록합니다.</p>
<p class="MDX_Paragraph__xqVvo">다른 사람의 코드를 보고 통찰을 얻습니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>문제를 풀지 못할 때</strong></p>
<p class="MDX_Paragraph__xqVvo">시간 내에 풀어보고 못 풀면 다른 사람 코드 보는 것이 좋습니다.</p>
<p class="MDX_Paragraph__xqVvo">단 풀이를 참조할 때는 반드시 복기를 동반해야 합니다.</p>
<p class="MDX_Paragraph__xqVvo">왜 자신은 한 번에 이런 풀이가 안떠올랐나 고민해봅니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">2.3 문제 해결 전략</div>
<p class="MDX_Paragraph__xqVvo"><strong>직관과 체계적인 접근</strong></p>
<p class="MDX_Paragraph__xqVvo">중요한 것은 문제와 답의 구조에 대한 직관의 중요성입니다.<br/>
<!-- -->직관은 알고리즘이 어떤 형태일지 짐작하게 해줍니다.<br/>
<!-- -->직관의 발달을 위해선 경험을 쌓아 나가야 합니다.<br/>
<!-- -->막막한 경우 어떻게 체계적으로 아이디어를 접근해야 할까요?</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">비슷한 문제를 풀어본 적이 있는가?</div>
<p class="MDX_Paragraph__xqVvo">비슷한 문제를 통해 접근 방법 예측이 가능합니다.<br/>
<!-- -->발생 확률이나 경우의 수는 보통 동적 계획법으로 해결합니다.<br/>
<!-- -->가장 짧은 경로는 보통 최단 경로 문제로 해결합니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">단순한 방법에서 시작할 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">비슷한 문제가 떠오르지 않는다면 무엇부터 할까요?<br/>
<strong>&quot;무식하게 풀 수 있을까?&quot;</strong> 라는 질문으로 시작합니다.<br/>
<!-- -->시간과 공간 제약을 무시하고 가장 단순한 알고리즘 먼저 생각해봅니다.<br/>
<!-- -->이후 중복 제거와 효율적인 자료 구조 등 최적화로 해결할 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo"><em>이 방법으로 해결하지 못하면요?</em><br/>
<!-- -->알고리즘의 효율성 판단 기준으로 사용 가능합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>예제 문제</strong></p>
<div style="--size:24pt" class="MDX_Heading__T63mn"><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mo stretchy="false">(</mo><mi>N</mi><mo>&lt;</mo><mo>=</mo><mn>30</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">N(N &lt;= 30)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">30</span><span class="mclose">)</span></span></span></span></span></div>
<p class="MDX_Paragraph__xqVvo">개의 사탕을 세 명의 어린이에게 나눠줍니다.
사탕의 무게는 모두 20이하의 정수입니다.<br/>
<!-- -->사탕 무게가 가장 무거운 사람과 가벼운 사람의 최소 차이는 얼마일까요?</p>
<p class="MDX_Paragraph__xqVvo"><strong>가장 단순한 방법</strong></p>
<p class="MDX_Paragraph__xqVvo">각 사탕마다 어느 어린이에게 줄지 결정합니다.<br/>
<!-- -->3^N, 즉 최대 205조개의 방법을 만들어봅니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>중복 제거</strong></p>
<p class="MDX_Paragraph__xqVvo">받은 사탕이 달라도 무게가 같으면 답은 같습니다.<br/>
<!-- -->무게가 같으면 하나의 상태로 취급 가능합니다.<br/>
<!-- -->사탕 최대 무게가 20입니다.<br/>
<!-- -->각 어린이가 가진 사탕의 양는 0에서 20<em>N 사이가 됩니다.<br/>
<!-- -->각 상태를 저장하면 (20</em>N+1)^3, 즉 대략 2억이 필요합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>최적화</strong></p>
<p class="MDX_Paragraph__xqVvo">가장 많이 받은 아이와 적게 받은 아이 차이가 20이 넘는다면?<br/>
<!-- -->사탕의 최대 무게가 20이므로 하나를 주면 둘의 차이는 항상 감소합니다.<br/>
<!-- -->즉 원래보다 차이가 감소하므로 20이상은 답이될 수 없습니다.<br/>
<!-- -->따라서 (20*N)/3+20, 즉 대략 1000만을 넘는 경우는 무시해도 됩니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>정렬</strong></p>
<p class="MDX_Paragraph__xqVvo">세 어린이 중 누가 더 많이 받는지는 중요하지 않습니다.<br/>
<!-- -->서로 다른 세 수는 여섯 가지 방법으로 나열할 수 있습니다.<br/>
<!-- -->이것을 오름차순으로 정렬된 방법만 탐색해봅시다.<br/>
<!-- -->1/6만큼 줄어드므로 대략 200만개 이하를 탐색하게 됩니다.</p>
<p class="MDX_Paragraph__xqVvo">처음보다 대략 1억분의 1로 줄어들었습니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">내가 문제를 푸는 과정을 수식화할 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">물론 점진적인 접근 방식이 만능은 아닙니다.<br/>
<!-- -->완전히 새로운 방향에서 접근해야 풀리는 문제도 있습니다.<br/>
<!-- -->이때 시도 가능한 건 <strong>손으로</strong> 간단한 입력을 직접 해결해보는 것입니다.<br/>
<!-- -->해결한 과정을 공식화해서 답을 만드는 알고리즘이 흔히 있습니다.</p>
<p class="MDX_Paragraph__xqVvo"><em>이 방법으로 해결하지 못하면요?</em><br/>
<!-- -->풀이 시 어떤 점을 고려해야할 지 알게 됩니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">문제를 단순화할 수 없을까?</div>
<p class="MDX_Paragraph__xqVvo">문제를 좀 더 쉬운 변형판으로 먼저 풀어보는 방법입니다.</p>
<ul>
<li>제약 조건을 없애봅니다.</li>
<li>계산해야하는 변수의 수를 줄여봅니다.</li>
<li>다차원을 1차원을 줄여봅니다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">해결에 대한 직관을 제공할 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>예제 문제</strong></p>
<p class="MDX_Paragraph__xqVvo">2차원 격자에서 N개의 점이 있다고 합시다.<br/>
<!-- -->가로선 혹은 세로선으로만 움직일 수 있습니다.<br/>
<!-- -->따라서 두 점 사이의 거리는 x좌표와 y좌표의 합입니다.<br/>
<!-- -->N개의 점 사이의 거리의 합이 최소가 되는 새 점의 위치는 어딜까요?</p>
<p class="MDX_Paragraph__xqVvo"><strong>1차원 형태로 바꾸기</strong></p>
<p class="MDX_Paragraph__xqVvo">x좌표에서 왼쪽이 오른쪽보다 많다면 왼쪽으로 옮겨야합니다.<br/>
<!-- -->y좌표축과 무관하게 x좌표축에만 연관이 됩니다.<br/>
<!-- -->y좌표도 마찬가지로 축으로 사영한 결과와 같아 두 결과를 합하면 됩니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">그림으로 그려볼 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">사람은 숫자의 나열보다 기하학적 도형을 더 직관적으로 받아들입니다.</p>
<ul>
<li>정수쌍을 2차원 평면 상의 좌표로 그려봅니다.</li>
<li>직선상의 구간들로 그려봅니다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">기하학이 아니더라도 유용한 경우가 많습니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">수식으로 표현할 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">기존은 직관을 얻기 좋은 방향으로 사고를 전개하는 방식들입니다.<br/>
<!-- -->반대로 평문으로 쓰인 문제를 수식으로 표현하는 것이 도움이 될 수 있습니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">문제를 분해할 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">복잡한 조건 하나보다 단순한 조건 여러 개가 다루기 쉽습니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>예제 문제</strong>
400m 달리기 경주에 N명의 육상 선수가 참여합니다.<br/>
<!-- -->각 선수의 최고기록 best[], 최저기록 worst[]가 있습니다.<br/>
<!-- -->각 선수가 기존 기록 범위 내의 성적만 낼 수 있습니다.
기록을 기준으로 다음 형식의 M개의 신문기사가 나왔습니다.</p>
<ol>
<li>선수 i는 선수 j에게 반드시 패배한다.</li>
<li>선수 i와 선수 j가 서로에게 이길 가능성이 있다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo">이 신문 기사들에 오류가 있는지 확인합니다.<br/>
<!-- -->예를 들어 A가 B에게 항상 이기고 B가 C에게 항상 이깁니다.<br/>
<!-- -->그런데 A와 C가 서로에게 이길 가능성이 있는 건 오류입니다.</p>
<p class="MDX_Paragraph__xqVvo">문제 해결을 위해 형식의 오류를 수식으로 표현해봅니다.</p>
<ol>
<li>worst[j] &lt; best[i]</li>
<li>(best[j] &lt; worst[i]) &amp;&amp; (best[i] &lt; worst[j])</li>
</ol>
<p class="MDX_Paragraph__xqVvo">두 조건을 만족하는 식으로 변경되었습니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">뒤에서부터 생각해서 문제를 풀 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">문제에 내재된 순서를 바꿔봅니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">순서를 강제할 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">순서가 없는 문제에 순서를 강제해봅니다.<br/>
<!-- -->답에는 영향을 주지 않습니다.<br/>
<!-- -->하지만 순서를 지정하면서 제약으로 사고를 도와줍니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">특정 형태의 답만을 고려할 수 있을까?</div>
<p class="MDX_Paragraph__xqVvo">순서를 강제하는 기법의 연장선으로 <strong>정규화</strong>가 있습니다.<br/>
<strong>정규화</strong>는 형태가 달라도 결과적으로 같은 것들을 묶습니다.</p></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"문제 해결 전략 2","date":"2021-06-24 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"문제-해결-전략-2"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h1: \"h1\",\n      h2: \"h2\",\n      p: \"p\",\n      br: \"br\",\n      ul: \"ul\",\n      li: \"li\",\n      strong: \"strong\",\n      ol: \"ol\",\n      h3: \"h3\",\n      em: \"em\",\n      span: \"span\",\n      math: \"math\",\n      semantics: \"semantics\",\n      mrow: \"mrow\",\n      mi: \"mi\",\n      mo: \"mo\",\n      mn: \"mn\",\n      annotation: \"annotation\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h1, {\n        children: \"문제 해결 개관\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"2.1 도입\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"무작정 알고리즘을 외우고 문제를 푼다고 실력이 쌓일까요?\", _jsx(_components.br, {}), \"\\n\", \"추상적 개념은 단순 반복으로 향상하기 어려습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"그래서 사람들은 주로 두 단계에서 머무릅니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"기계적으로 문제를 풀면서 감을 익히기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"막연한 시도 반복\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"채를 휘둘러 공을 치는 것은 누구나 할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"여러번 치다 보면 감을 잡을 수도 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 무작정 공을 여러 번 친다고 쉽게 늘지 않습니다.\", _jsx(_components.br, {}), \"\\n\", \"실력을 늘리려면 휘두르는 과정을 나누고 개선해야 합니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"마찬가지로 좋은 문제 해결자는 생각을 해야합니다.\", _jsx(_components.br, {}), \"\\n\", \"그리고 문제를 푸는 게 아닌 푸는 기술을 연마해야 합니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"자신이 어떤 방식으로 해결하는지 의식\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"어떤 부분을 개선할지 파악\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"2.2 문제 해결 과정\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"파인만 알고리즘\"\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"칠판에 문제를 적는다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"골똘히 생각한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"칠판에 답안을 적는다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"단순하지만 배울 점이 있습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"문제를 해결하기 위해 과정을 세분화\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"문제를 적으면서 문제를 읽고 이해하고 재정의\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"어떻게 문제를 풀 것인가\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"문제를 읽고 이해한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"문제를 익숙한 용어로 재정의한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"어떻게 해결할지 계획을 세운다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"계획을 검증한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"프로그램으로 구현한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"1단계: 문제를 읽고 이해하기\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문제를 꼼꼼히 읽고 제약 조건 제대로 이해합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"2단계: 재정의와 추상화\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문제를 직관적으로 이해하기 위해 자신의 언어로 작성합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"현실 세계의 복잡한 개념을 본질만 남기고 축약하는 추상화합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"어떻게 추상화하느냐에 따라 문제의 난이도가 변동합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"3단계: 계획 세우기\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"알고리즘과 자료구조를 선택합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"4단계: 계획 검증하기\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"알고리즘이 요구조건 수행하는지 증명합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"수행에 걸리는 시간과 메모리 제한 사항 충족 확인합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"5단계: 계획 수행하기\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"구현을 정확하고 효율적으로 작성합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"6단계: 회고하기\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문제와 함께 자신의 경험 기록으로 남깁니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"해법과 어떤 방식으로 접근했고 찾는데 결정적이었던 깨달음 기록합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"틀렸을 때는 어떤 실수를 했는지 기록합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"다른 사람의 코드를 보고 통찰을 얻습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"문제를 풀지 못할 때\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"시간 내에 풀어보고 못 풀면 다른 사람 코드 보는 것이 좋습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"단 풀이를 참조할 때는 반드시 복기를 동반해야 합니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"왜 자신은 한 번에 이런 풀이가 안떠올랐나 고민해봅니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"2.3 문제 해결 전략\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"직관과 체계적인 접근\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"중요한 것은 문제와 답의 구조에 대한 직관의 중요성입니다.\", _jsx(_components.br, {}), \"\\n\", \"직관은 알고리즘이 어떤 형태일지 짐작하게 해줍니다.\", _jsx(_components.br, {}), \"\\n\", \"직관의 발달을 위해선 경험을 쌓아 나가야 합니다.\", _jsx(_components.br, {}), \"\\n\", \"막막한 경우 어떻게 체계적으로 아이디어를 접근해야 할까요?\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"비슷한 문제를 풀어본 적이 있는가?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"비슷한 문제를 통해 접근 방법 예측이 가능합니다.\", _jsx(_components.br, {}), \"\\n\", \"발생 확률이나 경우의 수는 보통 동적 계획법으로 해결합니다.\", _jsx(_components.br, {}), \"\\n\", \"가장 짧은 경로는 보통 최단 경로 문제로 해결합니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"단순한 방법에서 시작할 수 있을까?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"비슷한 문제가 떠오르지 않는다면 무엇부터 할까요?\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n          children: \"\\\"무식하게 풀 수 있을까?\\\"\"\n        }), \" 라는 질문으로 시작합니다.\", _jsx(_components.br, {}), \"\\n\", \"시간과 공간 제약을 무시하고 가장 단순한 알고리즘 먼저 생각해봅니다.\", _jsx(_components.br, {}), \"\\n\", \"이후 중복 제거와 효율적인 자료 구조 등 최적화로 해결할 수 있습니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.em, {\n          children: \"이 방법으로 해결하지 못하면요?\"\n        }), _jsx(_components.br, {}), \"\\n\", \"알고리즘의 효율성 판단 기준으로 사용 가능합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"예제 문제\"\n        })\n      }), \"\\n\", _jsx(_components.h1, {\n        children: _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"(\"\n                    }), _jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mo, {\n                      children: \"\u003c\"\n                    }), _jsx(_components.mo, {\n                      children: \"=\"\n                    }), _jsx(_components.mn, {\n                      children: \"30\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \")\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"N(N \u003c= 30)\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10903em\"\n                  },\n                  children: \"N\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"(\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10903em\"\n                  },\n                  children: \"N\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"\u003c=\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"30\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \")\"\n                })]\n              })]\n            })]\n          })\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"개의 사탕을 세 명의 어린이에게 나눠줍니다.\\n사탕의 무게는 모두 20이하의 정수입니다.\", _jsx(_components.br, {}), \"\\n\", \"사탕 무게가 가장 무거운 사람과 가벼운 사람의 최소 차이는 얼마일까요?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"가장 단순한 방법\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"각 사탕마다 어느 어린이에게 줄지 결정합니다.\", _jsx(_components.br, {}), \"\\n\", \"3^N, 즉 최대 205조개의 방법을 만들어봅니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"중복 제거\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"받은 사탕이 달라도 무게가 같으면 답은 같습니다.\", _jsx(_components.br, {}), \"\\n\", \"무게가 같으면 하나의 상태로 취급 가능합니다.\", _jsx(_components.br, {}), \"\\n\", \"사탕 최대 무게가 20입니다.\", _jsx(_components.br, {}), \"\\n\", \"각 어린이가 가진 사탕의 양는 0에서 20\", _jsxs(_components.em, {\n          children: [\"N 사이가 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"각 상태를 저장하면 (20\"]\n        }), \"N+1)^3, 즉 대략 2억이 필요합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"최적화\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"가장 많이 받은 아이와 적게 받은 아이 차이가 20이 넘는다면?\", _jsx(_components.br, {}), \"\\n\", \"사탕의 최대 무게가 20이므로 하나를 주면 둘의 차이는 항상 감소합니다.\", _jsx(_components.br, {}), \"\\n\", \"즉 원래보다 차이가 감소하므로 20이상은 답이될 수 없습니다.\", _jsx(_components.br, {}), \"\\n\", \"따라서 (20*N)/3+20, 즉 대략 1000만을 넘는 경우는 무시해도 됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"정렬\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"세 어린이 중 누가 더 많이 받는지는 중요하지 않습니다.\", _jsx(_components.br, {}), \"\\n\", \"서로 다른 세 수는 여섯 가지 방법으로 나열할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"이것을 오름차순으로 정렬된 방법만 탐색해봅시다.\", _jsx(_components.br, {}), \"\\n\", \"1/6만큼 줄어드므로 대략 200만개 이하를 탐색하게 됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"처음보다 대략 1억분의 1로 줄어들었습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"내가 문제를 푸는 과정을 수식화할 수 있을까?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"물론 점진적인 접근 방식이 만능은 아닙니다.\", _jsx(_components.br, {}), \"\\n\", \"완전히 새로운 방향에서 접근해야 풀리는 문제도 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"이때 시도 가능한 건 \", _jsx(_components.strong, {\n          children: \"손으로\"\n        }), \" 간단한 입력을 직접 해결해보는 것입니다.\", _jsx(_components.br, {}), \"\\n\", \"해결한 과정을 공식화해서 답을 만드는 알고리즘이 흔히 있습니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.em, {\n          children: \"이 방법으로 해결하지 못하면요?\"\n        }), _jsx(_components.br, {}), \"\\n\", \"풀이 시 어떤 점을 고려해야할 지 알게 됩니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"문제를 단순화할 수 없을까?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문제를 좀 더 쉬운 변형판으로 먼저 풀어보는 방법입니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"제약 조건을 없애봅니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"계산해야하는 변수의 수를 줄여봅니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"다차원을 1차원을 줄여봅니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"해결에 대한 직관을 제공할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"예제 문제\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"2차원 격자에서 N개의 점이 있다고 합시다.\", _jsx(_components.br, {}), \"\\n\", \"가로선 혹은 세로선으로만 움직일 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"따라서 두 점 사이의 거리는 x좌표와 y좌표의 합입니다.\", _jsx(_components.br, {}), \"\\n\", \"N개의 점 사이의 거리의 합이 최소가 되는 새 점의 위치는 어딜까요?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"1차원 형태로 바꾸기\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"x좌표에서 왼쪽이 오른쪽보다 많다면 왼쪽으로 옮겨야합니다.\", _jsx(_components.br, {}), \"\\n\", \"y좌표축과 무관하게 x좌표축에만 연관이 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"y좌표도 마찬가지로 축으로 사영한 결과와 같아 두 결과를 합하면 됩니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"그림으로 그려볼 수 있을까?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"사람은 숫자의 나열보다 기하학적 도형을 더 직관적으로 받아들입니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"정수쌍을 2차원 평면 상의 좌표로 그려봅니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"직선상의 구간들로 그려봅니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"기하학이 아니더라도 유용한 경우가 많습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"수식으로 표현할 수 있을까?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"기존은 직관을 얻기 좋은 방향으로 사고를 전개하는 방식들입니다.\", _jsx(_components.br, {}), \"\\n\", \"반대로 평문으로 쓰인 문제를 수식으로 표현하는 것이 도움이 될 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"문제를 분해할 수 있을까?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"복잡한 조건 하나보다 단순한 조건 여러 개가 다루기 쉽습니다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"예제 문제\"\n        }), \"\\n400m 달리기 경주에 N명의 육상 선수가 참여합니다.\", _jsx(_components.br, {}), \"\\n\", \"각 선수의 최고기록 best[], 최저기록 worst[]가 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"각 선수가 기존 기록 범위 내의 성적만 낼 수 있습니다.\\n기록을 기준으로 다음 형식의 M개의 신문기사가 나왔습니다.\"]\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"선수 i는 선수 j에게 반드시 패배한다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"선수 i와 선수 j가 서로에게 이길 가능성이 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이 신문 기사들에 오류가 있는지 확인합니다.\", _jsx(_components.br, {}), \"\\n\", \"예를 들어 A가 B에게 항상 이기고 B가 C에게 항상 이깁니다.\", _jsx(_components.br, {}), \"\\n\", \"그런데 A와 C가 서로에게 이길 가능성이 있는 건 오류입니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문제 해결을 위해 형식의 오류를 수식으로 표현해봅니다.\"\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"worst[j] \u003c best[i]\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"(best[j] \u003c worst[i]) \u0026\u0026 (best[i] \u003c worst[j])\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"두 조건을 만족하는 식으로 변경되었습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"뒤에서부터 생각해서 문제를 풀 수 있을까?\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문제에 내재된 순서를 바꿔봅니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"순서를 강제할 수 있을까?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"순서가 없는 문제에 순서를 강제해봅니다.\", _jsx(_components.br, {}), \"\\n\", \"답에는 영향을 주지 않습니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 순서를 지정하면서 제약으로 사고를 도와줍니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"특정 형태의 답만을 고려할 수 있을까?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"순서를 강제하는 기법의 연장선으로 \", _jsx(_components.strong, {\n          children: \"정규화\"\n        }), \"가 있습니다.\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n          children: \"정규화\"\n        }), \"는 형태가 달라도 결과적으로 같은 것들을 묶습니다.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"문제-해결-전략-2"},"buildId":"KYz5P89J7mv6UfMYwsAwY","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>