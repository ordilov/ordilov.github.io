---
layout: post
title:  "Stop the world"
date:   2022-01-05 00:45:00 +0900
category: java
tags: ["backend"]
keywords: ["backend"]
description: Java를 사용할 때 유의해야할 Stop the World를 알아봅니다.
---

## Garbage Collector
Java는 메모리를 직접 해제하지 않고 Garbage Collector가 처리합니다.  
프로그램이 실행 되는 동안 객체를 생성하기만 한다면 메모리가 가득차게 됩니다.  
이때 실제로 사용하지 않는 데이터들을 GC가 메모리를 해제합니다.  
사용하지 않는 데이터의 기준은 참조되지 않고 있는 객체들입니다.  
어떻게 참조되지 않는 값들이 생길 수 있을까요?

### 메모리 영역
먼저 우리가 직접 접근 하는 변수들은 Stack 영역에 위치합니다.  
그리고 그 변수들은 객체에 대한 참조값을 나타냅니다.  
실제로 객체에 대한 정보는 Heap 영역에 생성되고 Stack에서 이 값을 참조합니다.  
즉 참조값으로 다른 Heap 영역을 가리키게 되면 Heap 영역에 생성된 메모리는 접근할 수 없습니다.  
이렇게 사용자가 접근할 수 없지만 Heap 영역에 차지하는 부분을 GC가 처리합니다.  
GC에서 메모리를 해제하고 나면 그만큼 메모리를 더 사용할 수 있게 됩니다.

## Stop the world
자동으로 메모리를 처리해주므로 편해보이지만 문제는 "Stop the world"가 발생합니다.  
영어 그대로 GC를 처리하는 동안 프로그램이 정지하게 됩니다.  
GC를 처리하는 쓰레드를 제외한 모든 쓰레드가 정지하게 됩니다.  
예를 들어 서버라고 하면 이렇게 멈춘 시간에 요청이 들어오면 처리하지 못하게 됩니다.  
그래서 이런 GC 처리 시간을 줄이는 것이 중요합니다.  

### 왜 GC 처리 중엔 멈추게 되는 걸까?
알고리즘마다 다르지만 GC가 처리되는 과정은 크게 2단계입니다.  
먼저 참조되지 않는 객체들을 찾습니다.  
그리고 참조되지 않는 메모리들을 해제합니다.  
GC중에 멈추는 이유는 메모리를 해제할 때 객체들의 위치도 변경합니다.  
단순히 참조되지 않는 메모리들을 해제만 한다면 다른 쓰레드를 멈출 필요가 없습니다.  
하지만 메모리를 해제만 하면 사용할 수 있는 메모리가 파편처럼 분포됩니다.  
이런 부분에 객체를 만들다보면 또 금방 파편 부분에 생성하지 못해 GC가 필요합니다.  
따라서 사용할 수 있는 객체가 차지하는 메모리와 여유 메모리 부분을 정리하는 작업을 합니다.  
이 과정에서 메모리 위치를 옮기고 객체에서 참조하는 위치를 변경합니다.  
만약 GC 중에 다른 쓰레드에서 메모리 위치를 옮기는 중에 객체를 사용하면 에러가 발생하게 됩니다.  
잘못된 위치를 참조하는 Dangling Pointer로 어떤 에러가 발생할지 모릅니다.  
이런 점을 방지하기 위해 다른 쓰레드를 모두 멈추고 GC 쓰레드만 동작합니다.  



