<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/eb02e362203cb1e5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/eb02e362203cb1e5.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8560289fc67afa8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8560289fc67afa8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-10d16e51767f2eb7.js" defer=""></script><script src="/_next/static/chunks/132-c8ad25a4bdd62a00.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4c91ca1952ea948f.js" defer=""></script><script src="/_next/static/zBeAlRJbI2EqZSyFRw0h1/_buildManifest.js" defer=""></script><script src="/_next/static/zBeAlRJbI2EqZSyFRw0h1/_ssgManifest.js" defer=""></script><script src="/_next/static/zBeAlRJbI2EqZSyFRw0h1/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Home_container__97eC3"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><article class="Post_container__qv178"><div class="Post_head__hU8yK"><h1 class="Post_title__MJ8Hr">오브젝트 (2)</h1><div class="Post_meta__TGwfg"><img src="/profile.png" class="Post_avatar__KIFLy" alt="profile"/><div class="Post_profile__wwScp">ordilov /<!-- --> <!-- -->3/20/202</div></div></div><div style="--size:20pt" class="MDX_Heading__T63mn">객체지향 프로그래밍을 향해</div>
<p class="MDX_Paragraph__xqVvo">객체지향은 말 그대로 객체를 지향하는 것으로 클래스를 먼저 고민하는 게 아닌 객체를 먼저 생각해야 합니다.
객체를 고민하고 클래스로 상태와 행동을 공유하는 객체들을 추상화합니다.
즉 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 합니다.
객체를 중심으로 두었을 때 설계는 단순하고 깔끔해집니다.
객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 합니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">도메인의 구조를 따르는 프로그램 구조</div>
<p class="MDX_Paragraph__xqVvo">도메인은 어떤 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 의미합니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">자율적인 객체</div>
<p class="MDX_Paragraph__xqVvo">객체는 상태와 행동을 함께 가지는 복합적인 존재이자, 스스로 판단하고 행동하는 자율적인 존재입니다.
데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 합니다.
그리고 캡슐화를 지원하기 위해 접근 제어와 접근 수정자를 제공합니다.
자율적인 존재가 되기 위해서는 외부의 간섭을 최소화해야합니다.
외부가 어떤 상태인지, 어떤 생각인지 알아서는 안되고 결정에 직접적으로 개입하려고 해서는 안됩니다.</p>
<p class="MDX_Paragraph__xqVvo">외부에서 접근 가능한 부분으로 퍼블릭 인터페이스라고 부르고 외부에서 접근 불가능한 부분은 구현이라고 부릅니다.
내부에 구현한 부분은 외부에서 변경할 수 없기 때문에 구현 은닉이라고 부릅니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">협력</div>
<p class="MDX_Paragraph__xqVvo">객체는 다른 객체의 인터페이스를 통해 요청합니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">상속</div>
<p class="MDX_Paragraph__xqVvo">상속은 코드를 재사용하기 위해 널리 사용됩니다.
하지만 두 가지 관점에서 설계에 안좋은 영향을 미칩니다.
하나는 상속이 캡슐화를 위반하고, 하나는 설계를 유연하지 못하게 만듭니다.
먼저 상속을 이용하기 위해서는 부모 클래스의 내부 클래스를 잘 알고 있어야 합니다.
결과적으로 부모 클래스의 구현은 자식 클래스에게 노출되어 캡슐화가 약화됩니다.</p>
<p class="MDX_Paragraph__xqVvo">두 번째 단점은 설계가 유연하지 않다는 것으로 실행 시점에 객체를 바꿀 수 없습니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">합성</div>
<p class="MDX_Paragraph__xqVvo">합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용합니다.
합성은 상속이 가지는 두 가지 문제점을 모두 해결합니다.</p></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"오브젝트 (2)","date":"2022-03-21 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"type":"archive","id":"오브젝트 2"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"객체지향 프로그래밍을 향해\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체지향은 말 그대로 객체를 지향하는 것으로 클래스를 먼저 고민하는 게 아닌 객체를 먼저 생각해야 합니다.\\n객체를 고민하고 클래스로 상태와 행동을 공유하는 객체들을 추상화합니다.\\n즉 클래스의 윤곽을 잡기 위해서는 어떤 객체들이 어떤 상태와 행동을 가지는지를 먼저 결정해야 합니다.\\n객체를 중심으로 두었을 때 설계는 단순하고 깔끔해집니다.\\n객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야 합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"도메인의 구조를 따르는 프로그램 구조\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"도메인은 어떤 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 의미합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"자율적인 객체\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체는 상태와 행동을 함께 가지는 복합적인 존재이자, 스스로 판단하고 행동하는 자율적인 존재입니다.\\n데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 합니다.\\n그리고 캡슐화를 지원하기 위해 접근 제어와 접근 수정자를 제공합니다.\\n자율적인 존재가 되기 위해서는 외부의 간섭을 최소화해야합니다.\\n외부가 어떤 상태인지, 어떤 생각인지 알아서는 안되고 결정에 직접적으로 개입하려고 해서는 안됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"외부에서 접근 가능한 부분으로 퍼블릭 인터페이스라고 부르고 외부에서 접근 불가능한 부분은 구현이라고 부릅니다.\\n내부에 구현한 부분은 외부에서 변경할 수 없기 때문에 구현 은닉이라고 부릅니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"협력\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"객체는 다른 객체의 인터페이스를 통해 요청합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"상속\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"상속은 코드를 재사용하기 위해 널리 사용됩니다.\\n하지만 두 가지 관점에서 설계에 안좋은 영향을 미칩니다.\\n하나는 상속이 캡슐화를 위반하고, 하나는 설계를 유연하지 못하게 만듭니다.\\n먼저 상속을 이용하기 위해서는 부모 클래스의 내부 클래스를 잘 알고 있어야 합니다.\\n결과적으로 부모 클래스의 구현은 자식 클래스에게 노출되어 캡슐화가 약화됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"두 번째 단점은 설계가 유연하지 않다는 것으로 실행 시점에 객체를 바꿀 수 없습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"합성\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"합성은 인터페이스에 정의된 메시지를 통해서만 코드를 재사용합니다.\\n합성은 상속이 가지는 두 가지 문제점을 모두 해결합니다.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"오브젝트 2"},"buildId":"zBeAlRJbI2EqZSyFRw0h1","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>