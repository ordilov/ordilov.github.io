<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/765fb4fbab0b233a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/765fb4fbab0b233a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1afd36a183130af5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1afd36a183130af5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-46629148a08166c1.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-7c59f9808c8355a5.js" defer=""></script><script src="/_next/static/5HqQ5iNmHyZXeVF046j4X/_buildManifest.js" defer=""></script><script src="/_next/static/5HqQ5iNmHyZXeVF046j4X/_ssgManifest.js" defer=""></script><script src="/_next/static/5HqQ5iNmHyZXeVF046j4X/_middlewareManifest.js" defer=""></script><style id="__jsx-2786876435">a.jsx-2786876435{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
[aria-current].jsx-2786876435:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-3340924647">a.jsx-3340924647{display:block;
margin-left:20px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:120px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
[aria-current].jsx-3340924647:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-3b70050e699e9af6">aside.jsx-3b70050e699e9af6{position:absolute;
right:0;
width:200px;
height:100%}
nav.jsx-3b70050e699e9af6{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
@media (max-width:1080px) {aside.jsx-3b70050e699e9af6{visibility:hidden}}</style><style id="__jsx-18f58d3410611438">article.jsx-18f58d3410611438{display:block;
margin:0 auto;
padding:0 1rem}
@media (max-width:800px) {aside.jsx-18f58d3410611438{position:static;
height:auto}}</style><style id="__jsx-76612a042023d019">footer.jsx-76612a042023d019{background-color:#1e1e1e;
padding:20px;
text-align:center}</style><style id="__jsx-853d05b23ef572e2">.container.jsx-853d05b23ef572e2{position:relative;
padding:0 2rem}
@media (min-width:900px) {.container.jsx-853d05b23ef572e2{position:relative;
max-width:1080px;
padding:0 2rem;
margin-left:auto;
margin-right:auto}}</style></head><body><div id="__next" data-reactroot=""><div class="jsx-853d05b23ef572e2 container"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><div class="jsx-18f58d3410611438"><aside class="jsx-3b70050e699e9af6"><nav class="jsx-3b70050e699e9af6"><a href="#Object Class" class="jsx-2786876435"> <!-- -->Object Class</a><a href="#@IntrinsicCandidate" class="jsx-3340924647"> <!-- -->@IntrinsicCandidate</a><a href="#생성자" class="jsx-2786876435"> <!-- -->생성자</a><a href="#getClass" class="jsx-2786876435"> <!-- -->getClass</a><a href="#hashCode" class="jsx-2786876435"> <!-- -->hashCode</a><a href="#equals" class="jsx-2786876435"> <!-- -->equals</a><a href="#clone" class="jsx-2786876435"> <!-- -->clone</a><a href="#toString" class="jsx-2786876435"> <!-- -->toString</a><a href="#finalize" class="jsx-2786876435"> <!-- -->finalize</a><a href="#notify" class="jsx-2786876435"> <!-- -->notify</a><a href="#notifyAll" class="jsx-2786876435"> <!-- -->notifyAll</a><a href="#wait" class="jsx-2786876435"> <!-- -->wait</a><a href="#notify와 wait" class="jsx-3340924647"> <!-- -->notify와 wait</a></nav></aside><article class="jsx-18f58d3410611438 Post_container__qv178"><div class="jsx-18f58d3410611438 Post_head__hU8yK"><h1 class="jsx-18f58d3410611438 Post_title__MJ8Hr">Java Object Class</h1><div class="jsx-18f58d3410611438 Post_meta__TGwfg"><img src="/profile.png" alt="profile" class="jsx-18f58d3410611438 Post_avatar__KIFLy"/><div class="jsx-18f58d3410611438 Post_profile__wwScp">ordilov /<!-- --> <!-- -->2022. 4. 30</div></div></div><div id="Object Class"><h2>Object Class</h2> </div>
<p class="MDX_Paragraph__xqVvo">Java의 Object Class를 구현 부분을 간단하게 살펴보겠습니다.</p>
<div id="@IntrinsicCandidate"><h3>@IntrinsicCandidate</h3> </div>
<p class="MDX_Paragraph__xqVvo">Object 구현 코드를 살펴보면 내부 구현 없이 <code>@IntrinsicCandidate</code> 어노테이션이 명시된 부분이 많습니다.
이 어노테이션은 자바에서 구현이 JVM 상에서 해주는 부분을 명시합니다.
Intrinsic 뜻 자체가 &#x27;고유&#x27; 라는 뜻을 가지다 보니 기본적으로 제공되는 기능으로 생각해도 됩니다.
이렇게 명시된 코드들의 특징은 구현 부분이 컴파일러나 인터프리터에 의해 변경될 수 있습니다.
이렇게 제공되었을 때 장점은 2가지입니다.</p>
<ul>
<li>하드웨어와 가까운 더 낮은 레벨의 코드로 구현될 수 있다.</li>
<li>그대로 사용하지만 버전에 따라 구현을 변경할 수 있다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">더 낮은 레벨의 코드를 사용하는 경우, 성능이 더 뛰어나거나, 자바 코드 상에서는 불가능한 구현들을 가능하게 합니다.</p>
<div id="생성자"><h2>생성자</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-meta">@IntrinsicCandidate</span>
<span class="hljs-keyword">public</span> <span class="hljs-title function_">Object</span><span class="hljs-params">()</span> {}
</code></pre>
<p class="MDX_Paragraph__xqVvo">생성자도 마찬가지로 JVM 내부에서 구현되어 있습니다.</p>
<div id="getClass"><h2>getClass</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-meta">@IntrinsicCandidate</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass();
</code></pre>
<p class="MDX_Paragraph__xqVvo">말 그대로 클래스 정보를 가져오는데 주의할 점은 선언한 변수 클래스가 아니라 생성한 클래스 정보를 가져옵니다.</p>
<pre><code class="hljs language-java"><span class="hljs-type">Animal</span> <span class="hljs-variable">animal</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>();
<span class="hljs-type">Class</span> <span class="hljs-variable">animalClass</span> <span class="hljs-operator">=</span> animal.getClass();
</code></pre>
<p class="MDX_Paragraph__xqVvo">예를 들어 Animal을 상속받은 Dog 클래스가 있다고 할 때, Animal 클래스로 선언한 변수에서 getClass()를 하더라도 Dog 클래스 정보를 불러옵니다.
그 결과 실제 구현 클래스 정보를 불러오고 싶을 때 따로 캐스팅이 필요 없습니다.</p>
<p class="MDX_Paragraph__xqVvo"><code>native</code> 키워드는 JNI(Java Native Interface)로 구현된 것을 나타내는 키워드로 운영체제와 더 가까운 c나 c++ 같은 언어로 구현된 코드와 매칭됩니다.</p>
<div id="hashCode"><h2>hashCode</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-meta">@IntrinsicCandidate</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;
</code></pre>
<p class="MDX_Paragraph__xqVvo">기본 해시코드도 <code>@IntrinsicCandiate</code>로 구현되어 있습니다.
따라서 JVM 종류에 따라 구현이 달라지게 되고 <code>native</code> 키워드도 있기 때문에 자바 언어로 구현되어 있지 않다는 걸 알 수 있습니다.
OpenJDK 8 기준으로 어떤 식으로 구현되는지 간단하게 살펴보겠습니다.</p>
<ol>
<li>OS 랜덤 값</li>
<li>오브젝트 메모리 주소 변환 값</li>
<li>1</li>
<li>증가하는 연속된 값</li>
<li>오브젝트 메모리 주소를 int 로 캐스팅</li>
<li>xorshift 랜덤 값</li>
</ol>
<p class="MDX_Paragraph__xqVvo">각 방법마다 장단점이 있지만 기본적으로 사용하는 방법은 5번입니다.
이는 다음에 나올 <code>equals()</code> 의 구현과도 연관이 있는데 Object의 <code>equals()</code>는 참조값을 기준으로 같은 객체인지 비교합니다.
따라서 <code>hashCode()</code> 도 기본 구현은 참조값을 기준으로 생성합니다.</p>
<p class="MDX_Paragraph__xqVvo">hashCode()는 2가지 규칙을 지켜야 합니다.</p>
<ul>
<li>내부 값을 변경하지 않는한 실행 중에 항상 일관된 값을 반환합니다.</li>
<li><code>equals()</code>가 참인 경우 같은 값을 반환합니다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo"><code>hashCode()</code>가 같더라도 <code>equals()</code>가 참이 아닐 수는 있지만 해시 테이블 성능을 생각했을 때 최대한 다른 객체면 다른 해시코드를 반환하는 것이 좋습니다.</p>
<div id="equals"><h2>equals</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> {
    <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);
}
</code></pre>
<p class="MDX_Paragraph__xqVvo"><code>hashCode()</code>를 설명하면서 간단하게 나왔지만 기본은 참조값을 비교합니다.
<code>equals()</code> 는 null이 아닐 때 5가지 규칙을 지켜야 합니다.</p>
<ul>
<li>자기 자신을 비교할 때 참을 반환합니다.</li>
<li>대칭적으로 a.equals(b) 라면 b.equals(a)도 참이여야 합니다.</li>
<li>전파적으로 (a,b), (b,c) 가 같다면 (a, c)도 같아야 합니다.</li>
<li>여러번 반복해도 일관된 결과를 반환해야 합니다.</li>
<li>null과 비교할 때 거짓을 반환해야 합니다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">Override하는 경우 앞서 설명한 hashCode와 함께 override를 해야합니다.</p>
<div id="clone"><h2>clone</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-meta">@IntrinsicCandidate</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException;
</code></pre>
<p class="MDX_Paragraph__xqVvo">clone 은 객체에 대한 얕은 복사를 하는 함수입니다.
깊은 복사가 필요하고 내부에 참조하는 다른 객체가 있다면 override해서 참조하는 객체도 새로 생성해줄 필요가 있습니다.</p>
<p class="MDX_Paragraph__xqVvo">clone의 반환값은 3가지 규칙을 만족해야 합니다.</p>
<ul>
<li>원본 참조값 == clone 참조값</li>
<li>원본.getClass() == clone.getClass()</li>
<li>원본.equals() == clone.equals()</li>
</ul>
<div id="toString"><h2>toString</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> {
    <span class="hljs-keyword">return</span> getClass().getName() + <span class="hljs-string">&quot;@&quot;</span> + Integer.toHexString(hashCode());
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">문자열로 출력할 때 사용되며 기본은 클래스 이름과 참조값이 출력됩니다.</p>
<div id="finalize"><h2>finalize</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-meta">@Deprecated(since=&quot;9&quot;)</span>
<span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable { }
</code></pre>
<p class="MDX_Paragraph__xqVvo">finalize는 객체가 더 이상 사용되지 않는 것을 직접 명시해서 가비지컬렉터를 부르게 되는데 deprecated 되었듯이 성능상의 이슈가 있을 수 있어 더 이상 사용되지 않습니다.</p>
<div id="notify"><h2>notify</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-meta">@IntrinsicCandidate</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span>;
</code></pre>
<p class="MDX_Paragraph__xqVvo">객체가 모니터 중이고 대기 중인 임의의 쓰레드 하나를 사용가능하게 합니다.
다만 <code>notify()</code>를 한다고 바로 다른 쓰레드가 실행되는게 아니라 <code>notify()</code>를 호출한 메소드가 완료되거나 <code>wait()</code>처럼 lock을 포기할 때 사용가능합니다.
객체가 소유중인지 모니터 중이려면 세 가지 방법중 하나를 택해야 합니다.</p>
<ul>
<li>synchronized 메소드를 실행할 때</li>
<li>synchronzied static 메소드를 실행할 때</li>
<li>synchronized body 선언 부분일 때</li>
</ul>
<div id="notifyAll"><h2>notifyAll</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-meta">@IntrinsicCandidate</span>
<span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span>;
</code></pre>
<p class="MDX_Paragraph__xqVvo"><code>notifyAll()</code>도 <code>notify()</code>와 마찬가지로 대기중인 다른 쓰레드를 사용 가능하게 하는데 차이점은 임의의 쓰레드 하나가 아닌 전부 사용 가능하게 됩니다.</p>
<div id="wait"><h2>wait</h2> </div>
<pre><code class="hljs language-java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeoutMillis)</span> <span class="hljs-keyword">throws</span> InterruptedException;
</code></pre>
<p class="MDX_Paragraph__xqVvo">쓰레드를 대기중인 상태로 변경하는 메소드입니다. 대기중에서 사용가능한 상태로 바뀌려면 notify 되거나, interrupt 되거나 지정한 timeout 시간이 지나야 합니다.</p>
<div id="notify와 wait"><h3>notify와 wait</h3> </div>
<p class="MDX_Paragraph__xqVvo">다른 부분들은 모든 객체에서 사용하는 부분이지만 notify와 wait은 멀티 쓰레드 작업을 할 때만 사용됩니다.
Object 클래스가 아닌 Thread 클래스에 있어도 될 것 같지만 Object 클래스에 위치한 이유가 있습니다.</p>
<p class="MDX_Paragraph__xqVvo">자바에서 쓰레드가 어떤 객체에 접근해서 작업하려고 할 때 사용중인지 모니터링 하는 역할을 객체가 담당합니다.
객체에 접근 중인 쓰레드가 더 이상 없어 사용 가능한 상태인 걸 판단하는 것도 객체에서 하게 됩니다.
따라서 쓰레드를 대기하거나 사용 가능하게 하는 메소드가 Object 클래스에 위치하게 됩니다.</p></article></div><footer class="jsx-76612a042023d019"></footer></div><footer class="jsx-76612a042023d019"></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"layout":"post","title":"Java Object Class","date":"2022-05-01 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Java Object Class"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      h3: \"h3\",\n      code: \"code\",\n      ul: \"ul\",\n      li: \"li\",\n      pre: \"pre\",\n      span: \"span\",\n      ol: \"ol\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"Object Class\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Java의 Object Class를 구현 부분을 간단하게 살펴보겠습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"@IntrinsicCandidate\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Object 구현 코드를 살펴보면 내부 구현 없이 \", _jsx(_components.code, {\n          children: \"@IntrinsicCandidate\"\n        }), \" 어노테이션이 명시된 부분이 많습니다.\\n이 어노테이션은 자바에서 구현이 JVM 상에서 해주는 부분을 명시합니다.\\nIntrinsic 뜻 자체가 '고유' 라는 뜻을 가지다 보니 기본적으로 제공되는 기능으로 생각해도 됩니다.\\n이렇게 명시된 코드들의 특징은 구현 부분이 컴파일러나 인터프리터에 의해 변경될 수 있습니다.\\n이렇게 제공되었을 때 장점은 2가지입니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"하드웨어와 가까운 더 낮은 레벨의 코드로 구현될 수 있다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"그대로 사용하지만 버전에 따라 구현을 변경할 수 있다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"더 낮은 레벨의 코드를 사용하는 경우, 성능이 더 뛰어나거나, 자바 코드 상에서는 불가능한 구현들을 가능하게 합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"생성자\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@IntrinsicCandidate\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"Object\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" {}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"생성자도 마찬가지로 JVM 내부에서 구현되어 있습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"getClass\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@IntrinsicCandidate\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"native\"\n          }), \" Class\u003c?\u003e getClass();\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"말 그대로 클래스 정보를 가져오는데 주의할 점은 선언한 변수 클래스가 아니라 생성한 클래스 정보를 가져옵니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Animal\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"animal\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title class_\",\n            children: \"Dog\"\n          }), \"();\\n\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"Class\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"animalClass\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" animal.getClass();\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"예를 들어 Animal을 상속받은 Dog 클래스가 있다고 할 때, Animal 클래스로 선언한 변수에서 getClass()를 하더라도 Dog 클래스 정보를 불러옵니다.\\n그 결과 실제 구현 클래스 정보를 불러오고 싶을 때 따로 캐스팅이 필요 없습니다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"native\"\n        }), \" 키워드는 JNI(Java Native Interface)로 구현된 것을 나타내는 키워드로 운영체제와 더 가까운 c나 c++ 같은 언어로 구현된 코드와 매칭됩니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"hashCode\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@IntrinsicCandidate\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"native\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"hashCode\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \";\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"기본 해시코드도 \", _jsx(_components.code, {\n          children: \"@IntrinsicCandiate\"\n        }), \"로 구현되어 있습니다.\\n따라서 JVM 종류에 따라 구현이 달라지게 되고 \", _jsx(_components.code, {\n          children: \"native\"\n        }), \" 키워드도 있기 때문에 자바 언어로 구현되어 있지 않다는 걸 알 수 있습니다.\\nOpenJDK 8 기준으로 어떤 식으로 구현되는지 간단하게 살펴보겠습니다.\"]\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"OS 랜덤 값\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"오브젝트 메모리 주소 변환 값\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"1\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"증가하는 연속된 값\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"오브젝트 메모리 주소를 int 로 캐스팅\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"xorshift 랜덤 값\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"각 방법마다 장단점이 있지만 기본적으로 사용하는 방법은 5번입니다.\\n이는 다음에 나올 \", _jsx(_components.code, {\n          children: \"equals()\"\n        }), \" 의 구현과도 연관이 있는데 Object의 \", _jsx(_components.code, {\n          children: \"equals()\"\n        }), \"는 참조값을 기준으로 같은 객체인지 비교합니다.\\n따라서 \", _jsx(_components.code, {\n          children: \"hashCode()\"\n        }), \" 도 기본 구현은 참조값을 기준으로 생성합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"hashCode()는 2가지 규칙을 지켜야 합니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"내부 값을 변경하지 않는한 실행 중에 항상 일관된 값을 반환합니다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"equals()\"\n          }), \"가 참인 경우 같은 값을 반환합니다.\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"hashCode()\"\n        }), \"가 같더라도 \", _jsx(_components.code, {\n          children: \"equals()\"\n        }), \"가 참이 아닐 수는 있지만 해시 테이블 성능을 생각했을 때 최대한 다른 객체면 다른 해시코드를 반환하는 것이 좋습니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"equals\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"boolean\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"equals\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(Object obj)\"\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \" == obj);\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"hashCode()\"\n        }), \"를 설명하면서 간단하게 나왔지만 기본은 참조값을 비교합니다.\\n\", _jsx(_components.code, {\n          children: \"equals()\"\n        }), \" 는 null이 아닐 때 5가지 규칙을 지켜야 합니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"자기 자신을 비교할 때 참을 반환합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"대칭적으로 a.equals(b) 라면 b.equals(a)도 참이여야 합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"전파적으로 (a,b), (b,c) 가 같다면 (a, c)도 같아야 합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"여러번 반복해도 일관된 결과를 반환해야 합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"null과 비교할 때 거짓을 반환해야 합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Override하는 경우 앞서 설명한 hashCode와 함께 override를 해야합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"clone\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@IntrinsicCandidate\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"protected\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"native\"\n          }), \" Object \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"clone\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"throws\"\n          }), \" CloneNotSupportedException;\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"clone 은 객체에 대한 얕은 복사를 하는 함수입니다.\\n깊은 복사가 필요하고 내부에 참조하는 다른 객체가 있다면 override해서 참조하는 객체도 새로 생성해줄 필요가 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"clone의 반환값은 3가지 규칙을 만족해야 합니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"원본 참조값 == clone 참조값\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"원본.getClass() == clone.getClass()\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"원본.equals() == clone.equals()\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"toString\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" String \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"toString\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" getClass().getName() + \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"@\\\"\"\n          }), \" + Integer.toHexString(hashCode());\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문자열로 출력할 때 사용되며 기본은 클래스 이름과 참조값이 출력됩니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"finalize\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Deprecated(since=\\\"9\\\")\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"protected\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"finalize\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"throws\"\n          }), \" Throwable { }\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"finalize는 객체가 더 이상 사용되지 않는 것을 직접 명시해서 가비지컬렉터를 부르게 되는데 deprecated 되었듯이 성능상의 이슈가 있을 수 있어 더 이상 사용되지 않습니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"notify\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@IntrinsicCandidate\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"native\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"notify\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \";\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"객체가 모니터 중이고 대기 중인 임의의 쓰레드 하나를 사용가능하게 합니다.\\n다만 \", _jsx(_components.code, {\n          children: \"notify()\"\n        }), \"를 한다고 바로 다른 쓰레드가 실행되는게 아니라 \", _jsx(_components.code, {\n          children: \"notify()\"\n        }), \"를 호출한 메소드가 완료되거나 \", _jsx(_components.code, {\n          children: \"wait()\"\n        }), \"처럼 lock을 포기할 때 사용가능합니다.\\n객체가 소유중인지 모니터 중이려면 세 가지 방법중 하나를 택해야 합니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"synchronized 메소드를 실행할 때\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"synchronzied static 메소드를 실행할 때\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"synchronized body 선언 부분일 때\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"notifyAll\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@IntrinsicCandidate\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"native\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"notifyAll\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \";\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"notifyAll()\"\n        }), \"도 \", _jsx(_components.code, {\n          children: \"notify()\"\n        }), \"와 마찬가지로 대기중인 다른 쓰레드를 사용 가능하게 하는데 차이점은 임의의 쓰레드 하나가 아닌 전부 사용 가능하게 됩니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"wait\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"native\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"wait\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"long\"\n            }), \" timeoutMillis)\"]\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"throws\"\n          }), \" InterruptedException;\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"쓰레드를 대기중인 상태로 변경하는 메소드입니다. 대기중에서 사용가능한 상태로 바뀌려면 notify 되거나, interrupt 되거나 지정한 timeout 시간이 지나야 합니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"notify와 wait\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"다른 부분들은 모든 객체에서 사용하는 부분이지만 notify와 wait은 멀티 쓰레드 작업을 할 때만 사용됩니다.\\nObject 클래스가 아닌 Thread 클래스에 있어도 될 것 같지만 Object 클래스에 위치한 이유가 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"자바에서 쓰레드가 어떤 객체에 접근해서 작업하려고 할 때 사용중인지 모니터링 하는 역할을 객체가 담당합니다.\\n객체에 접근 중인 쓰레드가 더 이상 없어 사용 가능한 상태인 걸 판단하는 것도 객체에서 하게 됩니다.\\n따라서 쓰레드를 대기하거나 사용 가능하게 하는 메소드가 Object 클래스에 위치하게 됩니다.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"Java Object Class"},"buildId":"5HqQ5iNmHyZXeVF046j4X","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>