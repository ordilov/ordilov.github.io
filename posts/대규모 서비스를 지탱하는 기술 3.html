<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/765fb4fbab0b233a.css" as="style"/><link rel="stylesheet" href="/_next/static/css/765fb4fbab0b233a.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1afd36a183130af5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1afd36a183130af5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-46629148a08166c1.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-d73c76ad2f51cae7.js" defer=""></script><script src="/_next/static/O35WQ2kU3GhLgRQbUWKAF/_buildManifest.js" defer=""></script><script src="/_next/static/O35WQ2kU3GhLgRQbUWKAF/_ssgManifest.js" defer=""></script><script src="/_next/static/O35WQ2kU3GhLgRQbUWKAF/_middlewareManifest.js" defer=""></script><style id="__jsx-2786876435">a.jsx-2786876435{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
[aria-current].jsx-2786876435:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-3340924647">a.jsx-3340924647{display:block;
margin-left:20px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:120px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
[aria-current].jsx-3340924647:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-3b70050e699e9af6">aside.jsx-3b70050e699e9af6{position:absolute;
right:0;
width:200px;
height:100%}
nav.jsx-3b70050e699e9af6{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
@media (max-width:1080px) {aside.jsx-3b70050e699e9af6{visibility:hidden}}</style><style id="__jsx-18f58d3410611438">article.jsx-18f58d3410611438{display:block;
margin:0 auto;
padding:0 1rem}
@media (max-width:800px) {aside.jsx-18f58d3410611438{position:static;
height:auto}}</style><style id="__jsx-76612a042023d019">footer.jsx-76612a042023d019{background-color:#1e1e1e;
padding:20px;
text-align:center}</style><style id="__jsx-853d05b23ef572e2">.container.jsx-853d05b23ef572e2{position:relative;
padding:0 2rem}
@media (min-width:900px) {.container.jsx-853d05b23ef572e2{position:relative;
max-width:1080px;
padding:0 2rem;
margin-left:auto;
margin-right:auto}}</style></head><body><div id="__next" data-reactroot=""><div class="jsx-853d05b23ef572e2 container"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><div class="jsx-18f58d3410611438"><aside class="jsx-3b70050e699e9af6"><nav class="jsx-3b70050e699e9af6"><a href="#용도 특화형 인덱스" class="jsx-2786876435"> <!-- -->용도 특화형 인덱스</a><a href="#이론과 실전 양쪽과의 싸움" class="jsx-2786876435"> <!-- -->이론과 실전 양쪽과의 싸움</a><a href="#정수열이 기록된 CSV를 바이너리로 해서 컴팩트하게 가져가기" class="jsx-2786876435"> <!-- -->정수열이 기록된 CSV를 바이너리로 해서 컴팩트하게 가져가기</a><a href="#VB Code와 속도 감각" class="jsx-2786876435"> <!-- -->VB Code와 속도 감각</a><a href="#압축의 기초" class="jsx-3340924647"> <!-- -->압축의 기초</a><a href="#대상이 정수인 경우" class="jsx-3340924647"> <!-- -->대상이 정수인 경우</a></nav></aside><article class="jsx-18f58d3410611438 Post_container__qv178"><div class="jsx-18f58d3410611438 Post_head__hU8yK"><h1 class="jsx-18f58d3410611438 Post_title__MJ8Hr">대규모 서비스를 지탱하는 기술 (5 ~ 6)</h1><div class="jsx-18f58d3410611438 Post_meta__TGwfg"><img src="/profile.png" alt="profile" class="jsx-18f58d3410611438 Post_avatar__KIFLy"/><div class="jsx-18f58d3410611438 Post_profile__wwScp">ordilov /<!-- --> <!-- -->2022. 3. 16</div></div></div><div style="--size:24pt" class="MDX_Heading__T63mn">대규모 데이터 처리 실전 입문</div>
<p class="MDX_Paragraph__xqVvo">데이터가 대량으로 있더라도 국소성을 발견하고 그에 맞게 구성을 변경해서 속도를 높여왔습니다.
하지만 전문 검색이나, 유사문서, 데이터마이닝의 경우 광범위한 데이터에 액세스해야 합니다.
데이터의 어느 부분만 절단할 수 없을 때 어떻게 해야 할까요?</p>
<div id="용도 특화형 인덱스"><h2>용도 특화형 인덱스</h2> </div>
<p class="MDX_Paragraph__xqVvo">이런 경우 대부분 RDBMS로는 한계가 있기에 배치처리로 RDBMS에서 별도로 인덱스 서버를 만듭니다.
웹 어플리케이션 서버에서 인덱스 서버에 RPC등으로 접근하는 방법을 사용합니다.
RPC(Remote Procedure Call)는 웹 API와 비슷하게 네트워크로 함수를 호출해 값을 받습니다.</p>
<p class="MDX_Paragraph__xqVvo">RDBMS를 사용하면 데이터를 정렬하거나, 통계처리, JOIN등을 범용적으로 만들 수 있습니다.
하지만 뭔가 특정한 목적으로 사용하는 경우 특정 목적 튜닝 데이터 구조를 사용하면 압도적으로 빠릅니다.
이럴 때 용도 특화형 인덱스를 사요하면 자연어 처리나 검색등을 더 빠르게 처리할 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo">문자열 키워드를 처리하기 위해선 Trie 기받느이 정규표현등을 이용해서 다양한 알고리즘과 데이터 구조로 사전에 만들어둡니다.
카테고리 자동 분류의 경우에도 기계학습이나 알고리즘이 추가로 필요합니다.
전문 검색엔징의 경우 어떤 문서를 상위로 가져올지 스코어링 처리가 필요합니다.
이 같은 기능은 특정 칼럼으로만 정렬되는 RDBMS에서는 무리로 다른 검색 인덱스가 필요합니다.</p>
<div id="이론과 실전 양쪽과의 싸움"><h2>이론과 실전 양쪽과의 싸움</h2> </div>
<p class="MDX_Paragraph__xqVvo">많은 것들이 고전적인 이론으로 해결할 수 있는 반면에 실전적인 노하우로 해결하는 경우도 있습니다.
RDBMS의 JOIN을 사용하지 않는 것은 RDB를 본질적인 개념을 부정하는 것 아닌가 할 수 있습니다.
하지만 분할을 위해서 실전적인 방법으로 처리할 수 있기에 균형을 맞추는 것이 필요합니다.
이론을 너무 추구하다면 구현할 때 여러 단점들이 나오게 되고, 실전만 추구하면 어려운 문제를 마주쳤을 때 해결법을 모릅니다.
즉 잔재주로 작은 문제는 해결할 수 있지만 큰 문제가 되갈수록 고전적인 이론이 더 필요해집니다.
예를 들어 키워드 링크의 경우 Trie로 Common Prefix Search 알고리즘을 적용시켜야할 때 알고리즘을 모르면 해결하기 힘듭니다.
이럴 때 알고리즘과 데이터 구조를 알고 있고, 이런 구조로 해결가능한지 알아야 문제를 마주쳤을 때 해결가능한지 파악할 수 있습니다.</p>
<div style="--size:24pt" class="MDX_Heading__T63mn">압축 프로그래밍</div>
<div id="정수열이 기록된 CSV를 바이너리로 해서 컴팩트하게 가져가기"><h2>정수열이 기록된 CSV를 바이너리로 해서 컴팩트하게 가져가기</h2> </div>
<p class="MDX_Paragraph__xqVvo">단순히 바이너리로 변환하는 게 아니라 부호화를 연구해서 크기를 절반 이하로 하는 것이 과제입니다.
큰 데이터를 압축해서 컴팩트하게 만들면 디스크 I/O를 줄일 수 있습니다.
RDBMS에서도 정수를 적당히 작은 크기로 줄이듯이 말이죠.
여기서 신경써야 할 부분은 데이터형의 크기, 바이너리의 크기, 스크립트 언어가 갖는 데이터 크기의 오버헤드입니다.</p>
<div id="VB Code와 속도 감각"><h2>VB Code와 속도 감각</h2> </div>
<p class="MDX_Paragraph__xqVvo">VB Code(Variable Byte Code, 가변길이 바이트 부호)는 정수열을 압축하는 알고리즘입니다.
VB Code는 구현에서 간단하고 속도가 빨라 손쉽게 사용할 수 있습니다.
컴퓨터에서 바이너리 부호는 5를 0...0101로 표현하듯이 고정길이의 비트로 부호화합니다.
VB Code도 이처럼 정수를 부호화하는데 앞부분의 안쓰이는 바이트를 제외하고 최소한의 바이트로 표현합니다.
첫 1비트는 플래그로 남은 7비트로 바이너리 부호를 표현합니다.
5라면 10000101이 되고 130이라면 00000001 10000010이 됩니다.
첫 비트가 1이 아니라면 다음 바이트가 있다는 것으로 해석하면 됩니다.
이렇게 압축하면 고정 4바이트로 표현하던 바이트가 각각 1바이트, 2바이트로 표현할 수 있습니다.
값이 적으면 적을 수록 적은 바이트로 정수를 표현할 수 있는 것이 VB Code입니다.</p>
<p class="MDX_Paragraph__xqVvo">이런 값들을 정렬된 상태에서 더 압축할 수 있습니다.
[3, 5, 20] 이런 식이라면 그 사이의 차이를 이용해 [3, 2, 15]로 차로 값을 표현할 수 있습니다.
복원할 때는 처음부터 값을 생성해서 더해가면 원래 값으로 복원이 가능합니다.
값의 차이를 이용하면 원래 크기보다 더 작은 값들이 만들어져 압축률이 더 높아집니다.</p>
<div id="압축의 기초"><h3>압축의 기초</h3> </div>
<p class="MDX_Paragraph__xqVvo">압축의 기초는 출현빈도를 보고 빈번하게 출현하는 기호에 더 짧은 기호를, 그렇지 않은 기호에 긴 부호를 부여합니다.
모스 신호도 영어에서 자주 사용하는 기호는 짧고, 자주 사용하지 않는 문자는 긴 부호가 할당되어 있습니다.
모든 기호에 같은 길이의 부호를 부여하는 게 아니라 출현빈도에 따라 부여할 때 압축효과가 올라갑니다.</p>
<div id="대상이 정수인 경우"><h3>대상이 정수인 경우</h3> </div>
<p class="MDX_Paragraph__xqVvo">문자 기호인 경우 허프만 부호등을 이용해 확률 분포에 최적인 부호를 생성합니다.
하지만 이번 과제처럼 정수인 경우 문자 자체에 의미가 없기 때문에 차이를 이용하는 등 값을 변형해서 압축이 가능합니다.</p></article></div><footer class="jsx-76612a042023d019"></footer></div><footer class="jsx-76612a042023d019"></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"대규모 서비스를 지탱하는 기술 (5 ~ 6)","date":"2022-03-17 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"대규모 서비스를 지탱하는 기술 3"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h1: \"h1\",\n      p: \"p\",\n      h2: \"h2\",\n      h3: \"h3\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h1, {\n        children: \"대규모 데이터 처리 실전 입문\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"데이터가 대량으로 있더라도 국소성을 발견하고 그에 맞게 구성을 변경해서 속도를 높여왔습니다.\\n하지만 전문 검색이나, 유사문서, 데이터마이닝의 경우 광범위한 데이터에 액세스해야 합니다.\\n데이터의 어느 부분만 절단할 수 없을 때 어떻게 해야 할까요?\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"용도 특화형 인덱스\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 경우 대부분 RDBMS로는 한계가 있기에 배치처리로 RDBMS에서 별도로 인덱스 서버를 만듭니다.\\n웹 어플리케이션 서버에서 인덱스 서버에 RPC등으로 접근하는 방법을 사용합니다.\\nRPC(Remote Procedure Call)는 웹 API와 비슷하게 네트워크로 함수를 호출해 값을 받습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"RDBMS를 사용하면 데이터를 정렬하거나, 통계처리, JOIN등을 범용적으로 만들 수 있습니다.\\n하지만 뭔가 특정한 목적으로 사용하는 경우 특정 목적 튜닝 데이터 구조를 사용하면 압도적으로 빠릅니다.\\n이럴 때 용도 특화형 인덱스를 사요하면 자연어 처리나 검색등을 더 빠르게 처리할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문자열 키워드를 처리하기 위해선 Trie 기받느이 정규표현등을 이용해서 다양한 알고리즘과 데이터 구조로 사전에 만들어둡니다.\\n카테고리 자동 분류의 경우에도 기계학습이나 알고리즘이 추가로 필요합니다.\\n전문 검색엔징의 경우 어떤 문서를 상위로 가져올지 스코어링 처리가 필요합니다.\\n이 같은 기능은 특정 칼럼으로만 정렬되는 RDBMS에서는 무리로 다른 검색 인덱스가 필요합니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"이론과 실전 양쪽과의 싸움\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"많은 것들이 고전적인 이론으로 해결할 수 있는 반면에 실전적인 노하우로 해결하는 경우도 있습니다.\\nRDBMS의 JOIN을 사용하지 않는 것은 RDB를 본질적인 개념을 부정하는 것 아닌가 할 수 있습니다.\\n하지만 분할을 위해서 실전적인 방법으로 처리할 수 있기에 균형을 맞추는 것이 필요합니다.\\n이론을 너무 추구하다면 구현할 때 여러 단점들이 나오게 되고, 실전만 추구하면 어려운 문제를 마주쳤을 때 해결법을 모릅니다.\\n즉 잔재주로 작은 문제는 해결할 수 있지만 큰 문제가 되갈수록 고전적인 이론이 더 필요해집니다.\\n예를 들어 키워드 링크의 경우 Trie로 Common Prefix Search 알고리즘을 적용시켜야할 때 알고리즘을 모르면 해결하기 힘듭니다.\\n이럴 때 알고리즘과 데이터 구조를 알고 있고, 이런 구조로 해결가능한지 알아야 문제를 마주쳤을 때 해결가능한지 파악할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: \"압축 프로그래밍\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"정수열이 기록된 CSV를 바이너리로 해서 컴팩트하게 가져가기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"단순히 바이너리로 변환하는 게 아니라 부호화를 연구해서 크기를 절반 이하로 하는 것이 과제입니다.\\n큰 데이터를 압축해서 컴팩트하게 만들면 디스크 I/O를 줄일 수 있습니다.\\nRDBMS에서도 정수를 적당히 작은 크기로 줄이듯이 말이죠.\\n여기서 신경써야 할 부분은 데이터형의 크기, 바이너리의 크기, 스크립트 언어가 갖는 데이터 크기의 오버헤드입니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"VB Code와 속도 감각\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"VB Code(Variable Byte Code, 가변길이 바이트 부호)는 정수열을 압축하는 알고리즘입니다.\\nVB Code는 구현에서 간단하고 속도가 빨라 손쉽게 사용할 수 있습니다.\\n컴퓨터에서 바이너리 부호는 5를 0...0101로 표현하듯이 고정길이의 비트로 부호화합니다.\\nVB Code도 이처럼 정수를 부호화하는데 앞부분의 안쓰이는 바이트를 제외하고 최소한의 바이트로 표현합니다.\\n첫 1비트는 플래그로 남은 7비트로 바이너리 부호를 표현합니다.\\n5라면 10000101이 되고 130이라면 00000001 10000010이 됩니다.\\n첫 비트가 1이 아니라면 다음 바이트가 있다는 것으로 해석하면 됩니다.\\n이렇게 압축하면 고정 4바이트로 표현하던 바이트가 각각 1바이트, 2바이트로 표현할 수 있습니다.\\n값이 적으면 적을 수록 적은 바이트로 정수를 표현할 수 있는 것이 VB Code입니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 값들을 정렬된 상태에서 더 압축할 수 있습니다.\\n[3, 5, 20] 이런 식이라면 그 사이의 차이를 이용해 [3, 2, 15]로 차로 값을 표현할 수 있습니다.\\n복원할 때는 처음부터 값을 생성해서 더해가면 원래 값으로 복원이 가능합니다.\\n값의 차이를 이용하면 원래 크기보다 더 작은 값들이 만들어져 압축률이 더 높아집니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"압축의 기초\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"압축의 기초는 출현빈도를 보고 빈번하게 출현하는 기호에 더 짧은 기호를, 그렇지 않은 기호에 긴 부호를 부여합니다.\\n모스 신호도 영어에서 자주 사용하는 기호는 짧고, 자주 사용하지 않는 문자는 긴 부호가 할당되어 있습니다.\\n모든 기호에 같은 길이의 부호를 부여하는 게 아니라 출현빈도에 따라 부여할 때 압축효과가 올라갑니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"대상이 정수인 경우\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"문자 기호인 경우 허프만 부호등을 이용해 확률 분포에 최적인 부호를 생성합니다.\\n하지만 이번 과제처럼 정수인 경우 문자 자체에 의미가 없기 때문에 차이를 이용하는 등 값을 변형해서 압축이 가능합니다.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"대규모 서비스를 지탱하는 기술 3"},"buildId":"O35WQ2kU3GhLgRQbUWKAF","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>