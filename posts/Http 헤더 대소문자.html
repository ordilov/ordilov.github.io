<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/f30e95c4ef9a5ce6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f30e95c4ef9a5ce6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8560289fc67afa8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8560289fc67afa8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-10d16e51767f2eb7.js" defer=""></script><script src="/_next/static/chunks/132-c8ad25a4bdd62a00.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4c91ca1952ea948f.js" defer=""></script><script src="/_next/static/CaGXczCsqtBXlXFz7xKwu/_buildManifest.js" defer=""></script><script src="/_next/static/CaGXczCsqtBXlXFz7xKwu/_ssgManifest.js" defer=""></script><script src="/_next/static/CaGXczCsqtBXlXFz7xKwu/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Home_container__97eC3"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><article class="Post_container__qv178"><div class="Post_head__hU8yK"><h1 class="Post_title__MJ8Hr">Http 헤더 대소문자 구분</h1><div class="Post_meta__TGwfg"><img src="/profile.png" class="Post_avatar__KIFLy" alt="profile"/><div class="Post_profile__wwScp">ordilov /<!-- --> <!-- -->2/14/202</div></div></div><div style="--size:20pt" class="MDX_Heading__T63mn">대소문자 구분?</div>
<p class="MDX_Paragraph__xqVvo">정답은 Name는 구분하지 않고 Value는 상관 없습니다.
<a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2">RFC 2616</a>에 명시된 내용에 따르면 헤더는 &quot;:&quot; 를 기준으로 name과 value로 구성되어 있습니다.
그리고 name은 대소문자를 구분하지 않는다고 명시되어 있습니다.</p>
<hr/>
<p class="MDX_Paragraph__xqVvo">당연한 내용일 수도 있지만 몰랐던 사실을 알게 된건 Httpheaders를 사용하면서였습니다.
Java에서 기본으로 제공하는 HttpHeaders는 기본 생성자가 private으로 인자를 넣어준 생성자만 접근가능합니다.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> java.net.http.HttpHeaders
...

<span class="hljs-keyword">private</span> <span class="hljs-title hljs-function">HttpHeaders</span><span class="hljs-params">()</span>{
...
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">그렇지만 Spring에서 제공하는 HttpHeaders는 기본 생성자를 사용할 수 있습니다.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">import</span> org.springframework.http.HttpHeaders;
...

<span class="hljs-keyword">public</span> <span class="hljs-title hljs-function">HttpHeaders</span><span class="hljs-params">()</span> {
  <span class="hljs-built_in">this</span>(CollectionUtils.toMultiValueMap(<span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">LinkedCaseInsensitiveMap</span>&lt;&gt;(<span class="hljs-number">8</span>, Locale.ENGLISH)));
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">LinkedCaseInsensitiveMap은 이름에서 보듯이 대소문자를 구분하지 않는 Map입니다.</p>
<pre><code class="hljs language-java">map.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);
map.put(<span class="hljs-string">&quot;Name&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);

System.out.println(map.get(<span class="hljs-string">&quot;name&quot;</span>));      <span class="hljs-comment">// 결과는 value2</span>
</code></pre>
<p class="MDX_Paragraph__xqVvo">이런 자료구조를 사용하는 걸 봤을 때 http 헤더의 키는 대소문자를 구분하지 않는다고 예상할 수 있었습니다.</p></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"layout":"post","title":"Http 헤더 대소문자 구분","date":"2022-02-15 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Http 헤더 대소문자"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      a: \"a\",\n      hr: \"hr\",\n      pre: \"pre\",\n      code: \"code\",\n      span: \"span\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"대소문자 구분?\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"정답은 Name는 구분하지 않고 Value는 상관 없습니다.\\n\", _jsx(_components.a, {\n          href: \"https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\",\n          children: \"RFC 2616\"\n        }), \"에 명시된 내용에 따르면 헤더는 \\\":\\\" 를 기준으로 name과 value로 구성되어 있습니다.\\n그리고 name은 대소문자를 구분하지 않는다고 명시되어 있습니다.\"]\n      }), \"\\n\", _jsx(_components.hr, {}), \"\\n\", _jsx(_components.p, {\n        children: \"당연한 내용일 수도 있지만 몰랐던 사실을 알게 된건 Httpheaders를 사용하면서였습니다.\\nJava에서 기본으로 제공하는 HttpHeaders는 기본 생성자가 private으로 인자를 넣어준 생성자만 접근가능합니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"import\"\n          }), \" java.net.http.HttpHeaders\\n...\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"HttpHeaders\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \"{\\n...\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"그렇지만 Spring에서 제공하는 HttpHeaders는 기본 생성자를 사용할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"import\"\n          }), \" org.springframework.http.HttpHeaders;\\n...\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"HttpHeaders\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" {\\n  \", _jsx(_components.span, {\n            className: \"hljs-built_in\",\n            children: \"this\"\n          }), \"(CollectionUtils.toMultiValueMap(\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"LinkedCaseInsensitiveMap\"\n          }), \"\u003c\u003e(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"8\"\n          }), \", Locale.ENGLISH)));\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"LinkedCaseInsensitiveMap은 이름에서 보듯이 대소문자를 구분하지 않는 Map입니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [\"map.put(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"name\\\"\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"value1\\\"\"\n          }), \");\\nmap.put(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"Name\\\"\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"value2\\\"\"\n          }), \");\\n\\nSystem.out.println(map.get(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"name\\\"\"\n          }), \"));      \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 결과는 value2\"\n          }), \"\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이런 자료구조를 사용하는 걸 봤을 때 http 헤더의 키는 대소문자를 구분하지 않는다고 예상할 수 있었습니다.\"\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"Http 헤더 대소문자"},"buildId":"CaGXczCsqtBXlXFz7xKwu","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>