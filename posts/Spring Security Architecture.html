<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/c0a70d45961d3915.css" as="style"/><link rel="stylesheet" href="/_next/static/css/c0a70d45961d3915.css" data-n-g=""/><link rel="preload" href="/_next/static/css/1afd36a183130af5.css" as="style"/><link rel="stylesheet" href="/_next/static/css/1afd36a183130af5.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-2e51481b1d484a05.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-46629148a08166c1.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-35233866829f951d.js" defer=""></script><script src="/_next/static/MWAHttpm_JJE2ebIzAafd/_buildManifest.js" defer=""></script><script src="/_next/static/MWAHttpm_JJE2ebIzAafd/_ssgManifest.js" defer=""></script><script src="/_next/static/MWAHttpm_JJE2ebIzAafd/_middlewareManifest.js" defer=""></script><style id="__jsx-ee3704506c3da47c">aside.jsx-ee3704506c3da47c{position:absolute;
right:0;
width:200px;
height:100%}
nav.jsx-ee3704506c3da47c{top:200px;
margin:0 0 0 40px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
a.jsx-ee3704506c3da47c{display:block;
padding:10px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc}
@media (max-width:1080px) {aside.jsx-ee3704506c3da47c{visibility:hidden}}</style><style id="__jsx-18f58d3410611438">article.jsx-18f58d3410611438{display:block;
margin:0 auto;
padding:0 1rem}
@media (max-width:800px) {aside.jsx-18f58d3410611438{position:static;
height:auto}}</style><style id="__jsx-76612a042023d019">footer.jsx-76612a042023d019{background-color:#1e1e1e;
padding:20px;
text-align:center}</style><style id="__jsx-853d05b23ef572e2">.container.jsx-853d05b23ef572e2{position:relative;
padding:0 2rem}
@media (min-width:900px) {.container.jsx-853d05b23ef572e2{position:relative;
max-width:1080px;
padding:0 2rem;
margin-left:auto;
margin-right:auto}}</style></head><body><div id="__next" data-reactroot=""><div class="jsx-853d05b23ef572e2 container"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><div class="jsx-18f58d3410611438"><aside class="jsx-ee3704506c3da47c"><nav class="jsx-ee3704506c3da47c"><a href="#Security" class="jsx-ee3704506c3da47c">Security</a><a href="#Web Security" class="jsx-ee3704506c3da47c">Web Security</a><a href="#Security Filters" class="jsx-ee3704506c3da47c">Security Filters</a><a href="#Handling Security Exceptions" class="jsx-ee3704506c3da47c">Handling Security Exceptions</a></nav></aside><article class="jsx-18f58d3410611438 Post_container__qv178"><div class="jsx-18f58d3410611438 Post_head__hU8yK"><h1 class="jsx-18f58d3410611438 Post_title__MJ8Hr">Spring Security Architecture</h1><div class="jsx-18f58d3410611438 Post_meta__TGwfg"><img src="/profile.png" alt="profile" class="jsx-18f58d3410611438 Post_avatar__KIFLy"/><div class="jsx-18f58d3410611438 Post_profile__wwScp">ordilov /<!-- --> <!-- -->2022. 2. 2</div></div></div><div id="Security"><h2>Security</h2> </div>
<p class="MDX_Paragraph__xqVvo">애플리케이션에서 보안은 인증과 권한 두 가지 문제로 구분됩니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">Authentication</div>
<p class="MDX_Paragraph__xqVvo">인증을 위한 주요 전략은 인증 메서드 하나면 됩니다.<br/>
<!-- -->authenticate 메서드라고 한다면 예상되는 결과는 세 가지 중 하나입니다.</p>
<ul>
<li>인증을 성공했습니다 -&gt; 인증 주체 정보 + 인증 성공 정보</li>
<li>인증을 실패했습니다 -&gt; 인증 실패 예외 처리</li>
<li>인증을 결정할 수 없습니다 -&gt; 인증 정보 null</li>
</ul>
<p class="MDX_Paragraph__xqVvo">인증 실패의 경우 401 응답과 예외 처리 정보를 보낼 수 있습니다.<br/>
<!-- -->인증 결정을 못한 경우 이어지는 다음 인증 처리로 넘기거나 예외처리할 수 있습니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">Authorization</div>
<p class="MDX_Paragraph__xqVvo">권한은 인증이 성공한 이후에 이뤄지며 인증 정보를 가지고 권한을 판단합니다.<br/>
<!-- -->나온 결과로 ROLE_ADMIN, ROLE_AUDIT 처럼 보통 ROLE_ 로 권한을 구분합니다.</p>
<div id="Web Security"><h2>Web Security</h2> </div>
<p class="MDX_Paragraph__xqVvo">클라이언트에서 받아서 Servlet까지 가는 과정동안 Filters를 거치게 됩니다.<br/>
<!-- -->Filter가 연쇄적으로 구성된 FilterChain으로 HttpServletRequest가 처리됩니다.
Filter가 할 수 있는 일은 두 가지입니다.</p>
<ul>
<li>다음으로 처리될 Filter나 Servlet 처리를 막습니다. 바로 응답으로 넘어갑니다.</li>
<li>다음으로 처리될 Filter나 Servlet에 사용될 요청이나 응답을 수정합니다.</li>
</ul>
<div style="--size:18pt" class="MDX_Heading__T63mn">DelegatingFilterProxy</div>
<p class="MDX_Paragraph__xqVvo">DelegatingFilterProxy로 구현된 Filter는 스프링 ApplicationContext 상에서 서블릿 컨테이너 생명주기에 맞게 사용할 수 있습니다.<br/>
<!-- -->다시 말하면 서블릿 컨테이너는 아무 Filter나 사용 가능하지만, 스프링에 정의된 빈인 것을 신경쓰지 않습니다.
DelegatingFilterProxy를 사용하면 서블릿 컨테이너에 필터를 직접 등록하는 대신 스프링 빈이 대신합니다.
서블릿 컨테이너가 실행되기 이전에 필터들이 등록되어야 하는데 Proxy로 처리된 필터들이 등록됩니다.
따라서 Context에 등록된 빈들을 불러오기 이전에 컨테이너에 필터를 등록하는 작업을 할 수 있습니다.</p>
<div style="--size:18pt" class="MDX_Heading__T63mn">FilterChainProxy &amp; SecurityFilterChain</div>
<p class="MDX_Paragraph__xqVvo">Filter를 구현해서 사용할 때 하나의 필터가 아닌 여러개를 FilterChainProxy로 등록이 가능합니다.
이런 필터들을 SecurityFilterChain이라고 합니다.<br/>
<!-- -->하나의 필터를 여러개로 대체하는 이유는 상황이나 경로에 따라 여러 조건을 추가할 수 있습니다.<br/>
<!-- -->api를 처리할 때, view를 처리할 때등 경로에 따라 다른 필터를 적용시킬 수 있습니다.</p>
<div id="Security Filters"><h2>Security Filters</h2> </div>
<p class="MDX_Paragraph__xqVvo">Security Filter들은 순서에 따라 진행됩니다. 따라서 순차적인 처리가 필요하다면 대표적인 필터의 처리 순서를 알고 있는 것이 좋습니다.</p>
<ul>
<li>CorsFilter</li>
<li>CsrfFilter</li>
<li>LogOutFilter</li>
<li>OAuth2AuthorizationRequestRedirectFilter</li>
<li>BearerTokenAuthenticationFilter</li>
</ul>
<div id="Handling Security Exceptions"><h2>Handling Security Exceptions</h2> </div>
<p class="MDX_Paragraph__xqVvo"><code>ExceptionTranslationFilter</code>에선 <code>AccessDeniedException</code>이나 <code>AuthenticationException</code>을 응답으로 바꿀 수 있습니다.
필터에서 인증되지 않은 상태거나 <code>AuthenticationException</code> 이라면 다음 과정을 거칩니다.</p>
<ul>
<li>SecurityContextHolder를 비웁니다.</li>
<li>HttpServletRequest에 담긴 <code>RequestCache</code>를 저장합니다.</li>
<li>AuthenticationEntryPoint를 통해 <code>WWW-Authenticate</code>헤더로 보내거나 로그인 페이지로 리다이렉트합니다.</li>
<li><code>AccessDeniedException</code>인 경우 <code>AccessDeniedHandler</code>가 인증 거부를 처리합니다.</li>
</ul></article></div><footer class="jsx-76612a042023d019"></footer></div><footer class="jsx-76612a042023d019"></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"layout":"post","title":"Spring Security Architecture","date":"2022-02-03 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring Security Architecture"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      h3: \"h3\",\n      br: \"br\",\n      ul: \"ul\",\n      li: \"li\",\n      code: \"code\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"Security\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"애플리케이션에서 보안은 인증과 권한 두 가지 문제로 구분됩니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Authentication\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"인증을 위한 주요 전략은 인증 메서드 하나면 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"authenticate 메서드라고 한다면 예상되는 결과는 세 가지 중 하나입니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"인증을 성공했습니다 -\u003e 인증 주체 정보 + 인증 성공 정보\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"인증을 실패했습니다 -\u003e 인증 실패 예외 처리\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"인증을 결정할 수 없습니다 -\u003e 인증 정보 null\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"인증 실패의 경우 401 응답과 예외 처리 정보를 보낼 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"인증 결정을 못한 경우 이어지는 다음 인증 처리로 넘기거나 예외처리할 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Authorization\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"권한은 인증이 성공한 이후에 이뤄지며 인증 정보를 가지고 권한을 판단합니다.\", _jsx(_components.br, {}), \"\\n\", \"나온 결과로 ROLE_ADMIN, ROLE_AUDIT 처럼 보통 ROLE_ 로 권한을 구분합니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Web Security\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"클라이언트에서 받아서 Servlet까지 가는 과정동안 Filters를 거치게 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"Filter가 연쇄적으로 구성된 FilterChain으로 HttpServletRequest가 처리됩니다.\\nFilter가 할 수 있는 일은 두 가지입니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"다음으로 처리될 Filter나 Servlet 처리를 막습니다. 바로 응답으로 넘어갑니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"다음으로 처리될 Filter나 Servlet에 사용될 요청이나 응답을 수정합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"DelegatingFilterProxy\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"DelegatingFilterProxy로 구현된 Filter는 스프링 ApplicationContext 상에서 서블릿 컨테이너 생명주기에 맞게 사용할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"다시 말하면 서블릿 컨테이너는 아무 Filter나 사용 가능하지만, 스프링에 정의된 빈인 것을 신경쓰지 않습니다.\\nDelegatingFilterProxy를 사용하면 서블릿 컨테이너에 필터를 직접 등록하는 대신 스프링 빈이 대신합니다.\\n서블릿 컨테이너가 실행되기 이전에 필터들이 등록되어야 하는데 Proxy로 처리된 필터들이 등록됩니다.\\n따라서 Context에 등록된 빈들을 불러오기 이전에 컨테이너에 필터를 등록하는 작업을 할 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"FilterChainProxy \u0026 SecurityFilterChain\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"Filter를 구현해서 사용할 때 하나의 필터가 아닌 여러개를 FilterChainProxy로 등록이 가능합니다.\\n이런 필터들을 SecurityFilterChain이라고 합니다.\", _jsx(_components.br, {}), \"\\n\", \"하나의 필터를 여러개로 대체하는 이유는 상황이나 경로에 따라 여러 조건을 추가할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"api를 처리할 때, view를 처리할 때등 경로에 따라 다른 필터를 적용시킬 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Security Filters\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Security Filter들은 순서에 따라 진행됩니다. 따라서 순차적인 처리가 필요하다면 대표적인 필터의 처리 순서를 알고 있는 것이 좋습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"CorsFilter\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"CsrfFilter\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"LogOutFilter\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"OAuth2AuthorizationRequestRedirectFilter\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"BearerTokenAuthenticationFilter\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Handling Security Exceptions\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"ExceptionTranslationFilter\"\n        }), \"에선 \", _jsx(_components.code, {\n          children: \"AccessDeniedException\"\n        }), \"이나 \", _jsx(_components.code, {\n          children: \"AuthenticationException\"\n        }), \"을 응답으로 바꿀 수 있습니다.\\n필터에서 인증되지 않은 상태거나 \", _jsx(_components.code, {\n          children: \"AuthenticationException\"\n        }), \" 이라면 다음 과정을 거칩니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"SecurityContextHolder를 비웁니다.\"\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"HttpServletRequest에 담긴 \", _jsx(_components.code, {\n            children: \"RequestCache\"\n          }), \"를 저장합니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"AuthenticationEntryPoint를 통해 \", _jsx(_components.code, {\n            children: \"WWW-Authenticate\"\n          }), \"헤더로 보내거나 로그인 페이지로 리다이렉트합니다.\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [_jsx(_components.code, {\n            children: \"AccessDeniedException\"\n          }), \"인 경우 \", _jsx(_components.code, {\n            children: \"AccessDeniedHandler\"\n          }), \"가 인증 거부를 처리합니다.\"]\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"Spring Security Architecture"},"buildId":"MWAHttpm_JJE2ebIzAafd","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>