<!DOCTYPE html><html><head><title>Ordinary</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="Blog"/><link rel="icon" href="/favicon.ico"/><meta name="next-head-count" content="5"/><link rel="preload" href="/_next/static/css/f30e95c4ef9a5ce6.css" as="style"/><link rel="stylesheet" href="/_next/static/css/f30e95c4ef9a5ce6.css" data-n-g=""/><link rel="preload" href="/_next/static/css/b8560289fc67afa8.css" as="style"/><link rel="stylesheet" href="/_next/static/css/b8560289fc67afa8.css" data-n-p=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-fd1bc4a65a80e5c8.js" defer=""></script><script src="/_next/static/chunks/framework-5f4595e5518b5600.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-10d16e51767f2eb7.js" defer=""></script><script src="/_next/static/chunks/132-c8ad25a4bdd62a00.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-4c91ca1952ea948f.js" defer=""></script><script src="/_next/static/C_hZnuebhS8O93_BuECK4/_buildManifest.js" defer=""></script><script src="/_next/static/C_hZnuebhS8O93_BuECK4/_ssgManifest.js" defer=""></script><script src="/_next/static/C_hZnuebhS8O93_BuECK4/_middlewareManifest.js" defer=""></script></head><body><div id="__next" data-reactroot=""><div class="Home_container__97eC3"><div class="Header_header__ubBbX"><div class="Header_headerLeft__gJBl3"><a href="/">Ordinary</a></div><div class="Header_headerRight__uflv6"><a href="/about">About</a></div></div><article class="Post_container__qv178"><div class="Post_head__hU8yK"><h1 class="Post_title__MJ8Hr">문제 해결 전략 4</h1><div class="Post_meta__TGwfg"><img src="/profile.png" class="Post_avatar__KIFLy" alt="profile"/><div class="Post_profile__wwScp">ordilov /<!-- --> <!-- -->6/23/202</div></div></div><div style="--size:20pt" class="MDX_Heading__T63mn">개관</div>
<p class="MDX_Paragraph__xqVvo"><strong>알고리즘 :</strong> 컴퓨터가 작업을 해결하는 방법</p>
<p class="MDX_Paragraph__xqVvo">프로그래밍 대회에 N명의 사람들이 참가해 답안을 제출했습니다.<br/>
<!-- -->100점 만점 기준으로 1등부터 20등까지 평균을 계산합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>가능한 방법</strong></p>
<ol>
<li>
<p class="MDX_Paragraph__xqVvo">전체 자료를 내림차순하고 20등까지 남깁니다.<br/>
<!-- -->남아있는 20명의 평균을 구합니다.</p>
</li>
<li>
<p class="MDX_Paragraph__xqVvo">상위 20명을 기록할 별도의 표를 만듭니다.<br/>
<!-- -->모든 사람의 점수를 훑으면서 20명만 남깁니다.
기록을 마치고 값의 평균을 구합니다.</p>
</li>
<li>
<p class="MDX_Paragraph__xqVvo">임의의 한 명을 기준으로 삼습니다.<br/>
<!-- -->더 잘 받은 그룹과 못 받은 그룹으로 나눕니다.
잘 받은 그룹 기준으로 아래 조건을 실행합니다.</p>
</li>
</ol>
<ul>
<li>20명 이상이면 하위를 지우고 상위에서 다시 반복합니다.</li>
<li>20명 이하이면 상위에 포함하고 하위에서 다시 반복합니다.</li>
</ul>
<p class="MDX_Paragraph__xqVvo">같은 일이지만 여러가지 방법이 있습니다.<br/>
<!-- -->이처럼 주어진 문제를 한 가지 방법으로 푼 것이 <strong>알고리즘</strong>입니다.<br/>
<!-- -->주관적이고 모호한 것은 <strong>알고리즘</strong>이 아닙니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>알고리즘 O</strong></p>
<ol>
<li>지하철 2호선을 타고 시청역으로 간다.</li>
<li>지하철 1호선을 갈아타고 청량리역으로 간다.</li>
<li>경춘선을 타고, 춘천역에서 내린다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo"><strong>알고리즘 X</strong></p>
<ol>
<li>강동구 쪽으로 가는 버스를 탄다.</li>
<li>동서울 버스 터미널 근처에서 내린다.</li>
<li>춘천행 버스를 타고, 한참 가다 내린다.</li>
</ol>
<p class="MDX_Paragraph__xqVvo">여러 알고리즘이 있다면 어떤 알고리즘을 선택할까요?<br/>
<!-- -->보통 기준을 <strong>시간</strong>과 <strong>공간</strong>으로 선택합니다.<br/>
<!-- -->둘은 상충하는 경우가 많은데 주로 <strong>시간</strong>을 기준으로 잡습니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">4.1 도입</div>
<p class="MDX_Paragraph__xqVvo">알고리즘의 속도를 어떻게 측정할까요?<br/>
<!-- -->가장 직관적인 방법은 두 프로그램 수행 속도 비교입니다.<br/>
<!-- -->이론적으로는 아무리 빨라도 실행 시 느리면 소용없습니다.<br/>
<!-- -->하지만 실행 시간은 외부환경에 따라 바뀔 수 있습니다.<br/>
<!-- -->또한 다양한 입력에 대한 실행 시간을 반영하지 못합니다.<br/>
<!-- -->그럼 어떤 기준으로 측정해야 할까요?</p>
<p class="MDX_Paragraph__xqVvo"><strong>반복문이 지배한다.</strong></p>
<p class="MDX_Paragraph__xqVvo">보통 입력 횟수에 따라 수행 시간이 달라지므로 반복문이 기준이 됩니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">4.2 선형 시간 알고리즘</div>
<p class="MDX_Paragraph__xqVvo"><strong>다이어트 현황 파악: 이동 평균 계산하기</strong></p>
<p class="MDX_Paragraph__xqVvo">이동 평균은 시간에 따라 변하는 값을 관찰할 때 유용한 통계 기준입니다.<br/>
<!-- -->M-이동평균은 마지막 M개의 관찰값의 평균으로 정의됩니다.<br/>
<!-- -->따라서 새 관찰 값이 나오면 M-이동평균은 새 관찰값을 포함하도록 바뀝니다.</p>
<p class="MDX_Paragraph__xqVvo">N개의 측정치가 주어질때 매달 M달간의 이동 평균을 계산하면?</p>
<pre><code class="hljs language-java">ArrayList&lt;Double&gt; <span class="hljs-title hljs-function">movingAverage1</span><span class="hljs-params">(ArrayList&lt;Double&gt; N, <span class="hljs-type">int</span> M)</span> {
    ArrayList&lt;Double&gt; answer = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">ArrayList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; N.size() - (M - <span class="hljs-number">1</span>); i++) {
        <span class="hljs-type">double</span> <span class="hljs-variable">partialSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

        <span class="hljs-comment">// M개의 측정치를 더합니다.</span>
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">f</span> <span class="hljs-operator">=</span> i; f &lt; i + M; f++)
            partialSum += N.get(f);

        <span class="hljs-comment">// M개의 측정치로 나눠 평균을 구합니다.</span>
        answer.add(partialSum / M);
    }
    <span class="hljs-keyword">return</span> answer;
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">전체 반복문의 횟수는 M*(N-M+1)이 됩니다.<br/>
<!-- -->중복 계산을 단축하려면 어떻게 할까요?<br/>
<!-- -->0일과 M일의 몸무게를 제외하면 모든 경우 겹칩니다.<br/>
<!-- -->반복문을 나눠서 계산해봅니다.</p>
<pre><code class="hljs language-java">ArrayList&lt;Double&gt; <span class="hljs-title hljs-function">movingAverage2</span><span class="hljs-params">(ArrayList&lt;Double&gt; N, <span class="hljs-type">int</span> M)</span> {
    ArrayList&lt;Double&gt; answer = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">ArrayList</span>&lt;&gt;();
    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> N.size();

    <span class="hljs-type">double</span> <span class="hljs-variable">partialSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; M - <span class="hljs-number">1</span>; i++) {
        partialSum += N.get(i);
    }

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> M - <span class="hljs-number">1</span>; i &lt; size; i++) {
        partialSum += N.get(i);
        answer.add(partialSum / M);
        partialSum -= N.get(i - (M - <span class="hljs-number">1</span>));
    }

    answer.add(partialSum / M);
    <span class="hljs-keyword">return</span> answer;
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">수행 시간은 M-1+(N-M+1) = N입니다.<br/>
<!-- -->그래프로 그려보면 시간 대비 직선으로 그려집니다.<br/>
<!-- -->이런 알고리즘을 <strong>선형 시간</strong> 알고리즘이라고 부릅니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">4.3 선형 이하 시간 알고리즘</div>
<p class="MDX_Paragraph__xqVvo"><strong>성형 전 사진 찾기</strong>
어떤 문제건 자료를 한 번 다 보기만 해도 선형 시간이 걸립니다.<br/>
<!-- -->선형 시간보다 짧으려면 자료가 정리되있어야 합니다.<br/>
<!-- -->구체적인 예를 들어보겠습니다.</p>
<p class="MDX_Paragraph__xqVvo">A군이 데뷔를 했는데 성형 전 고등학교 사진이 공개되었습니다.<br/>
<!-- -->시간순으로 정렬된 과거사진에서 언제 성형했는지 확인하려 합니다.<br/>
<!-- -->이때 빨리 찾을 수 있는 방법이 어떤 것일까요?<br/>
<!-- -->남은 사진들을 절반으로 나눠 가운데 사진을 보는 것입니다.<br/>
<!-- -->확인시 성형을 안했으면 이전 반은 넘길 수 있습니다.<br/>
<!-- -->이런 속도로 감소하는 그래프는 <strong>로그함수</strong>로 그려집니다.<br/>
<!-- -->선형 이하 시간으로 느리게 증가합니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>이진 탐색</strong>
위처럼 반씩 탐색하는 알고리즘은 <strong>이진 탐색</strong>이라 부릅니다.<br/>
<!-- -->이진 탐색은 다음과 같이 정의할 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo">binsearch(a[], x)</p>
<p class="MDX_Paragraph__xqVvo">오름차순으로 정렬한 배열A[]와 찾고싶은 값 x</p>
<div style="--size:24pt" class="MDX_Heading__T63mn"><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>&lt;</mo><mi>x</mi><mo>&lt;</mo><mo>=</mo><mi>A</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">A[i-1] &lt; x &lt;= A[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal">i</span><span class="mclose">]</span></span></span></span></span></div>
<p class="MDX_Paragraph__xqVvo">인 i를 반환한다.</p>
<div style="--size:24pt" class="MDX_Heading__T63mn"><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo stretchy="false">[</mo><mo>−</mo><mn>1</mn><mo stretchy="false">]</mo><mo>=</mo><mo>−</mo><mi>I</mi><mi>N</mi><mi>F</mi><mo separator="true">,</mo><mi>A</mi><mo stretchy="false">[</mo><mi>N</mi><mo stretchy="false">]</mo><mo>=</mo><mi>I</mi><mi>N</mi><mi>F</mi></mrow><annotation encoding="application/x-tex">A[-1] = -INF, A[N] = INF</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">−</span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.13889em">NF</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mord mathnormal">A</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07847em">I</span><span class="mord mathnormal" style="margin-right:0.13889em">NF</span></span></span></span></span></div>
<p class="MDX_Paragraph__xqVvo">로 가정한다.</p>
<p class="MDX_Paragraph__xqVvo">A[]에서 x를 삽입할 수 있는 위치 중 가장 앞을 반환합니다.<br/>
<!-- -->위의 성형 전 사진을 찾는 문제는 어떻게 풀까요?<br/>
<!-- -->길이 N인 정수 배열 A[]를 만들어 값을 저장합니다.<br/>
<!-- -->확인한 사진에서 성형시 1을, 아닌 경우 0으로 저장합니다.<br/>
<!-- -->이 중에서 1이 가장 먼저 나오는 1의 위치를 반환하면 됩니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>그래도 선형 시간 아닌가요?</strong></p>
<p class="MDX_Paragraph__xqVvo">위에서 나온 설명대로라면 0과 1을 저장하는 시간이 필요합니다.<br/>
<!-- -->그리고 시간순으로 정렬하는 시간도 필요합니다.<br/>
<!-- -->하지만 이런 시간들은 다음 이유로 이렇게 분석하지 않습니다.</p>
<ol>
<li>정렬해두는 과정은 탐색 과정과 별개입니다.</li>
<li>A[]를 미리 모두 계산이 아닌 확인하는 값만 사용하면 됩니다.</li>
</ol>
<div style="--size:20pt" class="MDX_Heading__T63mn">4.4 지수 시간 알고리즘</div>
<p class="MDX_Paragraph__xqVvo"><strong>다항 시간 알고리즘</strong></p>
<p class="MDX_Paragraph__xqVvo">변수 N과 N^2 그리고 N의 거듭제곱들을 <strong>다항식</strong>이라 부릅니다.<br/>
<!-- -->수행 횟수를 입력 크기의 반복 횟수로 표현할 수 있으면 <strong>다항시간</strong> 알고리즘이라 부릅니다.<br/>
<!-- -->같은 다항 시간이라도 제곱에 따라 시간차이가 납니다.<br/>
<!-- -->그런데도 하나로 묶는 이유는 더 오래 걸리는 알고리즘들이 있어서입니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>알러지가 심한 친구들</strong></p>
<p class="MDX_Paragraph__xqVvo">집들이에 N명의 친구를 초대하려 합니다.<br/>
<!-- -->음식 M가지 중 친구들이 못 먹는 음식을 고려해 만들려고 합니다.<br/>
<!-- -->각 친구가 하나씩은 먹으려면 몇 가지 음식을 해야 할까요?</p>
<p class="MDX_Paragraph__xqVvo"><strong>모든 답 후보를 평가하기</strong></p>
<p class="MDX_Paragraph__xqVvo">모든 음식을 한다면 모두가 음식을 먹을 수 있습니다.<br/>
<!-- -->하지만 우리는 그보다 더 구체적으로 작은 음식을 준비하려 합니다.<br/>
<!-- -->이럴 때 가장 먼저 떠오르는 건 모든 답을 다 확인하는 것입니다.<br/>
<!-- -->첫 번째 음식을 만들지 말지, 그 다음도 계속 반복하는 것이지요.<br/>
<!-- -->이런 알고리즘을 구현하기 쉬운 방법은 재귀 호출입니다.</p>
<pre><code class="hljs language-java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">INF</span> <span class="hljs-operator">=</span> <span class="hljs-number">987654321</span>;
<span class="hljs-comment">// 요리할 수 있는 음식의 종류의 수</span>
<span class="hljs-type">int</span> M;
<span class="hljs-comment">// food번째 음식을 만들지 결정</span>
<span class="hljs-type">int</span> <span class="hljs-title hljs-function">selectMenu</span><span class="hljs-params">(LinkedList&lt;Integer&gt; menu, <span class="hljs-type">int</span> food)</span> {
    <span class="hljs-keyword">if</span> (food == M) {
        <span class="hljs-keyword">if</span> (canEveryBodyEat(menu)) <span class="hljs-keyword">return</span> menu.size();
        <span class="hljs-comment">// 못 먹는 사람이 있으면 아주 큰 값 반환</span>
        <span class="hljs-keyword">return</span> INF;
    }
    <span class="hljs-comment">// 이 음식을 만들지 않는 경우의 답 계산</span>
    <span class="hljs-type">int</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> selectMenu(menu, food + <span class="hljs-number">1</span>);
    <span class="hljs-comment">// 이 음식을 만드는 경우의 답 계산 후 더 작은 값 선택</span>
    menu.add(food);
    answer = Math.min(answer, selectMenu(menu, food + <span class="hljs-number">1</span>));
    menu.remove();
    <span class="hljs-keyword">return</span> answer;
}
</code></pre>
<p class="MDX_Paragraph__xqVvo"><strong>지수 시간 알고리즘</strong></p>
<p class="MDX_Paragraph__xqVvo">답을 한 번씩 다 확인하기 때문에 시간은 답의 수에 비례합니다.<br/>
<!-- -->M가지의 음식마다 선택하므로 답은 2^M가지입니다.<br/>
<!-- -->그리고 canEverybodyEat의 수행시간을 곱해야합니다.<br/>
<!-- -->10가지 경우라면 1000개 수준이지만 30개면 백만배로 늘어납니다.<br/>
<!-- -->이렇게 시간이 배로 올라가면 <strong>지수 시간</strong> 알고리즘입니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>소인수 분해의 수행 시간</strong></p>
<p class="MDX_Paragraph__xqVvo">입력으로 주어지는 숫자의 개수가 아닌 크기에 따라 달라질 수도 있습니다.</p>
<pre><code class="hljs language-java">LinkedList&lt;Integer&gt; <span class="hljs-title hljs-function">factor</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> {
    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) 
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">LinkedList</span>&lt;&gt;(Collections.singletonList(<span class="hljs-number">1</span>));
    LinkedList&lt;Integer&gt; answer = <span class="hljs-keyword">new</span> <span class="hljs-title hljs-class">LinkedList</span>&lt;&gt;();
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">div</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; n &gt; <span class="hljs-number">1</span>; ++div) {
        <span class="hljs-keyword">while</span> (n % div == <span class="hljs-number">0</span>) {
            n /= div;
            answer.add(div);
        }
    }
    <span class="hljs-keyword">return</span> answer;
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">N이 1이 될때까지 가능한 모든 수로 나누어 봅니다.<br/>
<!-- -->N이 소수인 경우 나누기가 되지 않고 모든 수에 시도합니다.<br/>
<!-- -->그 경우 반복문 실행 횟수는 N-1이 됩니다.<br/>
<!-- -->이 경우 시간과 메모리 공간과의 관계를 생각해야 합니다.<br/>
<!-- -->입력값이 클수록 숫자를 저장하는 메모리 공간이 커집니다.<br/>
<!-- -->비트 수마다 수행시간이 두 배 증가하므로 이 경우도 지수시간입니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">4.5 시간 복잡도</div>
<p class="MDX_Paragraph__xqVvo"><strong>시간 복잡도</strong>란 수행하는 기본 연산 수를 입력 크기에 대한 함수로 표현한 것입니다.<br/>
<!-- -->기본 연산 수의 예제입니다.</p>
<ul>
<li>두 부호 있는 32비트 정수의 사칙연산</li>
<li>두 실수형 변수의 대소 비교</li>
<li>한 변수에 다른 변수 대입하기</li>
</ul>
<p class="MDX_Paragraph__xqVvo">다음은 기본적인 연산이 아닙니다.</p>
<ul>
<li>정수 배열 정렬하기</li>
<li>두 문자열이 서로 같은지 확인하기</li>
<li>입력된 두 소인수 분해하기</li>
</ul>
<p class="MDX_Paragraph__xqVvo">시간 복잡도가 높다는 말은 입력 크기가 증가할 때 더 빠르게 증가하는 것을 의미합니다.<br/>
<!-- -->이 말은 시간 복잡도가 낮다고 빠르다는 이야기는 아닙니다.<br/>
<!-- -->입력의 크기가 작을 때는 시간 복잡도가 낮아도 빠를 수 있습니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>입력의 종류에 따른 수행 시간의 변화</strong></p>
<p class="MDX_Paragraph__xqVvo">입력의 크기가 수행 시간을 결정하는 유일한 척도는 아닙니다.<br/>
<!-- -->입력이 어떤 형태로 구성되어 있는지도 영향을 미칩니다.</p>
<pre><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title hljs-function">firstIndex</span><span class="hljs-params">(LinkedList&lt;Integer&gt; array, <span class="hljs-type">int</span> element)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++)
        <span class="hljs-keyword">if</span> (array.get(i) == element)
            <span class="hljs-keyword">return</span> i;
    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;
}
</code></pre>
<ul>
<li>최선의 수행 시간: 맨 앞에 있는 경우 1</li>
<li>평균의 수행 시간: 중간에 있는 경우 N/2</li>
<li>최악의 수행 시간: 값이 없는 경우 N</li>
</ul>
<p class="MDX_Paragraph__xqVvo"><strong>점근적 시간 표기: O표기</strong>
시간 복잡도는 단순하게 표기하기 위해 <strong>O표기법</strong>으로 표기합니다.<br/>
<!-- -->가장 빨리 증가하는 항만 남기고 나머지를 버립니다.<br/>
<!-- -->변수가 두 개이상인 경우 가장 발리 증가하는 항만 놓습니다.</p>
<p class="MDX_Paragraph__xqVvo">항상 같은 시간이 걸리는 경우 <strong>상수 시간</strong> 알고리즘입니다.</p>
<p class="MDX_Paragraph__xqVvo">N에 대한 함수 f(N)이 주어질 때 f(N)=O(g(N))의 의미입니다.</p>
<p class="MDX_Paragraph__xqVvo">아주 큰 N0와 C(N0, C&gt;0)에서 적절히 선택합니다.</p>
<div style="--size:24pt" class="MDX_Heading__T63mn"><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>N</mi><mn>0</mn><mo>&lt;</mo><mo>=</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">N0 &lt;= N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7224em;vertical-align:-0.0391em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.10903em">N</span></span></span></span></span></div>
<p class="MDX_Paragraph__xqVvo">인 모든 N에 대해</p>
<div style="--size:24pt" class="MDX_Heading__T63mn"><span class="math math-inline"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∣</mi><mi>f</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi><mo>&lt;</mo><mo>=</mo><mi>C</mi><mo>∗</mo><mi mathvariant="normal">∣</mi><mi>g</mi><mo stretchy="false">(</mo><mi>N</mi><mo stretchy="false">)</mo><mi mathvariant="normal">∣</mi></mrow><annotation encoding="application/x-tex">|f(N)|&lt;=C*|g(N)|</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.10764em">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mclose">)</span><span class="mord">∣</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">&lt;=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:0.6833em"></span><span class="mord mathnormal" style="margin-right:0.07153em">C</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord">∣</span><span class="mord mathnormal" style="margin-right:0.03588em">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.10903em">N</span><span class="mclose">)</span><span class="mord">∣</span></span></span></span></span></div>
<p class="MDX_Paragraph__xqVvo">이 참이 됩니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>시간 복잡도 분석 연습</strong></p>
<pre><code class="hljs language-java"><span class="hljs-keyword">void</span> <span class="hljs-title hljs-function">selectionSort</span><span class="hljs-params">(LinkedList&lt;Integer&gt; array)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); i++) {
        <span class="hljs-type">int</span> <span class="hljs-variable">minIndex</span> <span class="hljs-operator">=</span> i;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i + <span class="hljs-number">1</span>; j &lt; array.size(); ++j) {
            <span class="hljs-keyword">if</span> (array.get(minIndex) &gt; array.get(j))
                minIndex = j;
        }
        Collections.swap(array, minIndex, i);
    }
}

<span class="hljs-keyword">void</span> <span class="hljs-title hljs-function">insertionSort</span><span class="hljs-params">(LinkedList&lt;Integer&gt; array)</span> {
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; array.size(); ++i) {
        <span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i;
        <span class="hljs-keyword">while</span> (j &gt; <span class="hljs-number">0</span> &amp;&amp; array.get(j - <span class="hljs-number">1</span>) &gt; array.get(j)) {
            Collections.swap(array, j-<span class="hljs-number">1</span>, j);
            --j;
        }
    }
}
</code></pre>
<p class="MDX_Paragraph__xqVvo"><strong>selectionSort</strong>는 <strong>선택 정렬</strong>입니다.<br/>
<!-- -->A[i...N-1]에서 가장 작은 원소를 찾아 A[i]에 대입합니다.<br/>
<!-- -->시간 복잡도는 N-1 + N-2 ... 1 = O(N^2)입니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>insertionSort</strong>는 <strong>삽입정렬</strong>입니다.<br/>
<!-- -->전체 배열 중 정렬되어 있는 부분에 새 원소를 끼워넣습니다.<br/>
<!-- -->최선의 경우 이미 정렬된 경우로 while이 O(1)으로 전체 O(N)입니다.<br/>
<!-- -->최악의 경우 역순으로 정렬된 경우로 삽입정렬처럼 O(N^2)입니다.</p>
<p class="MDX_Paragraph__xqVvo">비교했을 시 삽입정렬이 대부분의 경우 더 빠릅니다.<br/>
<!-- -->삽입정렬은 O(N^2) 정렬중 가장 빠른 것으로 알려져있습니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>시간 복잡도의 분할 상환 분석</strong></p>
<p class="MDX_Paragraph__xqVvo"><strong>분할 상환 분석</strong>은 반복문의 개수보다 더 정확하게 분석하는 방법입니다.<br/>
<!-- -->N개의 라면을 끓여 N명이 먹었습니다.<br/>
<!-- -->더 적게 먹거나 많이 먹을 수 있지만 N개의 라면은 동일합니다.<br/>
<!-- -->이것처럼 각 작업량은 달라도 전체가 동일할 수 있습니다.<br/>
<!-- -->이 때의 평균량은 전체에서 개수를 나눈 것과 동일합니다.</p>
<div style="--size:20pt" class="MDX_Heading__T63mn">4.6 수행 시간 어림짐작하기</div>
<p class="MDX_Paragraph__xqVvo"><strong>주먹구구 법칙</strong></p>
<p class="MDX_Paragraph__xqVvo">프로그램을 작성하기 전에 어느 정도 수행시간을 짐작해야 합니다.<br/>
<!-- -->어려운 일이지만 입력 크기만으로도 대략적으로 짐작이 가능합니다.</p>
<blockquote>
<p class="MDX_Paragraph__xqVvo">1초당 반복문이 1억이 넘어가면 시간 제한 초과 가능성이 높다.</p>
</blockquote>
<p class="MDX_Paragraph__xqVvo">입력의 최대크기 N이 10000이고 시간 제한이 1초라고 합시다.<br/>
<!-- -->O(N^3)이라면 1억을 넘어갑니다.<br/>
<!-- -->O(N^2)이라면 넘지 않지면 조건에 따라 다를 겁니다.
따라서 이 경우에는 충분한 여유를 두고 수행하는 것이 좋습니다.</p>
<p class="MDX_Paragraph__xqVvo"><strong>고려해야할 사항</strong></p>
<ul>
<li>
<p class="MDX_Paragraph__xqVvo">시간 복잡도가 실제 수행속도를 반영?<br/>
<!-- -->O표기법의 경우 최고차항만 고려하므로 그 외를 생각합니다.</p>
</li>
<li>
<p class="MDX_Paragraph__xqVvo">반복문의 내부가 복잡한 경우?<br/>
<!-- -->반복문 내부는 최대한 단순할수록 좋습니다.</p>
</li>
<li>
<p class="MDX_Paragraph__xqVvo">메모리 사용 패턴이 복잡한 경우?<br/>
<!-- -->자주 사용하는 변수는 미리 캐시로 저장해 관리합니다.</p>
</li>
</ul>
<p class="MDX_Paragraph__xqVvo"><strong>실제 적용해 보기</strong></p>
<p class="MDX_Paragraph__xqVvo">1차원 배열에서 연속된 부분 구간 중 합이 최대인 구간을 구합니다.<br/>
<!-- -->[-7, 4, -3, 6, 3, -8, 3, 4]의 경우 [4, -3, 6, 3]으로 10입니다.</p>
<p class="MDX_Paragraph__xqVvo">먼저 모든 구간을 순회하면서 합을 계산해봅니다.<br/>
<!-- -->O(N^2)으로 후보 구간을 검사하고 더하는 데 O(N)으로 O(N^3)입니다.</p>
<pre><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title hljs-function">inefficientMaxSum</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();
    <span class="hljs-type">int</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) {
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; size; j++) {
            <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> i; k &lt;= j; k++)
                sum += list.get(k);

            <span class="hljs-keyword">if</span> (sum &gt; answer)
                answer = sum;
        }
    }
    <span class="hljs-keyword">return</span> answer;
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">연속된 부분의 합부분을 개선하면 O(N^2)이 됩니다.</p>
<pre><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title hljs-function">betterMaxSum</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list)</span> {
    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> list.size();
    <span class="hljs-type">int</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;

    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i++) {
        <span class="hljs-type">int</span> <span class="hljs-variable">sum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i; j &lt; size; j++) {
            sum += list.get(j);

            <span class="hljs-keyword">if</span> (answer &lt; sum)
                answer = sum;
        }
    }
    <span class="hljs-keyword">return</span> answer;
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">분할 정복 기법을 이용하면 이보다 더 빠르게 가능합니다.<br/>
<!-- -->우선 절반을 잘라 왼쪽과 오른쪽 배열로 나눕니다.<br/>
<!-- -->재귀 호출과 탐욕법을 이용해 계산합니다.<br/>
<!-- -->알고리즘 시간 복잡도는 O(NlogN)입니다.</p>
<pre><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title hljs-function">fastMaxSum</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list, <span class="hljs-type">int</span> lo, <span class="hljs-type">int</span> hi)</span> {
    <span class="hljs-keyword">if</span> (lo == hi)
        <span class="hljs-keyword">return</span> list.get(lo);

    <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (lo + hi) / <span class="hljs-number">2</span>;

    <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> MIN, right = MIN, sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mid; i &gt;= lo; --i) {
        sum += list.get(i);
        left = Math.max(left, sum);
    }

    sum = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> mid + <span class="hljs-number">1</span>; i &lt;= hi; ++i) {
        sum += list.get(i);
        right = Math.max(right, sum);
    }

    <span class="hljs-type">int</span> <span class="hljs-variable">single</span> <span class="hljs-operator">=</span> Math.max(fastMaxSum(list, lo, mid),
            fastMaxSum(list, mid + <span class="hljs-number">1</span>, hi));

    <span class="hljs-keyword">return</span> Math.max(left + right, single);
}
</code></pre>
<p class="MDX_Paragraph__xqVvo">마지막으로 동적계획법으로 해결합니다.<br/>
<!-- -->A[i]를 오른쪽 끝으로 갖는 최대합 maxAt(i)를 정의합니다.</p>
<blockquote>
<p class="MDX_Paragraph__xqVvo">maxAt(i) = max(0, maxAt(i=1)) + A[i]</p>
</blockquote>
<p class="MDX_Paragraph__xqVvo">하나의 반복문만 갖고있으므로 O(N)이 됩니다.</p>
<pre><code class="hljs language-java"><span class="hljs-type">int</span> <span class="hljs-title hljs-function">fastestMaxSum</span><span class="hljs-params">(LinkedList&lt;Integer&gt; list)</span>{
    <span class="hljs-type">int</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> Integer.MIN_VALUE;
    <span class="hljs-type">int</span> <span class="hljs-variable">partialSum</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;

    <span class="hljs-keyword">for</span> (Integer i : list) {
        partialSum = Math.max(partialSum, <span class="hljs-number">0</span>) + i;
        answer = max(partialSum, answer);
    }
    <span class="hljs-keyword">return</span> answer;
}
</code></pre>
<ul>
<li>O(N^3)의 경우 2560 입력까지 1초 안에 풀 수 있습니다.</li>
<li>O(N^2)의 경우 40960 입력까지 1초 안에 풀 수 있습니다.</li>
<li>O(NlogN)의 경우 2천만 입력까지 1초 안에 풀 수 있습니다.</li>
<li>O(N)의 경우 1억 6천만 입력까지 1초 안에 풀 수 있습니다.</li>
</ul></article></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"title":"문제 해결 전략 4","date":"2021-06-24 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"문제-해결-전략-4"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      strong: \"strong\",\n      br: \"br\",\n      ol: \"ol\",\n      li: \"li\",\n      ul: \"ul\",\n      pre: \"pre\",\n      code: \"code\",\n      span: \"span\",\n      h1: \"h1\",\n      math: \"math\",\n      semantics: \"semantics\",\n      mrow: \"mrow\",\n      mi: \"mi\",\n      mo: \"mo\",\n      mn: \"mn\",\n      annotation: \"annotation\",\n      blockquote: \"blockquote\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"개관\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"알고리즘 :\"\n        }), \" 컴퓨터가 작업을 해결하는 방법\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"프로그래밍 대회에 N명의 사람들이 참가해 답안을 제출했습니다.\", _jsx(_components.br, {}), \"\\n\", \"100점 만점 기준으로 1등부터 20등까지 평균을 계산합니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"가능한 방법\"\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"전체 자료를 내림차순하고 20등까지 남깁니다.\", _jsx(_components.br, {}), \"\\n\", \"남아있는 20명의 평균을 구합니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"상위 20명을 기록할 별도의 표를 만듭니다.\", _jsx(_components.br, {}), \"\\n\", \"모든 사람의 점수를 훑으면서 20명만 남깁니다.\\n기록을 마치고 값의 평균을 구합니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"임의의 한 명을 기준으로 삼습니다.\", _jsx(_components.br, {}), \"\\n\", \"더 잘 받은 그룹과 못 받은 그룹으로 나눕니다.\\n잘 받은 그룹 기준으로 아래 조건을 실행합니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"20명 이상이면 하위를 지우고 상위에서 다시 반복합니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"20명 이하이면 상위에 포함하고 하위에서 다시 반복합니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"같은 일이지만 여러가지 방법이 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"이처럼 주어진 문제를 한 가지 방법으로 푼 것이 \", _jsx(_components.strong, {\n          children: \"알고리즘\"\n        }), \"입니다.\", _jsx(_components.br, {}), \"\\n\", \"주관적이고 모호한 것은 \", _jsx(_components.strong, {\n          children: \"알고리즘\"\n        }), \"이 아닙니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"알고리즘 O\"\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"지하철 2호선을 타고 시청역으로 간다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"지하철 1호선을 갈아타고 청량리역으로 간다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"경춘선을 타고, 춘천역에서 내린다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"알고리즘 X\"\n        })\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"강동구 쪽으로 가는 버스를 탄다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"동서울 버스 터미널 근처에서 내린다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"춘천행 버스를 타고, 한참 가다 내린다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"여러 알고리즘이 있다면 어떤 알고리즘을 선택할까요?\", _jsx(_components.br, {}), \"\\n\", \"보통 기준을 \", _jsx(_components.strong, {\n          children: \"시간\"\n        }), \"과 \", _jsx(_components.strong, {\n          children: \"공간\"\n        }), \"으로 선택합니다.\", _jsx(_components.br, {}), \"\\n\", \"둘은 상충하는 경우가 많은데 주로 \", _jsx(_components.strong, {\n          children: \"시간\"\n        }), \"을 기준으로 잡습니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4.1 도입\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"알고리즘의 속도를 어떻게 측정할까요?\", _jsx(_components.br, {}), \"\\n\", \"가장 직관적인 방법은 두 프로그램 수행 속도 비교입니다.\", _jsx(_components.br, {}), \"\\n\", \"이론적으로는 아무리 빨라도 실행 시 느리면 소용없습니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 실행 시간은 외부환경에 따라 바뀔 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"또한 다양한 입력에 대한 실행 시간을 반영하지 못합니다.\", _jsx(_components.br, {}), \"\\n\", \"그럼 어떤 기준으로 측정해야 할까요?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"반복문이 지배한다.\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"보통 입력 횟수에 따라 수행 시간이 달라지므로 반복문이 기준이 됩니다.\"\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4.2 선형 시간 알고리즘\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"다이어트 현황 파악: 이동 평균 계산하기\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이동 평균은 시간에 따라 변하는 값을 관찰할 때 유용한 통계 기준입니다.\", _jsx(_components.br, {}), \"\\n\", \"M-이동평균은 마지막 M개의 관찰값의 평균으로 정의됩니다.\", _jsx(_components.br, {}), \"\\n\", \"따라서 새 관찰 값이 나오면 M-이동평균은 새 관찰값을 포함하도록 바뀝니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"N개의 측정치가 주어질때 매달 M달간의 이동 평균을 계산하면?\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [\"ArrayList\u003cDouble\u003e \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"movingAverage1\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(ArrayList\u003cDouble\u003e N, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" M)\"]\n          }), \" {\\n    ArrayList\u003cDouble\u003e answer = \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"ArrayList\"\n          }), \"\u003c\u003e();\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \"; i \u003c N.size() - (M - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"); i++) {\\n        \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"double\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"partialSum\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n\\n        \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// M개의 측정치를 더합니다.\"\n          }), \"\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"f\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" i; f \u003c i + M; f++)\\n            partialSum += N.get(f);\\n\\n        \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// M개의 측정치로 나눠 평균을 구합니다.\"\n          }), \"\\n        answer.add(partialSum / M);\\n    }\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" answer;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"전체 반복문의 횟수는 M*(N-M+1)이 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"중복 계산을 단축하려면 어떻게 할까요?\", _jsx(_components.br, {}), \"\\n\", \"0일과 M일의 몸무게를 제외하면 모든 경우 겹칩니다.\", _jsx(_components.br, {}), \"\\n\", \"반복문을 나눠서 계산해봅니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [\"ArrayList\u003cDouble\u003e \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"movingAverage2\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(ArrayList\u003cDouble\u003e N, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" M)\"]\n          }), \" {\\n    ArrayList\u003cDouble\u003e answer = \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"ArrayList\"\n          }), \"\u003c\u003e();\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"size\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" N.size();\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"double\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"partialSum\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \"; i \u003c M - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"; i++) {\\n        partialSum += N.get(i);\\n    }\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" M - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"; i \u003c size; i++) {\\n        partialSum += N.get(i);\\n        answer.add(partialSum / M);\\n        partialSum -= N.get(i - (M - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"));\\n    }\\n\\n    answer.add(partialSum / M);\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" answer;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"수행 시간은 M-1+(N-M+1) = N입니다.\", _jsx(_components.br, {}), \"\\n\", \"그래프로 그려보면 시간 대비 직선으로 그려집니다.\", _jsx(_components.br, {}), \"\\n\", \"이런 알고리즘을 \", _jsx(_components.strong, {\n          children: \"선형 시간\"\n        }), \" 알고리즘이라고 부릅니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4.3 선형 이하 시간 알고리즘\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"성형 전 사진 찾기\"\n        }), \"\\n어떤 문제건 자료를 한 번 다 보기만 해도 선형 시간이 걸립니다.\", _jsx(_components.br, {}), \"\\n\", \"선형 시간보다 짧으려면 자료가 정리되있어야 합니다.\", _jsx(_components.br, {}), \"\\n\", \"구체적인 예를 들어보겠습니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A군이 데뷔를 했는데 성형 전 고등학교 사진이 공개되었습니다.\", _jsx(_components.br, {}), \"\\n\", \"시간순으로 정렬된 과거사진에서 언제 성형했는지 확인하려 합니다.\", _jsx(_components.br, {}), \"\\n\", \"이때 빨리 찾을 수 있는 방법이 어떤 것일까요?\", _jsx(_components.br, {}), \"\\n\", \"남은 사진들을 절반으로 나눠 가운데 사진을 보는 것입니다.\", _jsx(_components.br, {}), \"\\n\", \"확인시 성형을 안했으면 이전 반은 넘길 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"이런 속도로 감소하는 그래프는 \", _jsx(_components.strong, {\n          children: \"로그함수\"\n        }), \"로 그려집니다.\", _jsx(_components.br, {}), \"\\n\", \"선형 이하 시간으로 느리게 증가합니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"이진 탐색\"\n        }), \"\\n위처럼 반씩 탐색하는 알고리즘은 \", _jsx(_components.strong, {\n          children: \"이진 탐색\"\n        }), \"이라 부릅니다.\", _jsx(_components.br, {}), \"\\n\", \"이진 탐색은 다음과 같이 정의할 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"binsearch(a[], x)\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"오름차순으로 정렬한 배열A[]와 찾고싶은 값 x\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      children: \"A\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"[\"\n                    }), _jsx(_components.mi, {\n                      children: \"i\"\n                    }), _jsx(_components.mo, {\n                      children: \"−\"\n                    }), _jsx(_components.mn, {\n                      children: \"1\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"]\"\n                    }), _jsx(_components.mo, {\n                      children: \"\u003c\"\n                    }), _jsx(_components.mi, {\n                      children: \"x\"\n                    }), _jsx(_components.mo, {\n                      children: \"\u003c\"\n                    }), _jsx(_components.mo, {\n                      children: \"=\"\n                    }), _jsx(_components.mi, {\n                      children: \"A\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"[\"\n                    }), _jsx(_components.mi, {\n                      children: \"i\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"]\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"A[i-1] \u003c x \u003c= A[i]\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"A\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"[\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"i\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mbin\",\n                  children: \"−\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"1\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \"]\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"\u003c\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.5782em\",\n                    verticalAlign: \"-0.0391em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"x\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"\u003c=\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"A\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"[\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"i\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \"]\"\n                })]\n              })]\n            })]\n          })\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"인 i를 반환한다.\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      children: \"A\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"[\"\n                    }), _jsx(_components.mo, {\n                      children: \"−\"\n                    }), _jsx(_components.mn, {\n                      children: \"1\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"]\"\n                    }), _jsx(_components.mo, {\n                      children: \"=\"\n                    }), _jsx(_components.mo, {\n                      children: \"−\"\n                    }), _jsx(_components.mi, {\n                      children: \"I\"\n                    }), _jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mi, {\n                      children: \"F\"\n                    }), _jsx(_components.mo, {\n                      separator: \"true\",\n                      children: \",\"\n                    }), _jsx(_components.mi, {\n                      children: \"A\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"[\"\n                    }), _jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"]\"\n                    }), _jsx(_components.mo, {\n                      children: \"=\"\n                    }), _jsx(_components.mi, {\n                      children: \"I\"\n                    }), _jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mi, {\n                      children: \"F\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"A[-1] = -INF, A[N] = INF\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"A\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"[\"\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"−\"\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"1\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \"]\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"=\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"−\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.07847em\"\n                  },\n                  children: \"I\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.13889em\"\n                  },\n                  children: \"NF\"\n                }), _jsx(_components.span, {\n                  className: \"mpunct\",\n                  children: \",\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.1667em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  children: \"A\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"[\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10903em\"\n                  },\n                  children: \"N\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \"]\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"=\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.6833em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.07847em\"\n                  },\n                  children: \"I\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.13889em\"\n                  },\n                  children: \"NF\"\n                })]\n              })]\n            })]\n          })\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"로 가정한다.\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"A[]에서 x를 삽입할 수 있는 위치 중 가장 앞을 반환합니다.\", _jsx(_components.br, {}), \"\\n\", \"위의 성형 전 사진을 찾는 문제는 어떻게 풀까요?\", _jsx(_components.br, {}), \"\\n\", \"길이 N인 정수 배열 A[]를 만들어 값을 저장합니다.\", _jsx(_components.br, {}), \"\\n\", \"확인한 사진에서 성형시 1을, 아닌 경우 0으로 저장합니다.\", _jsx(_components.br, {}), \"\\n\", \"이 중에서 1이 가장 먼저 나오는 1의 위치를 반환하면 됩니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"그래도 선형 시간 아닌가요?\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"위에서 나온 설명대로라면 0과 1을 저장하는 시간이 필요합니다.\", _jsx(_components.br, {}), \"\\n\", \"그리고 시간순으로 정렬하는 시간도 필요합니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 이런 시간들은 다음 이유로 이렇게 분석하지 않습니다.\"]\n      }), \"\\n\", _jsxs(_components.ol, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"정렬해두는 과정은 탐색 과정과 별개입니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"A[]를 미리 모두 계산이 아닌 확인하는 값만 사용하면 됩니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4.4 지수 시간 알고리즘\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"다항 시간 알고리즘\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"변수 N과 N^2 그리고 N의 거듭제곱들을 \", _jsx(_components.strong, {\n          children: \"다항식\"\n        }), \"이라 부릅니다.\", _jsx(_components.br, {}), \"\\n\", \"수행 횟수를 입력 크기의 반복 횟수로 표현할 수 있으면 \", _jsx(_components.strong, {\n          children: \"다항시간\"\n        }), \" 알고리즘이라 부릅니다.\", _jsx(_components.br, {}), \"\\n\", \"같은 다항 시간이라도 제곱에 따라 시간차이가 납니다.\", _jsx(_components.br, {}), \"\\n\", \"그런데도 하나로 묶는 이유는 더 오래 걸리는 알고리즘들이 있어서입니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"알러지가 심한 친구들\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"집들이에 N명의 친구를 초대하려 합니다.\", _jsx(_components.br, {}), \"\\n\", \"음식 M가지 중 친구들이 못 먹는 음식을 고려해 만들려고 합니다.\", _jsx(_components.br, {}), \"\\n\", \"각 친구가 하나씩은 먹으려면 몇 가지 음식을 해야 할까요?\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"모든 답 후보를 평가하기\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"모든 음식을 한다면 모두가 음식을 먹을 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 우리는 그보다 더 구체적으로 작은 음식을 준비하려 합니다.\", _jsx(_components.br, {}), \"\\n\", \"이럴 때 가장 먼저 떠오르는 건 모든 답을 다 확인하는 것입니다.\", _jsx(_components.br, {}), \"\\n\", \"첫 번째 음식을 만들지 말지, 그 다음도 계속 반복하는 것이지요.\", _jsx(_components.br, {}), \"\\n\", \"이런 알고리즘을 구현하기 쉬운 방법은 재귀 호출입니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"private\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"static\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"final\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"INF\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"987654321\"\n          }), \";\\n\", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 요리할 수 있는 음식의 종류의 수\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" M;\\n\", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// food번째 음식을 만들지 결정\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"selectMenu\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(LinkedList\u003cInteger\u003e menu, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" food)\"]\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (food == M) {\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (canEveryBodyEat(menu)) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" menu.size();\\n        \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 못 먹는 사람이 있으면 아주 큰 값 반환\"\n          }), \"\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" INF;\\n    }\\n    \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 이 음식을 만들지 않는 경우의 답 계산\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"answer\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" selectMenu(menu, food + \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \");\\n    \", _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \"// 이 음식을 만드는 경우의 답 계산 후 더 작은 값 선택\"\n          }), \"\\n    menu.add(food);\\n    answer = Math.min(answer, selectMenu(menu, food + \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"));\\n    menu.remove();\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" answer;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"지수 시간 알고리즘\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"답을 한 번씩 다 확인하기 때문에 시간은 답의 수에 비례합니다.\", _jsx(_components.br, {}), \"\\n\", \"M가지의 음식마다 선택하므로 답은 2^M가지입니다.\", _jsx(_components.br, {}), \"\\n\", \"그리고 canEverybodyEat의 수행시간을 곱해야합니다.\", _jsx(_components.br, {}), \"\\n\", \"10가지 경우라면 1000개 수준이지만 30개면 백만배로 늘어납니다.\", _jsx(_components.br, {}), \"\\n\", \"이렇게 시간이 배로 올라가면 \", _jsx(_components.strong, {\n          children: \"지수 시간\"\n        }), \" 알고리즘입니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"소인수 분해의 수행 시간\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"입력으로 주어지는 숫자의 개수가 아닌 크기에 따라 달라질 수도 있습니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [\"LinkedList\u003cInteger\u003e \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"factor\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(\", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" n)\"]\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (n == \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \") \\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"LinkedList\"\n          }), \"\u003c\u003e(Collections.singletonList(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"));\\n    LinkedList\u003cInteger\u003e answer = \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-class\",\n            children: \"LinkedList\"\n          }), \"\u003c\u003e();\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"div\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"2\"\n          }), \"; n \u003e \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"; ++div) {\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"while\"\n          }), \" (n % div == \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \") {\\n            n /= div;\\n            answer.add(div);\\n        }\\n    }\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" answer;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"N이 1이 될때까지 가능한 모든 수로 나누어 봅니다.\", _jsx(_components.br, {}), \"\\n\", \"N이 소수인 경우 나누기가 되지 않고 모든 수에 시도합니다.\", _jsx(_components.br, {}), \"\\n\", \"그 경우 반복문 실행 횟수는 N-1이 됩니다.\", _jsx(_components.br, {}), \"\\n\", \"이 경우 시간과 메모리 공간과의 관계를 생각해야 합니다.\", _jsx(_components.br, {}), \"\\n\", \"입력값이 클수록 숫자를 저장하는 메모리 공간이 커집니다.\", _jsx(_components.br, {}), \"\\n\", \"비트 수마다 수행시간이 두 배 증가하므로 이 경우도 지수시간입니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4.5 시간 복잡도\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"시간 복잡도\"\n        }), \"란 수행하는 기본 연산 수를 입력 크기에 대한 함수로 표현한 것입니다.\", _jsx(_components.br, {}), \"\\n\", \"기본 연산 수의 예제입니다.\"]\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"두 부호 있는 32비트 정수의 사칙연산\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"두 실수형 변수의 대소 비교\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"한 변수에 다른 변수 대입하기\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"다음은 기본적인 연산이 아닙니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"정수 배열 정렬하기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"두 문자열이 서로 같은지 확인하기\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"입력된 두 소인수 분해하기\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"시간 복잡도가 높다는 말은 입력 크기가 증가할 때 더 빠르게 증가하는 것을 의미합니다.\", _jsx(_components.br, {}), \"\\n\", \"이 말은 시간 복잡도가 낮다고 빠르다는 이야기는 아닙니다.\", _jsx(_components.br, {}), \"\\n\", \"입력의 크기가 작을 때는 시간 복잡도가 낮아도 빠를 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"입력의 종류에 따른 수행 시간의 변화\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"입력의 크기가 수행 시간을 결정하는 유일한 척도는 아닙니다.\", _jsx(_components.br, {}), \"\\n\", \"입력이 어떤 형태로 구성되어 있는지도 영향을 미칩니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"firstIndex\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(LinkedList\u003cInteger\u003e array, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" element)\"]\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \"; i \u003c array.size(); i++)\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (array.get(i) == element)\\n            \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" i;\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" -\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \";\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"최선의 수행 시간: 맨 앞에 있는 경우 1\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"평균의 수행 시간: 중간에 있는 경우 N/2\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"최악의 수행 시간: 값이 없는 경우 N\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"점근적 시간 표기: O표기\"\n        }), \"\\n시간 복잡도는 단순하게 표기하기 위해 \", _jsx(_components.strong, {\n          children: \"O표기법\"\n        }), \"으로 표기합니다.\", _jsx(_components.br, {}), \"\\n\", \"가장 빨리 증가하는 항만 남기고 나머지를 버립니다.\", _jsx(_components.br, {}), \"\\n\", \"변수가 두 개이상인 경우 가장 발리 증가하는 항만 놓습니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"항상 같은 시간이 걸리는 경우 \", _jsx(_components.strong, {\n          children: \"상수 시간\"\n        }), \" 알고리즘입니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"N에 대한 함수 f(N)이 주어질 때 f(N)=O(g(N))의 의미입니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"아주 큰 N0와 C(N0, C\u003e0)에서 적절히 선택합니다.\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mn, {\n                      children: \"0\"\n                    }), _jsx(_components.mo, {\n                      children: \"\u003c\"\n                    }), _jsx(_components.mo, {\n                      children: \"=\"\n                    }), _jsx(_components.mi, {\n                      children: \"N\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"N0 \u003c= N\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.7224em\",\n                    verticalAlign: \"-0.0391em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10903em\"\n                  },\n                  children: \"N\"\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"0\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"\u003c=\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.6833em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10903em\"\n                  },\n                  children: \"N\"\n                })]\n              })]\n            })]\n          })\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"인 모든 N에 대해\"\n      }), \"\\n\", _jsx(_components.h1, {\n        children: _jsx(_components.span, {\n          className: \"math math-inline\",\n          children: _jsxs(_components.span, {\n            className: \"katex\",\n            children: [_jsx(_components.span, {\n              className: \"katex-mathml\",\n              children: _jsx(_components.math, {\n                xmlns: \"http://www.w3.org/1998/Math/MathML\",\n                children: _jsxs(_components.semantics, {\n                  children: [_jsxs(_components.mrow, {\n                    children: [_jsx(_components.mi, {\n                      mathvariant: \"normal\",\n                      children: \"∣\"\n                    }), _jsx(_components.mi, {\n                      children: \"f\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"(\"\n                    }), _jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \")\"\n                    }), _jsx(_components.mi, {\n                      mathvariant: \"normal\",\n                      children: \"∣\"\n                    }), _jsx(_components.mo, {\n                      children: \"\u003c\"\n                    }), _jsx(_components.mo, {\n                      children: \"=\"\n                    }), _jsx(_components.mi, {\n                      children: \"C\"\n                    }), _jsx(_components.mo, {\n                      children: \"∗\"\n                    }), _jsx(_components.mi, {\n                      mathvariant: \"normal\",\n                      children: \"∣\"\n                    }), _jsx(_components.mi, {\n                      children: \"g\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \"(\"\n                    }), _jsx(_components.mi, {\n                      children: \"N\"\n                    }), _jsx(_components.mo, {\n                      stretchy: \"false\",\n                      children: \")\"\n                    }), _jsx(_components.mi, {\n                      mathvariant: \"normal\",\n                      children: \"∣\"\n                    })]\n                  }), _jsx(_components.annotation, {\n                    encoding: \"application/x-tex\",\n                    children: \"|f(N)|\u003c=C*|g(N)|\"\n                  })]\n                })\n              })\n            }), _jsxs(_components.span, {\n              className: \"katex-html\",\n              \"aria-hidden\": \"true\",\n              children: [_jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"∣\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10764em\"\n                  },\n                  children: \"f\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"(\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10903em\"\n                  },\n                  children: \"N\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \")\"\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"∣\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mrel\",\n                  children: \"\u003c=\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2778em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"0.6833em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.07153em\"\n                  },\n                  children: \"C\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mbin\",\n                  children: \"∗\"\n                }), _jsx(_components.span, {\n                  className: \"mspace\",\n                  style: {\n                    marginRight: \"0.2222em\"\n                  }\n                })]\n              }), _jsxs(_components.span, {\n                className: \"base\",\n                children: [_jsx(_components.span, {\n                  className: \"strut\",\n                  style: {\n                    height: \"1em\",\n                    verticalAlign: \"-0.25em\"\n                  }\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"∣\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.03588em\"\n                  },\n                  children: \"g\"\n                }), _jsx(_components.span, {\n                  className: \"mopen\",\n                  children: \"(\"\n                }), _jsx(_components.span, {\n                  className: \"mord mathnormal\",\n                  style: {\n                    marginRight: \"0.10903em\"\n                  },\n                  children: \"N\"\n                }), _jsx(_components.span, {\n                  className: \"mclose\",\n                  children: \")\"\n                }), _jsx(_components.span, {\n                  className: \"mord\",\n                  children: \"∣\"\n                })]\n              })]\n            })]\n          })\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"이 참이 됩니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"시간 복잡도 분석 연습\"\n        })\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"selectionSort\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(LinkedList\u003cInteger\u003e array)\"\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \"; i \u003c array.size(); i++) {\\n        \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"minIndex\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" i;\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"j\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" i + \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"; j \u003c array.size(); ++j) {\\n            \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (array.get(minIndex) \u003e array.get(j))\\n                minIndex = j;\\n        }\\n        Collections.swap(array, minIndex, i);\\n    }\\n}\\n\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"insertionSort\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(LinkedList\u003cInteger\u003e array)\"\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \"; i \u003c array.size(); ++i) {\\n        \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"j\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" i;\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"while\"\n          }), \" (j \u003e \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \" \u0026\u0026 array.get(j - \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \") \u003e array.get(j)) {\\n            Collections.swap(array, j-\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \", j);\\n            --j;\\n        }\\n    }\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"selectionSort\"\n        }), \"는 \", _jsx(_components.strong, {\n          children: \"선택 정렬\"\n        }), \"입니다.\", _jsx(_components.br, {}), \"\\n\", \"A[i...N-1]에서 가장 작은 원소를 찾아 A[i]에 대입합니다.\", _jsx(_components.br, {}), \"\\n\", \"시간 복잡도는 N-1 + N-2 ... 1 = O(N^2)입니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"insertionSort\"\n        }), \"는 \", _jsx(_components.strong, {\n          children: \"삽입정렬\"\n        }), \"입니다.\", _jsx(_components.br, {}), \"\\n\", \"전체 배열 중 정렬되어 있는 부분에 새 원소를 끼워넣습니다.\", _jsx(_components.br, {}), \"\\n\", \"최선의 경우 이미 정렬된 경우로 while이 O(1)으로 전체 O(N)입니다.\", _jsx(_components.br, {}), \"\\n\", \"최악의 경우 역순으로 정렬된 경우로 삽입정렬처럼 O(N^2)입니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"비교했을 시 삽입정렬이 대부분의 경우 더 빠릅니다.\", _jsx(_components.br, {}), \"\\n\", \"삽입정렬은 O(N^2) 정렬중 가장 빠른 것으로 알려져있습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"시간 복잡도의 분할 상환 분석\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.strong, {\n          children: \"분할 상환 분석\"\n        }), \"은 반복문의 개수보다 더 정확하게 분석하는 방법입니다.\", _jsx(_components.br, {}), \"\\n\", \"N개의 라면을 끓여 N명이 먹었습니다.\", _jsx(_components.br, {}), \"\\n\", \"더 적게 먹거나 많이 먹을 수 있지만 N개의 라면은 동일합니다.\", _jsx(_components.br, {}), \"\\n\", \"이것처럼 각 작업량은 달라도 전체가 동일할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"이 때의 평균량은 전체에서 개수를 나눈 것과 동일합니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"4.6 수행 시간 어림짐작하기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"주먹구구 법칙\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"프로그램을 작성하기 전에 어느 정도 수행시간을 짐작해야 합니다.\", _jsx(_components.br, {}), \"\\n\", \"어려운 일이지만 입력 크기만으로도 대략적으로 짐작이 가능합니다.\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"1초당 반복문이 1억이 넘어가면 시간 제한 초과 가능성이 높다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"입력의 최대크기 N이 10000이고 시간 제한이 1초라고 합시다.\", _jsx(_components.br, {}), \"\\n\", \"O(N^3)이라면 1억을 넘어갑니다.\", _jsx(_components.br, {}), \"\\n\", \"O(N^2)이라면 넘지 않지면 조건에 따라 다를 겁니다.\\n따라서 이 경우에는 충분한 여유를 두고 수행하는 것이 좋습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"고려해야할 사항\"\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"시간 복잡도가 실제 수행속도를 반영?\", _jsx(_components.br, {}), \"\\n\", \"O표기법의 경우 최고차항만 고려하므로 그 외를 생각합니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"반복문의 내부가 복잡한 경우?\", _jsx(_components.br, {}), \"\\n\", \"반복문 내부는 최대한 단순할수록 좋습니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\", _jsxs(_components.li, {\n          children: [\"\\n\", _jsxs(_components.p, {\n            children: [\"메모리 사용 패턴이 복잡한 경우?\", _jsx(_components.br, {}), \"\\n\", \"자주 사용하는 변수는 미리 캐시로 저장해 관리합니다.\"]\n          }), \"\\n\"]\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.strong, {\n          children: \"실제 적용해 보기\"\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"1차원 배열에서 연속된 부분 구간 중 합이 최대인 구간을 구합니다.\", _jsx(_components.br, {}), \"\\n\", \"[-7, 4, -3, 6, 3, -8, 3, 4]의 경우 [4, -3, 6, 3]으로 10입니다.\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"먼저 모든 구간을 순회하면서 합을 계산해봅니다.\", _jsx(_components.br, {}), \"\\n\", \"O(N^2)으로 후보 구간을 검사하고 더하는 데 O(N)으로 O(N^3)입니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"inefficientMaxSum\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(LinkedList\u003cInteger\u003e list)\"\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"size\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" list.size();\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"answer\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" Integer.MIN_VALUE;\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \"; i \u003c size; i++) {\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"j\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" i; j \u003c size; j++) {\\n            \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"sum\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n            \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"k\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" i; k \u003c= j; k++)\\n                sum += list.get(k);\\n\\n            \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (sum \u003e answer)\\n                answer = sum;\\n        }\\n    }\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" answer;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"연속된 부분의 합부분을 개선하면 O(N^2)이 됩니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"betterMaxSum\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(LinkedList\u003cInteger\u003e list)\"\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"size\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" list.size();\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"answer\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" Integer.MIN_VALUE;\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \"; i \u003c size; i++) {\\n        \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"sum\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"j\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" i; j \u003c size; j++) {\\n            sum += list.get(j);\\n\\n            \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (answer \u003c sum)\\n                answer = sum;\\n        }\\n    }\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" answer;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"분할 정복 기법을 이용하면 이보다 더 빠르게 가능합니다.\", _jsx(_components.br, {}), \"\\n\", \"우선 절반을 잘라 왼쪽과 오른쪽 배열로 나눕니다.\", _jsx(_components.br, {}), \"\\n\", \"재귀 호출과 탐욕법을 이용해 계산합니다.\", _jsx(_components.br, {}), \"\\n\", \"알고리즘 시간 복잡도는 O(NlogN)입니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"fastMaxSum\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(LinkedList\u003cInteger\u003e list, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" lo, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" hi)\"]\n          }), \" {\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"if\"\n          }), \" (lo == hi)\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" list.get(lo);\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"mid\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" (lo + hi) / \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"2\"\n          }), \";\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"left\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" MIN, right = MIN, sum = \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" mid; i \u003e= lo; --i) {\\n        sum += list.get(i);\\n        left = Math.max(left, sum);\\n    }\\n\\n    sum = \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"i\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" mid + \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"; i \u003c= hi; ++i) {\\n        sum += list.get(i);\\n        right = Math.max(right, sum);\\n    }\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"single\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" Math.max(fastMaxSum(list, lo, mid),\\n            fastMaxSum(list, mid + \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \", hi));\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" Math.max(left + right, single);\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"마지막으로 동적계획법으로 해결합니다.\", _jsx(_components.br, {}), \"\\n\", \"A[i]를 오른쪽 끝으로 갖는 최대합 maxAt(i)를 정의합니다.\"]\n      }), \"\\n\", _jsxs(_components.blockquote, {\n        children: [\"\\n\", _jsx(_components.p, {\n          children: \"maxAt(i) = max(0, maxAt(i=1)) + A[i]\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"하나의 반복문만 갖고있으므로 O(N)이 됩니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title hljs-function\",\n            children: \"fastestMaxSum\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(LinkedList\u003cInteger\u003e list)\"\n          }), \"{\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"answer\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" Integer.MIN_VALUE;\\n    \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-variable\",\n            children: \"partialSum\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-operator\",\n            children: \"=\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \";\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (Integer i : list) {\\n        partialSum = Math.max(partialSum, \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), \") + i;\\n        answer = max(partialSum, answer);\\n    }\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" answer;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"O(N^3)의 경우 2560 입력까지 1초 안에 풀 수 있습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"O(N^2)의 경우 40960 입력까지 1초 안에 풀 수 있습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"O(NlogN)의 경우 2천만 입력까지 1초 안에 풀 수 있습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"O(N)의 경우 1억 6천만 입력까지 1초 안에 풀 수 있습니다.\"\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"문제-해결-전략-4"},"buildId":"C_hZnuebhS8O93_BuECK4","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>