<!DOCTYPE html><html><head><title class="jsx-b1d8888b598bb747">Ordinary</title><meta charSet="utf-8" class="jsx-b1d8888b598bb747"/><meta name="viewport" content="width=device-width, initial-scale=1" class="jsx-b1d8888b598bb747"/><meta name="description" content="Blog" class="jsx-b1d8888b598bb747"/><link rel="icon" href="/favicon.ico" class="jsx-b1d8888b598bb747"/><meta name="next-head-count" content="5"/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/_next/static/chunks/polyfills-5cd94c89d3acac5f.js"></script><script src="/_next/static/chunks/webpack-9b312e20a4e32339.js" defer=""></script><script src="/_next/static/chunks/framework-82797a600c079ab5.js" defer=""></script><script src="/_next/static/chunks/main-a054bbf31fb90f6a.js" defer=""></script><script src="/_next/static/chunks/pages/_app-c0e324b3689a0aa4.js" defer=""></script><script src="/_next/static/chunks/pages/posts/%5Bid%5D-7a23590d81cced59.js" defer=""></script><script src="/_next/static/83TotyA5SeDu1ijUHwh-Y/_buildManifest.js" defer=""></script><script src="/_next/static/83TotyA5SeDu1ijUHwh-Y/_ssgManifest.js" defer=""></script><script src="/_next/static/83TotyA5SeDu1ijUHwh-Y/_middlewareManifest.js" defer=""></script><style id="__jsx-b1d8888b598bb747">header.jsx-b1d8888b598bb747{display:grid;
color:#0070f3;
background-color:#1e1e1e;
border-bottom:1px solid #e5e5e5;
grid-template-columns:1fr 1fr;
grid-template-rows:5rem;
position:fixed;
width:100%;
left:25%;
height:5rem;
z-index:300;
opacity:0.95}
.home.jsx-b1d8888b598bb747{font-size:2.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-text-decoration:none;
text-decoration:none}
.about.jsx-b1d8888b598bb747{font-size:1.5rem;
display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-flex-direction:row-reverse;
-ms-flex-direction:row-reverse;
flex-direction:row-reverse}
.category.jsx-b1d8888b598bb747{display:-webkit-box;
display:-webkit-flex;
display:-ms-flexbox;
display:flex;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center;
-webkit-flex-direction:row-reverse;
-ms-flex-direction:row-reverse;
flex-direction:row-reverse}
@media (min-width:720px) {header.jsx-b1d8888b598bb747{max-width:50rem;
padding:0 2rem;
margin:0 auto}}</style><style id="__jsx-506446869">a.jsx-506446869{display:block;
margin-left:0px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:140px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-506446869:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-2105002209">a.jsx-2105002209{display:block;
margin-left:20px;
padding-left:0.3rem;
padding-top:0.5rem;
padding-bottom:0.5rem;
width:120px;
-webkit-text-decoration:none;
text-decoration:none;
color:#FFF;
font-size:8pt;
border-bottom:1px solid #ccc;
white-space:nowrap;
text-overflow:ellipsis;
overflow:hidden}
[aria-current].jsx-2105002209:not([aria-current="false"]){font-weight:bold;
color:red}</style><style id="__jsx-ba6267904dd67a4c">aside.jsx-ba6267904dd67a4c{position:absolute;
right:0;
padding-left:200px;
width:200px;
height:100%}
nav.jsx-ba6267904dd67a4c{top:200px;
padding:0 0 0 10px;
display:inline-block;
position:-webkit-sticky;
position:sticky}
ul.jsx-ba6267904dd67a4c{list-style:none}
@media (max-width:1080px) {aside.jsx-ba6267904dd67a4c{visibility:hidden}}</style><style id="__jsx-66c5b3c4cf32749c">img.jsx-66c5b3c4cf32749c{display:inline;
vertical-align:middle}
span.jsx-66c5b3c4cf32749c{color:#BBBBBB;
padding-left:0.5rem;
display:inline;
vertical-align:middle}</style><style id="__jsx-52f56faf7d264d51">a.jsx-52f56faf7d264d51{color:#62c8f3}</style><style id="__jsx-477b66404f654573">article.jsx-477b66404f654573{display:block;
margin:0 auto;
padding:0 1rem}
h1.jsx-477b66404f654573{font-size:30pt;
margin-bottom:5px}
.head.jsx-477b66404f654573{margin-bottom:2rem}
.container.jsx-477b66404f654573{width:100%;
max-width:720px;
margin:0 auto;
line-height:1.625}
@media (min-width:720px) {.container.jsx-477b66404f654573{padding:0 2rem;
margin:0 auto}}
@media (max-width:800px) {aside.jsx-477b66404f654573{position:static;
height:auto}}</style><style id="__jsx-243dc63d52768b84">.content{max-width:40rem}</style><style id="__jsx-acfe784ee19a4513">.github.jsx-acfe784ee19a4513{font-size:1rem;
display:inline-block;
text-align:center;
width:8rem;
height:2rem;
margin:0 auto}
.github.jsx-acfe784ee19a4513:hover{background-color:#4d4747;
box-shadow:0 0 0.6rem rgb(0 0 0 / 60%);
-webkit-transform:translate(0, -0.4rem);
-moz-transform:translate(0, -0.4rem);
-ms-transform:translate(0, -0.4rem);
transform:translate(0, -0.4rem)}</style><style id="__jsx-75cef58db113c542">footer.jsx-75cef58db113c542{height:6rem;
padding:0 2rem;
text-align:center;
margin:0 auto;
display:grid;
grid-template-columns:1fr 1fr}
span.jsx-75cef58db113c542{font-size:1rem;
padding:2rem 0}
@media (min-width:720px) {footer.jsx-75cef58db113c542{max-width:50rem;
padding:0 2rem;
margin:0 auto}}</style><style id="__jsx-fcc9ccaaf982543f">*{color:white;
box-sizing:border-box}
html, body{padding:0;
margin:0;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
background:#1e1e1e}
a{color:inherit;
-webkit-text-decoration:none;
text-decoration:none}
main{background:#1e1e1e;
min-height:100vh;
height:100%;
padding:8rem 0 0 0;
-webkit-align-items:center;
-webkit-box-align:center;
-ms-flex-align:center;
align-items:center}
strong{color:#a964a7}
code{color:#3fd0c0;
font-weight:bold;
font-family:-apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif}
blockquote{border:3px solid #27a9e3;
margin-left:0;
margin-right:0;
padding-left:20px;
padding-right:20px;
border-left:12px solid #27a9e3;
border-radius:5px}
article{position:relative}
.hljs{font-size:0.9rem;
background:#333;
font-family:SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
display:block;
color:#fff;
border-radius:5px;
overflow:auto;
padding:1em;
margin:0.6em}
.hljs-doctag, .hljs-meta-keyword, .hljs-name, .hljs-strong{font-weight:bold}
.hljs-code, .hljs-emphasis{font-style:italic}
.hljs-section, .hljs-tag{color:#62c8f3}
.hljs-selector-class, .hljs-selector-id, .hljs-template-variable, .hljs-variable{color:#ade5fc}
.hljs-meta-string, .hljs-string{color:#a2fca2}
.hljs-attr, .hljs-quote, .hljs-selector-attr{color:#7bd694}
.hljs-tag .hljs-attr{color:inherit}
.hljs-attribute, .hljs-title, .hljs-type{color:#ffa}
.hljs-number, .hljs-symbol{color:#d36363}
.hljs-bullet, .hljs-template-tag{color:#b8d8a2}
.hljs-built_in, .hljs-keyword, .hljs-literal, .hljs-selector-tag{color:#fcc28c}
.hljs-code, .hljs-comment, .hljs-formula{color:#888}
.hljs-link, .hljs-selector-pseudo, .hljs-regexp{color:#c6b4f0}
.hljs-meta{color:#fc9b9b}
.hljs-deletion{background:#fc9b9b;
color:#333}
.hljs-addition{background:#a2fca2;
color:#333}
.hljs-operator, .hljs-params, .hljs-property, .hljs-punctuation{}
.hljs-subst{color:#fff}
.hljs a{color:inherit}
.hljs a:focus, .hljs a:hover{color:inherit;
text-decoration:underline}
.hljs mark{background:#555;
color:inherit}</style></head><body><div id="__next" data-reactroot=""><header class="jsx-b1d8888b598bb747"><div class="jsx-b1d8888b598bb747 home"><a href="/">Ordinary</a></div><div class="jsx-b1d8888b598bb747 about"><a class="jsx-b1d8888b598bb747" href="/about">About</a></div></header><main><div class="jsx-243dc63d52768b84"><div class="jsx-477b66404f654573"><article class="jsx-477b66404f654573 container"><aside class="jsx-ba6267904dd67a4c"><nav class="jsx-ba6267904dd67a4c"><ul class="jsx-ba6267904dd67a4c"><li class="jsx-506446869"><a href="#대량의 데이터를 Insert할 때" class="jsx-506446869"> <!-- -->대량의 데이터를 Insert할 때</a></li><li class="jsx-2105002209"><a href="#트랜잭션을 하나로 묶기" class="jsx-2105002209"> <!-- -->트랜잭션을 하나로 묶기</a></li><li class="jsx-2105002209"><a href="#Bulk insert 사용하기" class="jsx-2105002209"> <!-- -->Bulk insert 사용하기</a></li><li class="jsx-506446869"><a href="#JPA Bulk Insert" class="jsx-506446869"> <!-- -->JPA Bulk Insert</a></li><li class="jsx-2105002209"><a href="#Batch Size 설정" class="jsx-2105002209"> <!-- -->Batch Size 설정</a></li><li class="jsx-2105002209"><a href="#order_inserts, order_updates 설정" class="jsx-2105002209"> <!-- -->order_inserts, order_updates 설정</a></li><li class="jsx-2105002209"><a href="#mysql datasource url 설정" class="jsx-2105002209"> <!-- -->mysql datasource url 설정</a></li><li class="jsx-506446869"><a href="#Identity 전략 문제" class="jsx-506446869"> <!-- -->Identity 전략 문제</a></li><li class="jsx-2105002209"><a href="#해결책 1. Id 자동 생성 전략 변경" class="jsx-2105002209"> <!-- -->해결책 1. Id 자동 생성 전략 변경</a></li><li class="jsx-2105002209"><a href="#해결책 2: JDBC 사용하기" class="jsx-2105002209"> <!-- -->해결책 2: JDBC 사용하기</a></li><li class="jsx-506446869"><a href="#결론" class="jsx-506446869"> <!-- -->결론</a></li><li class="jsx-2105002209"><a href="#참고" class="jsx-2105002209"> <!-- -->참고</a></li></ul></nav></aside><div class="jsx-477b66404f654573 head"><h1 class="jsx-477b66404f654573">JPA Bulk Insert</h1><div class="jsx-66c5b3c4cf32749c"><img src="/profile.png" alt="profile" class="jsx-66c5b3c4cf32749c"/><span class="jsx-66c5b3c4cf32749c">ordilov<!-- --> / <!-- -->2022. 5. 14</span></div></div><div id="대량의 데이터를 Insert할 때"><h2>대량의 데이터를 Insert할 때</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">적은 데이터를 insert 한다면 DB와 네트워크 연결이 시간이 제일 오래 소요되기 때문에 개수가 늘어도 큰 차이가 나지 않습니다.
하지만 대량의 데이터를 입력한다면 방법에 따라 성능이 많이 차이날 수 있습니다.
성능을 향상시키기 위한 기본적인 방법은 다음과 같습니다.</p>
<div id="트랜잭션을 하나로 묶기"><h3>트랜잭션을 하나로 묶기</h3></div>
<pre><code class="hljs language-sql"><span class="hljs-keyword">start</span> transaction;
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1 (id, name) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name1&#x27;</span>);
<span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1 (id, name) <span class="hljs-keyword">values</span> (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;name2&#x27;</span>);
<span class="hljs-keyword">commit</span>;
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">트랜잭션을 열고 닫는 데도 시간이 들기 때문에 작업을 트랜잭션 하나로 묶어주면 조금이라도 성능이 올라갑니다.</p>
<div id="Bulk insert 사용하기"><h3>Bulk insert 사용하기</h3></div>
<pre><code class="hljs language-sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> table1 (id, name) <span class="hljs-keyword">values</span> (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;name1&#x27;</span>), (<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;name2&#x27;</span>);
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">MySQL에서는 Bulk Insert라고 불리는 방법으로, 여러 row를 한 번에 입력하는 방법입니다.
이렇게 여러 row를 입력하는 경우 unique 제약조건이나, 외래 키 제약조건을 임시적으로 꺼두면 성능이 더 올라갈 수 있습니다.</p>
<pre><code class="hljs language-ini">SET <span class="hljs-attr">unique_checks</span>=<span class="hljs-number">0</span><span class="hljs-comment">;</span>
SET <span class="hljs-attr">foreign_key_checks</span>=<span class="hljs-number">0</span><span class="hljs-comment">;</span>

... insert

SET <span class="hljs-attr">unique_checks</span>=<span class="hljs-number">1</span><span class="hljs-comment">;</span>
SET <span class="hljs-attr">foreign_key_checks</span>=<span class="hljs-number">1</span><span class="hljs-comment">;</span>
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">여러 row를 한 번에 insert하는 경우에 데이터 패킷의 크기가 너무 커서 못 받을 수 있습니다.</p>
<pre><code class="hljs language-sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">global</span> variables <span class="hljs-keyword">like</span> <span class="hljs-string">&#x27;max_allowed_packet&#x27;</span>
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">이 때 필요한만큼 <code>max_allowed_packet</code> 크기를 키워주면 됩니다.</p>
<div id="JPA Bulk Insert"><h2>JPA Bulk Insert</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">JPA에는 명시적으로 bulk insert를 하는 방법이 존재하지 않습니다. JPA에서 insert하는 메소드는 persist() 하나로, 컬렉션을
한 번에 저장하는 방법은 존재하지 않습니다. 하지만 Data JPA의 JpaRepository에서는 saveAll() 메소드가 존재합니다.</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Transactional</span>
<span class="hljs-meta">@Override</span>
<span class="hljs-keyword">public</span> &lt;S <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; List&lt;S&gt; <span class="hljs-title function_">saveAll</span><span class="hljs-params">(Iterable&lt;S&gt; entities)</span> {

    Assert.notNull(entities, <span class="hljs-string">&quot;Entities must not be null!&quot;</span>);

    List&lt;S&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();

    <span class="hljs-keyword">for</span> (S entity : entities) {
        result.add(save(entity));
    }

    <span class="hljs-keyword">return</span> result;
}
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">내부 구현을 살펴보면 saveAll() 메소드도 persist를 반복문으로 처리하는 것으로 다른 점이 없어 보입니다.
그럼에도 insert를 여러 개 할 경우 save() 대신 saveAll()을 써야하는 이유가 있습니다.</p>
<ul>
<li>메소드를 여러번 호출하는 것과 한 번 호출하는 것만으로도 차이가 있습니다.</li>
<li>@Transactional 어노테이션으로 새로운 트랜잭션 호출에 따른 시간 차이가 있습니다.</li>
</ul>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">save() 메소드는 @Transactional 어노테이션이 존재합니다.
@Transactional 의 기본 전파 타입은 <code>REQUIRED</code>로 호출 시 새로운 트랜잭션이 생성됩니다.
따라서 호출 시마다 트랜잭션을 생성하게 되어 위에서 설명한 <strong>트랜잭션을 하나로 묶기</strong>조차 안되는 상태가 됩니다.
반면 saveAll()을 사용하는 경우 클래스 내부에서 save()를 호출하게 되는데 이 경우 Self-Invocation이 발생하여 트랜잭션이 생성되지 않습니다.
따라서 saveAll() 메소드의 @Transactional 어노테이션의 트랜잭션만 생성되어 트랜잭션이 하나로 묶이게 됩니다.
이 결과로 1만건만 테스트해봐도 42초와 5초 차이로 큰 성능 차이가 나는 것을 확인할 수 있습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/jpa/save_saveall.png" alt="save saveAll 차이"/></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">하지만 hibernate에서 생성되는 sql문은 여전히 여러 개의 insert문을 보내는 방식입니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/jpa/insert_many.png" alt="insert 여러번"/></p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">bulk insert로 sql문을 하나로 보내 성능을 향상시키려면 몇 가지 설정이 더 필요합니다.</p>
<div id="Batch Size 설정"><h3>Batch Size 설정</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><code>jdbc batch_size</code> 값을 설정하면 크기만큼 sql문을 모아서 한 번에 DB 서버에 요청합니다.
<code>batch_size</code>가 정해져있는 이유는 모든 엔티티가 영속성 컨텍스트에 올라가면 <code>OutOfMemoryException</code>이 발생할 수 있어
batch_size를 기준으로 flush()와 clear() 작업을 진행해서 입니다.</p>
<pre><code class="hljs language-yaml"><span class="hljs-attr">spring.jpa.properties.hibernate.jdbc.batch_size:</span> <span class="hljs-number">20</span>
</code></pre>
<div id="order_inserts, order_updates 설정"><h3>order_inserts, order_updates 설정</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">같은 테이블에 대한 insert나 update가 모여 있지 않으면 batch 처리를 할 수 없습니다.
<code>order_inserts</code> 와 <code>order_updates</code>를 설졍해주면 같은 테이블에 insert끼리 묶어줍니다.</p>
<pre><code class="hljs language-yml"><span class="hljs-attr">spring.jpa.properties.hibernate.order_inserts:</span> <span class="hljs-literal">true</span>
<span class="hljs-attr">spring.jpa.properties.hibernate.order_updates:</span> <span class="hljs-literal">true</span>
</code></pre>
<div id="mysql datasource url 설정"><h3>mysql datasource url 설정</h3></div>
<pre><code class="hljs language-bash">spring.datasource.url: jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=<span class="hljs-literal">true</span>&amp;profileSQL=<span class="hljs-literal">true</span>&amp;logger=Slf4JLogger
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><code>rewriteBatchedStatements</code> 옵션을 적용해주면 여러 insert 쿼리를 bulk insert 방식으로 재작성해줍니다.
이렇게 재작성된 쿼리는 Hibernate에 찍히는 SQL 로그와 달라지는데 바뀐 쿼리를 보고 싶은 경우
<code>profileSQL=true</code> 를 추가해주면 실제 mysql 쿼리를 볼 수 있습니다.</p>
<pre><code class="hljs language-sql">Hibernate: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">member</span> (name, id) <span class="hljs-keyword">values</span> (?, ?)
Hibernate: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">member</span> (name, id) <span class="hljs-keyword">values</span> (?, ?)
Hibernate: <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">member</span> (name, id) <span class="hljs-keyword">values</span> (?, ?)
Mon May <span class="hljs-number">16</span> <span class="hljs-number">17</span>:<span class="hljs-number">08</span>:<span class="hljs-number">39</span> KST <span class="hljs-number">2022</span> INFO: [QUERY] <span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> <span class="hljs-keyword">member</span> (name, id) <span class="hljs-keyword">values</span> (<span class="hljs-string">&#x27;0&#x27;</span>, <span class="hljs-number">1</span>),(<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-number">2</span>),(<span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-number">3</span>)
</code></pre>
<div id="Identity 전략 문제"><h2>Identity 전략 문제</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">MySQL에서 Id 자동 생성 전략을 사용하는 경우 Identity 전략을 주로 사용합니다.
문제는 Identity 전략의 경우 다음 Id를 받아오기 위해서 insert를 해야하기 때문에 bulk insert 작업을 지원하지 않습니다.
따라서 bulk insert를 사용하려면 2가지 해결책이 있습니다.</p>
<div id="해결책 1. Id 자동 생성 전략 변경"><h3>해결책 1. Id 자동 생성 전략 변경</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">Id 자동 전략을 Sequence 전략이나 Table 전략으로 변경하면 bulk insert가 가능합니다.
하지만 단순히 Sequence 전략으로 바꾸기만 하면 성능은 더 안 좋아지게 됩니다.
Sequence 전략을 사용하면 insert하기 전에 다음 id를 찾는 select문과 다음 id를 설정하는 update문이 나가게 됩니다.</p>
<pre><code class="hljs language-vbnet"><span class="hljs-symbol">Hibernate:</span> <span class="hljs-keyword">select</span> next_val <span class="hljs-keyword">as</span> id_val <span class="hljs-keyword">from</span> hibernate_sequence <span class="hljs-keyword">for</span> update
<span class="hljs-symbol">Hibernate:</span> update hibernate_sequence <span class="hljs-keyword">set</span> next_val= ? <span class="hljs-keyword">where</span> next_val=?
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">기본 id 생성은 하나씩 생성되기 때문에 insert하기 전에 매번 두 개의 쿼리가 더 나가게 됩니다.
따라서 생성해서 사용할 Id 범위를 지정해줘야합니다.</p>
<pre><code class="hljs language-java"><span class="hljs-meta">@Id</span>
<span class="hljs-meta">@GenericGenerator(
        name = &quot;sequence-generator&quot;,
        strategy = &quot;org.hibernate.id.enhanced.SequenceStyleGenerator&quot;,
        parameters = {
                @Parameter(name = &quot;sequence_name&quot;, value = &quot;hibernate_sequence&quot;),
                @Parameter(name = &quot;optimizer&quot;, value = &quot;pooled&quot;),
                @Parameter(name = &quot;initial_value&quot;, value = &quot;1&quot;),
                @Parameter(name = &quot;increment_size&quot;, value = &quot;100&quot;)
        }
)</span>
<span class="hljs-meta">@GeneratedValue(
        strategy = GenerationType.SEQUENCE,
        generator = &quot;SequenceGenerator&quot;
)</span>
<span class="hljs-keyword">private</span> Long id;
</code></pre>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><code>increment_size</code>를 지정해주어 크기만큼의 id는 조회나 업데이트 없이 생성할 수 있게 됩니다.</p>
<div id="해결책 2: JDBC 사용하기"><h3>해결책 2: JDBC 사용하기</h3></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">JPA를 꼭 써야만 하는 게 아니라면 bulk insert 작업을 JDBC로 분리할 수도 있습니다.
jdbcTemplate의 batchUpdate() 메서드를 사용해 bulk insert가 가능해집니다.</p>
<pre><code class="hljs language-java">jdbcTemplate.batchUpdate(<span class="hljs-string">&quot;INSERT INTO MEMBER(`NAME`) VALUES(?)&quot;</span>,
<span class="hljs-keyword">new</span> <span class="hljs-title class_">BatchPreparedStatementSetter</span>() {
    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setValues</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-type">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException {
        ps.setString(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;member&quot;</span> + i);
    }

    <span class="hljs-meta">@Override</span>
    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBatchSize</span><span class="hljs-params">()</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-number">1000</span>;
    }
});
</code></pre>
<div id="결론"><h2>결론</h2></div>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}">JPA로만 작성한다면 키 자동 생성 전략을 바꾸는 게 좋습니다.
하지만 JDBC를 사용한다면 키 자동 생성 전략을 그대로 사용할 수 있고 성능도 전반적으로 더 빨랐습니다.
다른 DB를 쓰거나 설정이 달라진다면 결과가 다를 수 있지만 MySQL 기준으로 데이터 크기가 커질수록
JDBC 쪽이 성능이 더 좋은 것을 확인할 수 있었습니다.
물론 두 방법 어느 쪽을 사용하더라도 사용하지 않는 쪽에 비해 큰 성능 차이를 확인할 수 있습니다.</p>
<p class=".Paragraph.jsx-c13bd6d988b6c83{line-height:1.625}"><img class="content" src="/image/jpa/insert_difference.png" alt="성능 차이"/></p>
<div id="참고"><h3>참고</h3></div>
<ul>
<li><a class="jsx-52f56faf7d264d51">https://jaehun2841.github.io/2020/11/22/2020-11-22-spring-data-jpa-batch-insert/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0</a></li>
<li><a class="jsx-52f56faf7d264d51">https://homoefficio.github.io/2020/01/25/Spring-Data%EC%97%90%EC%84%9C-Batch-Insert-%EC%B5%9C%EC%A0%81%ED%99%94/</a></li>
<li><a class="jsx-52f56faf7d264d51">https://www.baeldung.com/spring-data-save-saveall</a></li>
</ul></article></div></div></main><footer class="jsx-75cef58db113c542"><span class="jsx-75cef58db113c542"><a href="https://github.com/ordilov" class="jsx-acfe784ee19a4513 github">Github 🔗</a></span><span class="jsx-75cef58db113c542">Copyright © Ordilov</span></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"metadata":{"layout":"post","title":"JPA Bulk Insert","date":"2022-05-15 00:01:00 +0900","category":"spring","tags":["backend"],"keywords":["backend"],"description":"JPA에서 MySQL의 Bulk Insert를 하는 법을 알아봅니다.","id":"JPA Bulk Insert"},"mdxSource":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      h2: \"h2\",\n      p: \"p\",\n      h3: \"h3\",\n      pre: \"pre\",\n      code: \"code\",\n      span: \"span\",\n      ul: \"ul\",\n      li: \"li\",\n      strong: \"strong\",\n      img: \"img\",\n      a: \"a\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.h2, {\n        children: \"대량의 데이터를 Insert할 때\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"적은 데이터를 insert 한다면 DB와 네트워크 연결이 시간이 제일 오래 소요되기 때문에 개수가 늘어도 큰 차이가 나지 않습니다.\\n하지만 대량의 데이터를 입력한다면 방법에 따라 성능이 많이 차이날 수 있습니다.\\n성능을 향상시키기 위한 기본적인 방법은 다음과 같습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"트랜잭션을 하나로 묶기\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-sql\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"start\"\n          }), \" transaction;\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"insert\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"into\"\n          }), \" table1 (id, name) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"values\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'name1'\"\n          }), \");\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"insert\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"into\"\n          }), \" table1 (id, name) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"values\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"2\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'name2'\"\n          }), \");\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"commit\"\n          }), \";\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"트랜잭션을 열고 닫는 데도 시간이 들기 때문에 작업을 트랜잭션 하나로 묶어주면 조금이라도 성능이 올라갑니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Bulk insert 사용하기\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-sql\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"insert\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"into\"\n          }), \" table1 (id, name) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"values\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'name1'\"\n          }), \"), (\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"2\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'name2'\"\n          }), \");\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"MySQL에서는 Bulk Insert라고 불리는 방법으로, 여러 row를 한 번에 입력하는 방법입니다.\\n이렇게 여러 row를 입력하는 경우 unique 제약조건이나, 외래 키 제약조건을 임시적으로 꺼두면 성능이 더 올라갈 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-ini\",\n          children: [\"SET \", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"unique_checks\"\n          }), \"=\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \";\"\n          }), \"\\nSET \", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"foreign_key_checks\"\n          }), \"=\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"0\"\n          }), _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \";\"\n          }), \"\\n\\n... insert\\n\\nSET \", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"unique_checks\"\n          }), \"=\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \";\"\n          }), \"\\nSET \", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"foreign_key_checks\"\n          }), \"=\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), _jsx(_components.span, {\n            className: \"hljs-comment\",\n            children: \";\"\n          }), \"\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"여러 row를 한 번에 insert하는 경우에 데이터 패킷의 크기가 너무 커서 못 받을 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-sql\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"show\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"global\"\n          }), \" variables \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"like\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'max_allowed_packet'\"\n          }), \"\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"이 때 필요한만큼 \", _jsx(_components.code, {\n          children: \"max_allowed_packet\"\n        }), \" 크기를 키워주면 됩니다.\"]\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"JPA Bulk Insert\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"JPA에는 명시적으로 bulk insert를 하는 방법이 존재하지 않습니다. JPA에서 insert하는 메소드는 persist() 하나로, 컬렉션을\\n한 번에 저장하는 방법은 존재하지 않습니다. 하지만 Data JPA의 JpaRepository에서는 saveAll() 메소드가 존재합니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Transactional\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Override\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \u003cS \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"extends\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title class_\",\n            children: \"T\"\n          }), \"\u003e List\u003cS\u003e \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"saveAll\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"(Iterable\u003cS\u003e entities)\"\n          }), \" {\\n\\n    Assert.notNull(entities, \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"Entities must not be null!\\\"\"\n          }), \");\\n\\n    List\u003cS\u003e result = \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title class_\",\n            children: \"ArrayList\"\n          }), \"\u003c\u003e();\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" (S entity : entities) {\\n        result.add(save(entity));\\n    }\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" result;\\n}\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"내부 구현을 살펴보면 saveAll() 메소드도 persist를 반복문으로 처리하는 것으로 다른 점이 없어 보입니다.\\n그럼에도 insert를 여러 개 할 경우 save() 대신 saveAll()을 써야하는 이유가 있습니다.\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: \"메소드를 여러번 호출하는 것과 한 번 호출하는 것만으로도 차이가 있습니다.\"\n        }), \"\\n\", _jsx(_components.li, {\n          children: \"@Transactional 어노테이션으로 새로운 트랜잭션 호출에 따른 시간 차이가 있습니다.\"\n        }), \"\\n\"]\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"save() 메소드는 @Transactional 어노테이션이 존재합니다.\\n@Transactional 의 기본 전파 타입은 \", _jsx(_components.code, {\n          children: \"REQUIRED\"\n        }), \"로 호출 시 새로운 트랜잭션이 생성됩니다.\\n따라서 호출 시마다 트랜잭션을 생성하게 되어 위에서 설명한 \", _jsx(_components.strong, {\n          children: \"트랜잭션을 하나로 묶기\"\n        }), \"조차 안되는 상태가 됩니다.\\n반면 saveAll()을 사용하는 경우 클래스 내부에서 save()를 호출하게 되는데 이 경우 Self-Invocation이 발생하여 트랜잭션이 생성되지 않습니다.\\n따라서 saveAll() 메소드의 @Transactional 어노테이션의 트랜잭션만 생성되어 트랜잭션이 하나로 묶이게 됩니다.\\n이 결과로 1만건만 테스트해봐도 42초와 5초 차이로 큰 성능 차이가 나는 것을 확인할 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/jpa/save_saveall.png\",\n          alt: \"save saveAll 차이\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"하지만 hibernate에서 생성되는 sql문은 여전히 여러 개의 insert문을 보내는 방식입니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/jpa/insert_many.png\",\n          alt: \"insert 여러번\"\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"bulk insert로 sql문을 하나로 보내 성능을 향상시키려면 몇 가지 설정이 더 필요합니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"Batch Size 설정\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"jdbc batch_size\"\n        }), \" 값을 설정하면 크기만큼 sql문을 모아서 한 번에 DB 서버에 요청합니다.\\n\", _jsx(_components.code, {\n          children: \"batch_size\"\n        }), \"가 정해져있는 이유는 모든 엔티티가 영속성 컨텍스트에 올라가면 \", _jsx(_components.code, {\n          children: \"OutOfMemoryException\"\n        }), \"이 발생할 수 있어\\nbatch_size를 기준으로 flush()와 clear() 작업을 진행해서 입니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-yaml\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"spring.jpa.properties.hibernate.jdbc.batch_size:\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"20\"\n          }), \"\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"order_inserts, order_updates 설정\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"같은 테이블에 대한 insert나 update가 모여 있지 않으면 batch 처리를 할 수 없습니다.\\n\", _jsx(_components.code, {\n          children: \"order_inserts\"\n        }), \" 와 \", _jsx(_components.code, {\n          children: \"order_updates\"\n        }), \"를 설졍해주면 같은 테이블에 insert끼리 묶어줍니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-yml\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"spring.jpa.properties.hibernate.order_inserts:\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-literal\",\n            children: \"true\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-attr\",\n            children: \"spring.jpa.properties.hibernate.order_updates:\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-literal\",\n            children: \"true\"\n          }), \"\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"mysql datasource url 설정\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-bash\",\n          children: [\"spring.datasource.url: jdbc:mysql://localhost:3306/test?rewriteBatchedStatements=\", _jsx(_components.span, {\n            className: \"hljs-literal\",\n            children: \"true\"\n          }), \"\u0026profileSQL=\", _jsx(_components.span, {\n            className: \"hljs-literal\",\n            children: \"true\"\n          }), \"\u0026logger=Slf4JLogger\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"rewriteBatchedStatements\"\n        }), \" 옵션을 적용해주면 여러 insert 쿼리를 bulk insert 방식으로 재작성해줍니다.\\n이렇게 재작성된 쿼리는 Hibernate에 찍히는 SQL 로그와 달라지는데 바뀐 쿼리를 보고 싶은 경우\\n\", _jsx(_components.code, {\n          children: \"profileSQL=true\"\n        }), \" 를 추가해주면 실제 mysql 쿼리를 볼 수 있습니다.\"]\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-sql\",\n          children: [\"Hibernate: \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"insert\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"into\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"member\"\n          }), \" (name, id) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"values\"\n          }), \" (?, ?)\\nHibernate: \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"insert\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"into\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"member\"\n          }), \" (name, id) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"values\"\n          }), \" (?, ?)\\nHibernate: \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"insert\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"into\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"member\"\n          }), \" (name, id) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"values\"\n          }), \" (?, ?)\\nMon May \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"16\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"17\"\n          }), \":\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"08\"\n          }), \":\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"39\"\n          }), \" KST \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"2022\"\n          }), \" INFO: [QUERY] \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"insert\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"into\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"member\"\n          }), \" (name, id) \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"values\"\n          }), \" (\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'0'\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \"),(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'1'\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"2\"\n          }), \"),(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"'2'\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"3\"\n          }), \")\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"Identity 전략 문제\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"MySQL에서 Id 자동 생성 전략을 사용하는 경우 Identity 전략을 주로 사용합니다.\\n문제는 Identity 전략의 경우 다음 Id를 받아오기 위해서 insert를 해야하기 때문에 bulk insert 작업을 지원하지 않습니다.\\n따라서 bulk insert를 사용하려면 2가지 해결책이 있습니다.\"\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"해결책 1. Id 자동 생성 전략 변경\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"Id 자동 전략을 Sequence 전략이나 Table 전략으로 변경하면 bulk insert가 가능합니다.\\n하지만 단순히 Sequence 전략으로 바꾸기만 하면 성능은 더 안 좋아지게 됩니다.\\nSequence 전략을 사용하면 insert하기 전에 다음 id를 찾는 select문과 다음 id를 설정하는 update문이 나가게 됩니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-vbnet\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-symbol\",\n            children: \"Hibernate:\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"select\"\n          }), \" next_val \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"as\"\n          }), \" id_val \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"from\"\n          }), \" hibernate_sequence \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"for\"\n          }), \" update\\n\", _jsx(_components.span, {\n            className: \"hljs-symbol\",\n            children: \"Hibernate:\"\n          }), \" update hibernate_sequence \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"set\"\n          }), \" next_val= ? \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"where\"\n          }), \" next_val=?\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"기본 id 생성은 하나씩 생성되기 때문에 insert하기 전에 매번 두 개의 쿼리가 더 나가게 됩니다.\\n따라서 생성해서 사용할 Id 범위를 지정해줘야합니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [_jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Id\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@GenericGenerator(\\n        name = \\\"sequence-generator\\\",\\n        strategy = \\\"org.hibernate.id.enhanced.SequenceStyleGenerator\\\",\\n        parameters = {\\n                @Parameter(name = \\\"sequence_name\\\", value = \\\"hibernate_sequence\\\"),\\n                @Parameter(name = \\\"optimizer\\\", value = \\\"pooled\\\"),\\n                @Parameter(name = \\\"initial_value\\\", value = \\\"1\\\"),\\n                @Parameter(name = \\\"increment_size\\\", value = \\\"100\\\")\\n        }\\n)\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@GeneratedValue(\\n        strategy = GenerationType.SEQUENCE,\\n        generator = \\\"SequenceGenerator\\\"\\n)\"\n          }), \"\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"private\"\n          }), \" Long id;\\n\"]\n        })\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [_jsx(_components.code, {\n          children: \"increment_size\"\n        }), \"를 지정해주어 크기만큼의 id는 조회나 업데이트 없이 생성할 수 있게 됩니다.\"]\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"해결책 2: JDBC 사용하기\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"JPA를 꼭 써야만 하는 게 아니라면 bulk insert 작업을 JDBC로 분리할 수도 있습니다.\\njdbcTemplate의 batchUpdate() 메서드를 사용해 bulk insert가 가능해집니다.\"\n      }), \"\\n\", _jsx(_components.pre, {\n        children: _jsxs(_components.code, {\n          className: \"hljs language-java\",\n          children: [\"jdbcTemplate.batchUpdate(\", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"INSERT INTO MEMBER(`NAME`) VALUES(?)\\\"\"\n          }), \",\\n\", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"new\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title class_\",\n            children: \"BatchPreparedStatementSetter\"\n          }), \"() {\\n    \", _jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Override\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"void\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"setValues\"\n          }), _jsxs(_components.span, {\n            className: \"hljs-params\",\n            children: [\"(PreparedStatement ps, \", _jsx(_components.span, {\n              className: \"hljs-type\",\n              children: \"int\"\n            }), \" i)\"]\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"throws\"\n          }), \" SQLException {\\n        ps.setString(\", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1\"\n          }), \", \", _jsx(_components.span, {\n            className: \"hljs-string\",\n            children: \"\\\"member\\\"\"\n          }), \" + i);\\n    }\\n\\n    \", _jsx(_components.span, {\n            className: \"hljs-meta\",\n            children: \"@Override\"\n          }), \"\\n    \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"public\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-type\",\n            children: \"int\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-title function_\",\n            children: \"getBatchSize\"\n          }), _jsx(_components.span, {\n            className: \"hljs-params\",\n            children: \"()\"\n          }), \" {\\n        \", _jsx(_components.span, {\n            className: \"hljs-keyword\",\n            children: \"return\"\n          }), \" \", _jsx(_components.span, {\n            className: \"hljs-number\",\n            children: \"1000\"\n          }), \";\\n    }\\n});\\n\"]\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"결론\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: \"JPA로만 작성한다면 키 자동 생성 전략을 바꾸는 게 좋습니다.\\n하지만 JDBC를 사용한다면 키 자동 생성 전략을 그대로 사용할 수 있고 성능도 전반적으로 더 빨랐습니다.\\n다른 DB를 쓰거나 설정이 달라진다면 결과가 다를 수 있지만 MySQL 기준으로 데이터 크기가 커질수록\\nJDBC 쪽이 성능이 더 좋은 것을 확인할 수 있었습니다.\\n물론 두 방법 어느 쪽을 사용하더라도 사용하지 않는 쪽에 비해 큰 성능 차이를 확인할 수 있습니다.\"\n      }), \"\\n\", _jsx(_components.p, {\n        children: _jsx(_components.img, {\n          src: \"/image/jpa/insert_difference.png\",\n          alt: \"성능 차이\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"참고\"\n      }), \"\\n\", _jsxs(_components.ul, {\n        children: [\"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://jaehun2841.github.io/2020/11/22/2020-11-22-spring-data-jpa-batch-insert/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\",\n            children: \"https://jaehun2841.github.io/2020/11/22/2020-11-22-spring-data-jpa-batch-insert/#%EB%93%A4%EC%96%B4%EA%B0%80%EB%A9%B0\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://homoefficio.github.io/2020/01/25/Spring-Data%EC%97%90%EC%84%9C-Batch-Insert-%EC%B5%9C%EC%A0%81%ED%99%94/\",\n            children: \"https://homoefficio.github.io/2020/01/25/Spring-Data%EC%97%90%EC%84%9C-Batch-Insert-%EC%B5%9C%EC%A0%81%ED%99%94/\"\n          })\n        }), \"\\n\", _jsx(_components.li, {\n          children: _jsx(_components.a, {\n            href: \"https://www.baeldung.com/spring-data-save-saveall\",\n            children: \"https://www.baeldung.com/spring-data-save-saveall\"\n          })\n        }), \"\\n\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}}},"__N_SSG":true},"page":"/posts/[id]","query":{"id":"JPA Bulk Insert"},"buildId":"83TotyA5SeDu1ijUHwh-Y","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>