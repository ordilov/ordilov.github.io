---
title:  "문제 해결 전략 8"
date:   2021-06-24 00:01:00 +0900
category: book
tags: ['book']
keywords: ['book']
---

## 8.1 동적 계획법

**중복되는 부분 문제**

동적계획법은 큰 의미에서 분할 정복과 접근 방식이 같습니다.  
주어진 문제를 더 작은 문제로 나눠 조각의 답을 계산합니다.  
이 답들로부터 원래 문제에 대한 답을 계산해냅니다.  
차이가 나는 부분은 문제를 나누는 방식입니다.  
동적계획법에서 어떤 부분 문제는 두 개 이상에서 쓰일 수 있습니다.  
이 때 여러번 계산하는 대신 한번만 계산하고 결과를 재활용합니다.  
그러기 위해서 각 문제의답을 메모리에 저장할 필요가 있습니다.  
계산한 값을 저장해두는 메모리 장소를 **캐시**라고 부릅니다.  
두 번 이상 계산되는 부분 문제를 중복 문제라고 부릅니다.

동적 계획법 알고리즘에서 가장 유명한 예 중 하나는 **이항 계수**입니다.  
이항 계수 $\binom{n}{r}$는 다음과 같습니다.

> n개의 서로 다른 원소 중에서 r개의 원소를 순서없이 골라내는 방법의 수

이항 계수에는 다음과 같은 점화식이 성립합니다.

$\binom{n}{r}$ = $\binom{n-1}{r-1}$ + $\binom{n-1}{r}$

이 점화식으로 재귀함수를 작성할 수 있습니다.

```java
int bino(int n, int r){
  // 기저 사례 1: 고를 원소 r이 없을 때 
  // 기저 사례 2: n == r 모든 원소를 다 골랐을 때
  if(r == 0 || n == r) return 1;
  return bino(n - 1, r - 1) + bino(n-1, r);
}
```
여기서 함수의 중복 호출은 n과 r이 커지면 급증합니다.  
특히 bino(1, 0), bino(1, 1)처럼 낮은 수에서 중복됩니다.  
이런 중복을 해결하려면 각 조합을 배열에 반환 값을 저장합니다.  
매번 호출 시 해당 값이 있다면 반환하고 없다면 계산 후 저장합니다.

```java
  static int[][] cache = new int[30][30];

  // cache 원소들 -1 로 초기화
  Arrays.stream(cache).forEach(e -> Arrays.fill(e, -1));

  static int bino2(int n, int r){
    if(r == 0 || n == r) return 1;
    if(cache[n][r] != -1)
      return cache[n][r];
    return cache[n][r] = bino2(n - 1, r - 1) + bino2(n - 1, r);
  }
```

기존의 bino는 n이 증가할 때마다 호출 횟수가 2배 증가했습니다.  
bino2 는 n이 증가할 때마다 호출 횟수가 n^2 꼴로 증가합니다.

**메모리제이션을 적용할 수 있는 경우**

수학의 함수와 프로그래밍의 함수는 다릅니다.  
수학의 함수는 입력이 같으면 출력은 언제나 같습니다.  
$\sin$ $\pi$는 몇 번을 계산해도 0입니다.  
그러나 프로그래밍을 할 때는 이 속성이 성립하지 않습니다.  
함수의 입력 외에도 전역 변수, 멤버 변수 값에 따라 달라집니다.

```java
int counter = 0;
int count(){
  return counter++;
}
```
입력을 받지 않아도 매번 다른 결과를 반환할 수도 있습니다.  
bino2처럼 입력이 같으면 출력이 같게 만들 수도 있습니다.  
함수의 반환 값이 입력 값으로만 결정되는 여부를 **참조적 투명성**이라 합니다.  
이런 함수들은 입력이 고정되어 있으면 항상 같은 결과를 냅니다.  
**메모리제이션**은 **참조적 투명** 함수에만 적용할 수 있습니다.  
입력이 같은 데 외부 요소에 다른 값이 나오면 캐싱을 할 수 없습니다.

**메모리제이션 구현 패턴**

메모리제이션은 자주 사용하므로 한 가지 패턴을 정하는 것이 좋습니다.

```java
// a와 b는 각각 (0, 2500) 구간 안의 정수
// 반환 값은 항상 int형 안에 들어가는 음이 아닌 정수
int someObscureFunction(int a, int b);
```
예시로 위의 함수를 메모리제이션 형태로 바꿉니다.

- 항상 기저 사례를 먼저 처리합니다.  
입력이 범위에서 벗어난 경우도 여기에 포함합니다.

- 함수의 반환 값이 0 이상이라는 점을 이용해 cache를 -1로 초기화합니다.  
계산되지 않은 값이라는 것을 확인하기 위해 쓰입니다.

- cache[]를 초기화하는 방법을 알아두는 것이 좋습니다.

```java
int[][] cache = new int[2500][2500];

int someObscureFunction(int a, int b){
  if(...) return ...;
  if(cache[a][b] != -1) return cache[a][b];
  // 여기서 답을 계산
  return cache[a][b];
}
```

**메모리제이션의 시간 복잡도 분석**

시간 복잡도 분석이 처음에는 헷갈릴 수 있습니다.  
처음 호출할 때와 다음에 호출할 때 걸리는 시간이 달라져서 그렇습니다.  
하지만 간단하게 계산할 수 있는 방법이 있습니다.

> 존재하는 부분 문제의 수 X 한 부분 문제의 필요 반복문의 수행 횟수

bino2의 경우 r의 최대치는 n입니다.  
bino2(n, r)을 계산할 때 만날 수 있는 부분 문제 최대는 O(n^2)입니다.  
각 부분 문제를 계산할 때 걸리는 시간은 없으니 O(1)이 됩니다.  
두 값을 곱하면 O(n^2)이 됩니다.

이 식이 성립하는 이유는 캐시로 인한 값의 상한선입니다.

**예졔: 외발 뛰기**

nxn 크기의 격자에 1부터 9까지 정수를 쓴 게임판이 있습니다.  
게임의 목적은 게임판 왼쪽 위부터 시작해 맨 오른쪽 아래에 도착합니다.  
각 칸에 적혀 있는 숫자만큼 아래나 오른쪽으로 이동할 수 있습니다.  
중간에 게임판 밖으로 벗어나면 안됩니다.  
문제는 게임판이 주어질 때 끝부분에 도착할 수 있나 확인합니다.

**재귀 호출에서 시작하기**

동적 계획법을 만드는 첫 단계는 해당 문제를 재귀적으로 해결합니다.  
완전 탐색 알고리즘으로 모든 경로를 만들어보며 끝에 도달하나 확인합니다.

> jump(y, x) = (y, x)에서부터 맨 마지막 칸까지 도달할 수 있는 여부

jump()는 한 번 호출할 때마다 아래쪽인지 오른쪽인지 결정합니다.  
(y,x) 위치의 수를 jumpSize라고 하겠습니다.  
그렇다면 다음과 같이 표현이 가능합니다.

> jump(y,x) = jump(y + jumpSize, x) || jump (y, jumpSize + x)

```java
int n;
int[][] board = new int[100][100];

boolean jump(int y, int x){
  // 기저 사례: 게임판 밖으로 벗어난 경우
  if(y >= n || x >= n) return false;
  // 기저 사례: 마지막 칸에 도착한 경우
  if(y == n-1 && x == n-1) return true;

  int jumpSize = board[y][x];
  return jump(y + jumpSize, x) || jump(y, x + jumpSize);
}
```

**메모리제이션 적용하기**

완전탐색 시 문제가 되는 것은 보통 원하는 답이 없을 때입니다.  
원하는 답은 없는데 전체 답의 개수가 많으면 해결하기 어려워집니다.  
이 경우 만들어야 하는 경로는 n에 대해 지수적으로 증가합니다.  
n이 100이면 시간 제한을 초과하게 됩니다.  
하지만 n이 100이라도 입력의 개수는 10,000개 뿐입니다.  
즉 많은 경우가 중복으로 처리되고 있습니다.  
이를 메모리제이션을 이용해 해결합니다.

```java
int n;
int[][] board = new int[100][100];
int[][] cache = new int[100][100];

int jump(int y, int x){
  // 기저 사례: 게임판 밖으로 벗어난 경우
  if(y >= n || x >= n) return false;
  // 기저 사례: 마지막 칸에 도착한 경우
  if(y == n-1 && x == n-1) return true;

  if(cache != -1) return cache[y][x];
  int jumpSize = board[y][x];
  cache[y][x] = (jump(y + jumpSize, x) || jump(y, x + jumpSize));
  return cache[y][x] 
}
```

1. 주어진 문제를 완전 탐색을 이용해 해결
2. 중복된 문제를 한 번만 계산하도록 메모리제이션 적용

## 8.2 문제: 와일드 카드
와을드 카드는 파일의 일부만으로 파일 이름을 찾을 수 있습니다.  
이 때 사용하는 문자열을 와일드 카드 패턴이라 합니다.  
패턴은 일반적인 파일명과 비슷하지만 *나 ?를 포함합니다.  
와일드카드 패턴과 비교해 모든 글자가 일치하면 대응된다고 합니다.  
?는 어떤 글자와도 대응되고 *은 0글자 이상 어떤 문자열과도 대응됩니다.

**시간 메모리 제한**

> 2초 안에 실행, 64MB 이하의 메모리 사용

**입력**
첫 줄: 테스트 케이스의 수 C (1 < C < 10)

테스트 케이스:
첫 번째 줄: 와일드 카드 패턴 W
다음 줄: 파일명의 수 n (1 < n < 50)
n 줄: 각 파일명
패턴은 알파벳 대소문자, 숫자, *, ?으로 구성
파일명은 알파벳 대소문자, 숫자
모든 문자열은 1이상 100이하


**출력**

테스트 케이스마다 주어진 패턴에 대응하는 파일 이름  
한줄에 하나씩 출력

**예제 입력**
```
3
he?p
3
help
heap
helpp
*p*
3
help
papa
hello
*bb*
1
babbbc
```

**예졔 출력**
```
heap
help
help
papa
babbbc
```

## 8.3 풀이: 와일드 카드

**\*가 문제**

이 문제를 어렵게 만드는 것은 *에 대응되는 글자 개수입니다.  
단순하게는 * 다음에 출현하는 글자가 나올때까지 대응시킬 수 있습니다.  
하지만 그렇게 되면 입력의 3번째 예제를 해결할 수 없습니다.  
주어진 패턴이 m개의 *를 포함하낟고 가정합니다.  
이 패턴을 * 가 나타낼때마다 쪼갭니다.  
그럼 이 패턴이 문자열에 대응하는지 문제를 m+1로 쪼갤 수 있습니다.  
이 조각들마다 재귀 호출로 일치하나 확인해볼 수 있습니다.  
먼저 와일드 카드가 원문 s에 대응되는지 match(w,s)로 확인합니다.  
이때 종료 조건은 다음과 같습니다.

1. s[pos]와 w[pos]가 대응되지 않는다.  
실패 조건입니다.

2. w 끝에 도달했다.  
패턴에 *이 없는 경우로 패턴과 문자열이 일치해야 합니다.

3. s 끝에 도달했다.  
패턴은 남았지만 문자열이 끝난 경우입니다.
남은 패턴이 **인 경우를 제외하고 실패입니다.

4. w[pos]가 * 인 경우  
*가 몇 글자에 대응될지 모르므로 0글자부터 남은 문자열을 순회합니다.
이 때 w의 pos+1 이후의 패턴과 s가 하나라도 일치하면 참이됩니다.

```java
static int[][] cache = new int[101][101];
static String W, S;

public static int matchMemorized(int w, int s) {
  if (cache[w][s] != -1) {
    return cache[w][s];
  }

  if (s < S.length() && w < W.length()
      && (W.charAt(w) == '?' || W.charAt(w) == S.charAt(s))) {
    return cache[w][s] = matchMemorized(w + 1, s + 1);
  }

  if (w == W.length()) {
    return cache[w][s] = (s == S.length() ? 1 : 0);
  }

  if (W.charAt(w) == '*') {
    if (matchMemorized(w + 1, s) == 1 ||
        (s < S.length() && matchMemorized(w, s + 1) == 1)) {
      return cache[w][s] = 1;
    }
  }

  return cache[w][s] = 0;
}
```
전체 시간 복잡도는 O(n^2)이 됩니다.

## 8.4 전통적 최적화 문제들

동적 계획법의 가장 일반적인 사용처는 최적화 문제입니다.  
최적화 문제에서 특정 성질이 성립할 때 더 효휼적으로 풀 수 있습니다.

**예졔: 삼각형 위의 최대 경로**

왼쪽 하단을 중심으로 삼각형으로 배치된 자연수들이 있습니다.  
맨 위의 숫자에서 시작해 한 번에 한 칸씩 아래로 내려가 경로를 만듭니다.  
아래줄로 내려갈 때마다 바로 아래 혹은 오른쪽 아래로 내려갑니다.  
이 때 모든 경로 중 숫자의 합을 최대화하는 경로는 무엇일까요?  
그리고 그렇게 정해진 경로에 포함된 숫자들의 합은 얼마일까요?

**완전 탐색으로 시작하기**

경로를 각 가로줄로 조각냅니다.  
각 조각에서는 아래로 내려갈지 오른쪽으로 갈지 선택합니다.  
이 때 재귀호출에는 현재 위치와 지금까지 거친 숫자들의 합을 전달합니다.

> pathSum(y, x, sum) 현재 위치가 (y, x)  
지금까지 만난 수의 합이 sum일 때 맨 아래줄이 얻을 수 있는 최대합

아래쪽과 오른쪽으로 내려갔을 때 최대합은 다음처럼 표현합니다.

$ path1(y,x,sum) = max
\cases{
path(y+1, x, sum + triangle[y][x]) \cr
path(y+1, x+1, sum + triangle[y][x])
}$

**무식하게 메모리제이션 적용하기**

앞에서 정의한 점화식은 답을 구하기 위해 모든 경로를 만듭니다.  
이것은 큰 문제로 가로줄이 늘때마다 두 배씩 늘어납니다.  
n < 20 정도라면 가능하지만 최대치가 100이라면 계산할 수 없습니다.
메모리제이션을 적용할 때 메모리에 대해 생각해야 합니다.  
또한 위의 점화식은 합이 서로 다른 경우 매번 계산합니다.

**입력 걸러내기**

재귀함수의 입력을 나누면 더 빠르게 할 수 있습니다.

1. y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정합니다.

2. sum은 어떤 경로로 이 부분에 도달했는지 나타냅니다.

즉 y와 x는 아직 해결하지 못한 조각을 정의하는 입력입니다.  
반면에 sum은 이미 결정된 조각입니다.  
즉 sum은 앞으로 푸는 문제에 영향을 주지 않습니다.  
따라서 둘의 입력을 분리합니다.  
이렇게 구성하면 전의 값들을 알 수 없기 때습니다.  
따라서 반환 값을 (y,x)에서 시작하는 최대치로 바꿉니다.

```java
private static int path(int y, int x) {
  if (y == n - 1) {
    return triangle[y][x];
  }

  if (cache[y][x] != -1) {
    return cache[y][x];
  }

  int max = Math.max(path(y + 1, x), path(y + 1, x + 1));
  return cache[y][x] = max + triangle[y][x];
}
```

부분 문제는 O(n^2)이고 각 부분문제는 상수 시간이 걸립니다.  
따라서 전체 시간복잡도는 O(n^2)이 됩니다.

**이론적 배경: 최적 부분 구조**

속도를 최적화할 수 있었던 이유는 sum이 (y,x)에 영향을 안줘서입니다.  
어떤 경로로 도달했건 남은 부분 문제는 최적으로 푸 있습니다.  
이런 구조를 **최적 부분 구조**라고 합니다.  
각 부분 문제의 최적해만 있으면 전체의 최적해를 구할 수 있는 구조입니다.  
다른 예로는 서울에서 부산까지 가는 최단 경로입니다.  
최단 경로가 대전을 지난다고 가정합니다.  
그렇다면 (서울, 대전), (대전, 부산)으로 경로를 나눌 수 있습니다.  
두 구간의 최단 경로를 찾아서 이으면 항상 최단 경로입니다.  
반면에 최단 경로외에 조건이 붙기 시작하면 쓸 수 없습니다.  
각 최적이 전체에 최적을 보장해주지 못합니다.

**예제: 최대 증가 부분 수열**

정수 수열 S의 부분 수열이란 S에서 0개 이상을 지우고 남은 수열입니다.  
부분 수열에 포함된 숫자들이 순 증가를 하면 증가 부분 수열입니다.  
주어진 수열에서 얻을 수 있는 가장 긴 증가 부분 수열을 찾습니다.

**완전 탐색에서 시작하기**

최대 증가 부분 수열을 찾는 부분을 숫자 하나씩 쪼갭니다.  
한 조각에서 하나씩 선택하는 완전 탐색 알고리즘을 만듭니다.  
수열 A를 입력 받아 LIS의 길이를 반환하는 lis(A)를 가정합니다.  
A의 모든 증가 부분 수열을 만든 뒤 가장 긴 길이를 반환합니다.

lis(A)가 첫 번째 수열의 첫 숫자로 A[j]를 골랐다고 가정합니다.  
A[j+1...] 부분 수열에서 A[j]보다 큰 숫자들만 고른 B를 만듭니다.  
B를 lis로 계산하면 최대 부분이 나오게 됩니다.

```java
int lis(LinkedList<Integer> A){
  if(A.isEmpty()) return 0;
  int answer = 0;
  for(int i = 0; i < A.size(); ++i){
    LinkedList<Integer> B;
    for(int j = i+1; j < A.size(); ++j)
      if(A[i] < A[j])
        B.push(A[j]);
    answer = max(answer, 1 + lis(B));
  }
  return answer;
}
```

**입력 손보기**

완전 탐색의 기능은 하지만 메모리제이션 적용이 어렵습니다.  
먼저 입력이 정수가 아니라 배열입니다.  
map을 사용해서 저장할 수 있지만 속도가 매우 느립니다.  
A의 정의를 이용해 A를 좀 더 간단하게 표현합니다.

1. 원래 주어진 수열 S
2. 원래 주어진 수열의 원소 S[i]에 대해 S[i+1...] 에서 큰 수들

2번 정의에서 이전에 선택한 수들은 포함되지 않습니다.  
즉 2번 정의에서 A는 S의 인덱스와 1:1 대응이 됩니다.

> lis(start) = S[start]에서 시작하는 부분 증가 수열의 최대 길이

재귀 호출할 때마다 S[start]보다 뒤에 잇고 큰 수를 고릅니다.  
이렇게 되면 시간 복잡도는 O(n) x O(n) 으로 O(n^2)이 됩니다.

```java
static int n;
static int[] cache = new int[100];
static int[] S = new int[100];

int lis2(int start){
  if(cache[start] != -1) return cache[start];
  cache[start] = 1;
  for(int next = start + 1; next < n; ++next)
    if(S[start] < S[next])
      answer = Math.max(answer, lis2(next) + 1);
  return answer;
}
```

**시작 위치 고정하기**
lis2()를 호출할 때 항상 증가 부분 수열의 시작 위치를 정합니다.  
처음에 호출 할 때 각 위치를 순회하면서 최대 값을 찾습니다.

```java
int maxLen = 0;
for(int begin = 0; begin < n; ++begin)
  maxLen = Math.max(maxLen, lis2(begin));
```
이것도 귀찮게 느껴질 수 있습니다.  
그럴 때 S[-1] = $-\infty$ 로 가정합니다.  
lis2(-1)을 호출하면 항상 $-\infty$으로 모든 시작 위치를 시도합니다.

```java
static int n;
static int[] cache = new int[101];
static int[] S = new int[100];

int lis3(int start){
  if(cache[start+1] != -1) return cache[start+1];
  cache[start+1] = 1;
  for(int next = start + 1; next < n; ++next)
    if(start == -1 || S[start] < S[next])
      answer = Math.max(answer, lis3(next) + 1);
  return answer;
}
```

**더 빠른 해법**
O(n^2) 보다 빠른 O(nlogn)에 답을 찾을 수 있습니다.  
텅 빈 수열에서 시작해 숫자를 하나씩 추가해나갑니다.  
각 길이를 갖는 증가 수열 중 가장 마지막 수가 작은 걸 찾습니다.

> C[i] = 지금까지 만든 부분 배열 길이 i  
증가 부분 수열 중 최소의 마지막 값

이 값을 이용하면 LIS의 길이 k에 대해 O(nk)에 찾을 수 있습니다.  
C[]는 순증가하게 되는데 이것을 이분 검색하면 O(nlogn)을 만족합니다.

**최적화 문제 동적 계획법 레시피**

1. 모든 문제를 만들어보고 그중 최적해를 반환하는 완전 탐색 알고리즘

2. 전체 답의 점수가 아닌 앞으로 남은 선택만 반환하도록 부분 문제 정의

3. 재귀 호출 입력에 이전 선택이 있다면 줄이기  
가능한 중복되는 부분 문제 많이 만들어 메모리제이션

4. 입력이 배열이나 문자열이라면 되도록 변환

5. 메모리제이션 적용

## 8.5 문제: 합친 LIS

어떤 수열에서 0개 이상의 숫자를 지운 결과를 부분 수열이라 합니다.  
중복된 숫자가 없고 증가할 때 증가 부분 수열이라 합니다.  
두 개의 정수 수열 A와 B에서 길이 0이상 증가 부분 수열을 얻습니다.  
이들을 크기 순서대로 합친 것이 합친 증가 부분 수열입니다.  
이 중 가장 긴 수열을 합친 LIS라 합니다.

**시간 메모리 제한**

> 2초 안에 실행, 64MB 이하의 메모리 사용

**입력**
첫 줄: 테스트 케이스의 수 C (1 < C < 50)
테스트 케이스:
첫 번째 줄: A와 B의 길이 n, m (1 < n, m < 100)
다음 줄: n개의 정수 A
다음 줄: m개의 정수 B
모든 원소들은 32비트 부호 있는 정수에 저장 가능

**출력**

각 테스트 케이스마다 한 줄에 JLIS 출력


**예제 입력**
```
3
3 3
1 2 4
3 4 7
3 3
1 2 3
4 5 6
5 3
10 20 30 1 2
10 20 30
```

**예졔 출력**
```
5
6
5
```

## 8.6 풀이: 합친 LIS

이 문제는 LIS의 확장판입니다.  
두 개의 수열에서 고를 뿐 그다지 다르지 않습니다.  
하지만 두 개에서 뽑은 LIS가 연결되어야합니다.

**비슷한 문제를 풀어 본 적이 있군요**

기존에 LIS를 찾는데 사용했던 알고리즘을 변형해 문제를 풉니다.

## 8.7 문제: 원주율 외우기
외우는 것을 잘하는 사람들은 원주율을 끊어서 외웁니다.  
세 자리나 다섯 자리까지 끊어서 외웁니다.  
이 중에서 외우기 쉬운 조각들을 택합니다.  
난이도의 합의 최소값을 구합니다.

|경우|예|난이도|
|---|---|---|
| 모든 숫자가 같을 때 |333, 5555| 1 |
| 숫자가 1씩 단조 증가하거나 단조 감소| 23456, 3210 | 2 |
| 두 개 숫자 번갈아 등장 | 323, 54545 | 4 |
| 숫자가 등차수열을 이룰 때 | 147, 8642 | 5 |
| 이 외의 모든 경우 | 17912, 312 | 10 |

**시간 메모리 제한**

> 1초 안에 실행, 64MB 이하의 메모리 사용

**입력**
> 첫 줄: 테스트 케이스의 수 C (1 < C < 50)
테스트 케이스:
첫 번째 줄: 8자리 이상 10,000자리 이하의 자연수
맨 앞자리가 0일 수도 있습니다.

**출력**

한 줄에 최소의 난이도를 출력합니다.


**예제 입력**
```
5 
12341234 
11111222 
12122222 
22222222 
12673939 
```

**예졔 출력**
```
4
2
5
2
14
```

```java

```

## 8.9 문제: Quantization

양자화 과정은 더 넓은 범위를 갖는 값들을 작은 범위로 근사합니다.  
자료를 손실 압축하는 과정입니다.  
예를 들어 16bit JPG 컬러를 4컬러 GIF 파일로 변환하듯이요.

1,000 이하의 자연수들로 구성된 수열을 s가지의 자연수로 양자화합니다.  
양자화를 하는 방법은 여러가지입니다.  
이 때 오차 제곱의 합이 최소화하는 양자화 결과를 얻고 싶습니다.

**시간 메모리 제한**

> 2초 안에 실행, 64MB 이하의 메모리 사용

**입력**
> 첫 줄: 테스트 케이스의 수 C (1 < C < 50)
테스트 케이스:
첫 번째 줄: 수열의 길이 n (1 < n < 100)
사용할 숫자의 수 s(1 < s < 10)
다음 줄 : n개의 정수

**출력**

양자화할 때 오차 제곱의 합의 최소치

**예제 입력**
```
2
10 3
3 3 3 1 2  3 2 2 2 1
9 3
1 744 755 4 897 902 890 6 777
```

**예졔 출력**
```
0
651
```

## 8.10 풀이 Quantization

**하던 대로는 안 된다**

이 문제는 지금까지처럼 재귀적인 해법을 찾기 힘듭니다.  
단순하게는 양자화된 결과 수열을 답어로 생각합니다.  
맨 앞에서부터 숫자 하나씩 채워가는 접근 방법을 택합니다.  
경우의 수가 어마무시하게 많아질 것은 당연한 일입니다.

**답의 형태 제한하기**

부분 문제의 개수가 너무 많을 때 시도할 방법은 많습니다.  
그 중에서 이 문제에서는 답의 구조를 예측하고 강제하는 것입니다.  
a < b 에 대해서 두 숫자에 대응되는 숫자는 a < b입니다.
반대의 경우 대응되는 숫자를 바꾸면 최소값이 낮아집니다.  
여기서 일반화하면 다음과 같은 결과가 나옵니다.

> 정렬된 수열에서, 같은 숫자로 양자화된 숫자들은 항상 인접해있다.

따라서 현재 부분에서 최소값과 남은 부분으로 나눌 수 있습니다.  
오차 제곱 합의 최소치는 어떻게 구할까요?  
구간 내에 있는 숫자들을 반복문으로 돌아볼 수도 있습니다.  
복잡하게 생각하기 귀찮으면 위의 방법을 사용해도 됩니다.  
하지만 좀 더 고민해서 미분으로 최소화 하는 부분을 찾아봅니다.

$\sum_{i=a}^b (A[i]-m)^2$

$(b-a+1)*m^2 - 2 * \sum_{i=a}^b m + \sum_{i=a}^b (A[i]^2)$

위의 식을 미분하면 다음과 같습니다.

$2 * (b-a+1) * m - 2 * \sum_{i=a}^b (A[i]) = 0$

위의 식을 정리하면 m은 다음과 같습니다.

$m = \frac {\sum_{i=a}^b (A[i])}{b-a+1}$

즉 모든 값의 평균일 때 오차는 제일 작아집니다.

## 8.11 경우의 수와 확률

대개 경우의 수를 세는 문제는 입력의 크기에 따라 지수적으로 증가합니다.  
그렇지 않다면 이 방법이 아닌 완전탐색으로 풀어낼 것입니다.  
크기가 커지기에 보통 32비트의 정수형의 크기를 벗어납니다.  
그래서 보통 어떤 수 M으로 나눈 나머지를 출력합니다.

**예제: 타일링 방법의 수 세기**

2xn 크기의 사각형을 2x1 크기의 타일로 채우는 방법의 수를 셉니다.

우선 안전 탐색을 이용해 모든 방법을 만들어봅니다.  
맨 왼쪽 세로줄을 채우는 방법은 두 가지입니다.

- 맨 왼쪽 줄에 세로 한 칸으로 채울 때
- 맨 왼쪽 두 줄에 가로 두 칸으로 채울 때

그리고 이후로도 계속 이 두 방법 이외에 채울 수 없습니다.  
이런 문제를 해결할 때 두 가지를 확인합니다.

- 분류가 모든 방법을 포함합니다.
- 두 가지 분류에 모두 포함하는 방법은 없습니다.

첫 번째를 어기는 경우, 답보다 적은 수를 구하게 됩니다.  
두 번째를 어기는 경우, 답보다 많은 수를 구하게 됩니다.

> tiling(n)= 2xn 크기의 사각형을 타일로 덮는 방법을 구한다.

tiling은 이전 부분은 어떻게 덮었는지 신경쓰지 않습니다.

> tiling(n) = tiling(n-1) + tiling(n-2)

```java
static final int M = 10000007;
int[] cache = [101];

int tiling(int width){
  if(width <= 1) return 1;
  if(cache[width] != -1) return cache[width];
  return cache[width] = (tiling(width-2) + tiling(width-1))%M;
}
```

**예제 삼각형 위의 최대 경로 개수 세기**

8.4에서 삼각형 최대 경로의 합만 구하고 경로는 구하지 않았습니다.  
최대 경로는 유일하지 않습니다.  
n이 커질 경우에 최대 경로의 수를 어떻게 구할 수 있을까요?   
이 문제를 해결하려면 두 개의 다른 동적 계획법을 해결해야 합니다.  
먼저 최적화 문제를 해결하고 각 부분 문제마다 최적해를 구합니다.

8.4를 진행하고 나온 cache[]를 생각하면서 문제를 해결합니다.  
같은 높이에서 가장 값이 큰 경우가 최대 경로로 가는 길입니다.  
이 때 같은 값이 있다면 경로에 추가해야합니다.

> count(y,x) = (y,x)에서 시작해 맨 아래줄까지 내려가는 최대 경로 수

```java
int[][] countCache = new int[100][100];
int count(int y, int x){
  if(y == n-1) return 1;
  if(countCache[y][x] != -1 ) return countCache[y][x];
  countCache[y][x]=0;
  if(path2(y+1, x+1) >= path2(y+1, x)) 
    countCache[y][x] += count(y+1, x+1);
  if(path2(y+1, x+1) <= path2(y+1, x)) 
    countCache[y][x] += count(y+1, x);
  return countCahce[y][x];
}
```

**예졔: 우물을 기어오르는 달팽이**

깊이가 n미터인 우물의 밑바닥에 달팽이가 있습니다.  
달팽이의 움직임은 그 날의 날씨에 좌우됩니다.  
비가 내리면 하루에 2미터, 맑으면 1미터 올라갑니다.  
m일간 비 올 확률이 50%일 때 m일 안에 올라갈 확률은 얼마일까요?

**경우의 수로 확률 계산하기**

각 날마다 비가 오거나 오지 않거나 둘 중 하나입니다.  
즉 모든 경우의 수는 m일간 2^m 가지가 됩니다.

**완전 탐색 알고리즘**

모든 날씨 조합을 하나하나 만들어보는 완전 탐색 부터 시작합니다.  
각 조합을 m조각으로 잘라 재귀 호출로 맑을지 결정합니다.

> climb(C) = 지금까지 만든 C를 완성해서 원소합이 n이 되는 방법 수

climb은 다음과 같은 점화식으로 정의할 수 있습니다.

> climb(C) = climb(C + [1]) + climb(C + [2])

이렇게 정리하고 나서 C 대신에 C의 시작 날짜 days로 바꿉니다.

```java
int n, m;
int[][] cache = new int[MAX_N][2+MAX_N+1];

int climb(int days, int climbed){
  if(days == m) return climbed >= n ? 1 : 0;
  if(cache[days][climbed] != -1) return cache[days][climbed];
  int answer = climb(days+1, climbed+1) + climb(days+1, climbed+2);
  return cache[days][climbed] = answer;
}
```

**예졔: 장마가 찾아왔다**

장마가 찾아와 매일 비가 올 확률이 50%에서 75%로 증가했습니다.  
이렇게 되면 날씨의 조합마다 출현 확률이 달라지게 됩니다.

날씨가 정해졌을 때 올라가는 부분은 동일하게 유지할 수 있습니다.  
달라지는 부분은 점화식 부분에 확률만 추가하면 됩니다.

**경우의 수 계산하기 레시피**

1. 모든 답을 직접 만드는 완전 탐색 알고리즘을 만듭니다.
2. 최적화 문제를 해결하듯 이전 입력 결정 요소를 줄입니다.
3. 메모리제이션을 적용합니다.

## 8.12 문제: 비대칭 타일링

2xn 크기의 직사각형을 2x1 크기의 타일로 채웁니다.  
단 타일링 방법 중 좌우 대칭이면 안됩니다.  
n이 주어질 때 비대칭 타일링 방법의 수를 계산합니다.  
단 수가 커질 수 있으므로 1,000,000,007으로 나눕니다.

**시간 메모리 제한**

> 1초 안에 실행, 64MB 이하의 메모리 사용

**입력**
> 첫 줄: 테스트 케이스의 수 C (1 < C < 50)
테스트 케이스:
첫 번째 줄: n (1 < n < 100)

**출력**
결과를 1,000,000,007으로 나눕니다.

**예제 입력**
```
3
2
4
92
```

**예졔 출력**
```
0
2
913227494
```

## 8.13 풀이: 비대칭 타일링
완전 탐색 알고리즘으로도 풀 수 있습니다.  
다만 더 쉽게 푸는 방법들이 있습니다.  
비대칭 타일링의 수는 전체에서 타일링의 수를 제외한 값입니다.  
대칭 타일링의 경우를 셀 수 있을까요?  
먼저 n이 홀수 일때와 짝수일 때 경우의 수가 달라집니다.  
n이 홀수 일때 가운데 세로 줄은 세로 타일이어야 합니다.  
그리고 나머지는 좌우 대칭 형태일 것입니다.  
n이 짝수인 경우 가운데 가로 두줄로 겹쳐진 형태가 있습니다.  
이외에는 좌우 대칭인 형태가 됩니다.  
각 부분에 대해 계산하면 답을 구할 수 있습니다.

```java
int asymmetric(int width){
  if(width % 2 == 1)
    return (tiling(width) - tiling(width/2) + MOD) % 2;
  int answer = tiling(width);
  answer = (answer - tiling(width / 2) + MOD) % MOD;
  answer = (answer - tiling(width/2 - 1) + MOD) % MOD;
  return answer;
}
```
MOD값으로 나누기 전에 MOD를 더해주는 부분이 있습니다.  
tiling()의 반환 값은 경우의 수로 음수가 나올리 없습니다.  
하지만 tiling()의 반환 값을 MOD로 나눈 반환 값이 나옵니다.  
따라서 대칭인 경우의 수를 빼면 음수가 나올 수 있습니다.

**직접 비대칭 타일링의 수 세기**

직접 비대칭 타일링의 수를 셀 수도 있습니다.  
좌우 대칭이 아닌 부분만 걸러내면 됩니다.  
하지만 이런 식으로는 메모리제이션 적용이 힘듭니다.  
타일링 방법이 대칭인지 알려면 과거 정보도 전부 전달해야 합니다.  
과거 정보 없이 만들어가는 방법은 양쪽 끝에서 동시에 만듭니다.  
경우는 두 가지로 끝 부분이 세로일 때와 가로일 때입니다.

```java
int[] cache2 = new int[101];

int asymmetric2(int width){
  if(width <= 2) return 0;
  if(cache2[width] != -1) return cache2[width];
  cache2[width] = asymmetric2(width-2) % MOD;
  cache2[width] = (cache2[width] + asymmetric2(width-4)) % MOD;
  cache2[width] = (cache2[width] + tiling(width-3)) % MOD;
  cache2[width] = (cache2[width] + tiling(width-3)) % MOD;
}
```
**스캐폴딩으로 테스트하기**

이 문제는 입력을 생성하기 쉽고 느리지만 확실한 답을 낼 수 있습니다.  
따라서 스캐폴딩을 통해 테스트하기 적절한 문제입니다.  
1부터 20이하로 확인을 해보고 답이 일치하면 답의 정확도에 자신이 생깁니다.

## 8.14 문제: 폴리오미노
정사각형의 변들을 서로 완전하게 붙여 만든 도형이 **폴리오미노**입니다.  
n개의 정사각형으로 구성된 폴리오미노 중 세로로 단조인 개수를 셉니다.  
세로로 단조는 어떤 가로줄도 두 번 이상 교차하지 않음을 뜻합니다.

**시간 메모리 제한**

> 1초 안에 실행, 64MB 이하의 메모리 사용

**입력**

첫 줄: 테스트 케이스의 수 C (1 < C < 50)
테스트 케이스:
첫 번째 줄: n (1< n < 100)

**출력**
10,000,000 이상일 경우 나머지 출력

**예제 입력**
```
3
2
4
92
```

**예졔 출력**
```
2
19
4841817
```
## 8.15 풀이: 폴리오미노

**완전 탐색에서 시작하자**

어떤 순서대로 폴리오미노를 구성하는 것이 중요합니다.  
같은 모양을 두 번 이상 세지 않기 위해서입니다.  
다행히 문제가 세로 단조를 구하기 때문에 쉬워집니다.  
각 가로줄마다 몇개를 넣을지를 정합니다.  
그리고 각 위치를 조정해주면 됩니다.

>poly(n)= n개의 정사각형으로 만들 수 있는 세로 단조 폴리오미노의 수

다만 첫 번째 줄에 몇 개인지에 따라 다음 줄의 개수도 영향받습니다.  
따라서 첫 번째 줄도 인자로 포함시킵니다.  
둘 크기에 따라 방법의 수는 first + second - 1개가 됩니다.

```java
static final int MOD = 10*1000*1000;
int[][] cache = new int[101][101];

int poly(int n, int first){
  if(n == first) return 1;

  int answer = cache[n][first];
  if(answer != -1) return answer;

  answer = 0;
  for(int second = 1; second <= n-first; ++second){
    int add = second + first - 1;
    add *= poly(n - first, second);
    add %= mOD;
    ret += add;
    ret %= MOD;
    cache[n][first] = answer;
  }
  return answer;
}
```

## 8.16 문제: 두니발 박사의 탈옥

두니발 박사가 감옥에서 탈출했습니다.  
d일이 지났지만 찾지 못해 도주 경로를 분석중입니다.  
찾은 단서로 세운 가설은 다음과 같습니다.

- 두니발 박사는 검문을 피해 산길로만 이동한다.
- 두니발 박사는 탈출한 당일 교도소와 인접한 마을 하나로 도망쳤다.
- 두니발 박사는 매일 인접한 마을로 움직여 은신한다.

이 가설을 검증하기 위해 n개 마을들의 지도를 구했습니다.

**시간 메모리 제한**

> 2초 안에 실행, 64MB 이하의 메모리 사용

**입력**
> 첫 줄: 테스트 케이스의 수 C (1 < C < 50)
테스트 케이스:
첫 번째 줄: 마을의 수 N (2 < N < 50)
탈출 후 지금까지 지난 일수 D(1 < D < 100)
교도소가 있는 마을의 번호 P (0 < P < N)
마을은 0번 부터 N-1번까지 순서대로 번호
다음 줄   마을 연결 그래프
0인 경우 길이 없다는 것을 의미
다음 줄: 확률을 계산할 마을의 수 T (0 < T < N)
다음 줄: T개의 정수로 계산할 마을의 번호 Q(0 < Q < N>)
한 마을에서 다른 마을로 길은 양방향으로 항상 있습니다.
한 마을에서 다시 그 마을로 연결되는 길은 없습니다.

**출력**
각 테스트 케이스마다 T개의 실수로 숨어있을 확률  
10^-7 이하의 절대/상대 오차 정답 처리


**예제 입력**
```
2
5 2 0
0 1 1 1 0
1 0 0 0 1
1 0 0 0 0
1 0 0 0 0
0 1 0 0 0
3
0 2 4
8 2 3
0 1 1 1 0 0 0 0
1 0 0 1 0 0 0 0
1 0 0 1 0 0 0 0
1 1 1 0 1 1 0 0
0 0 0 1 0 0 1 1
0 0 0 1 0 0 0 1
0 0 0 0 1 0 0 0
0 0 0 0 1 1 0 0
4
3 1 2 6
```

**예졔 출력**
```
0.83333333 0.00000000 0.16666667
0.43333333 0.06666667 0.06666667 0.06666667
```

```java
private static double dunibal(int loc, int day) {
  if (day == 0) {
    return loc == prison ? 1 : 0;
  }

  if (cache[day][loc] != -1) {
    return cache[day][loc];
  }

  cache[day][loc] = 0;

  for (int i = 0; i < n; i++) {
    if (i == loc) {
      continue;
    }
    if (map[loc][i] == 1) {
      cache[day][loc] += dunibal(i, day - 1) / connected[i];
    }
  }
  return cache[day][loc];
}

public static double[] getConnected(int[][] map){
  double[] connected = new double[map.length];
  for(int i = 0; i < map.length; i++)
    for(int j = 0; j < map[i].length; j++)
      if(map[i][j] == 1) connected[i] += 1;

  return connected;
}
```
첫 번째 방법으로 0일부터 시작해 D에 도착하게 계산했습니다.  
결과는 잘나왔지만 문제는 D일에 도착하는 위치를 매번 바꿔야 합니다.  
즉 테스트 케이스마다 구해야해서 O(n^2 dt)의 시간이 걸립니다.  
하지만 반대로 생각해서 풀면 0일째 감옥에 있는 경우로 고정됩니다.  
이러한 특성을 **마르코프 연쇄**라고 합니다.

- 유한개의 상태가 있습니다.
- 매 시간마다 상태가 변경됩니다.
- 상태 a에서 상태 b로 옭겨갈 확률은 현재 상태 a에만 좌우됩니다.
- a 이전에 어느 상태인지, 현재 시간은 얼마인지는 상관없습니다.  