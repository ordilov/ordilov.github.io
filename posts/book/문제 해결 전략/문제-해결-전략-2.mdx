---
title:  "문제 해결 전략 2"
date:   2021-06-24 00:01:00 +0900
category: book
tags: ['book']
keywords: ['book']
---

# 문제 해결 개관

## 2.1 도입

무작정 알고리즘을 외우고 문제를 푼다고 실력이 쌓일까요?   
추상적 개념은 단순 반복으로 향상하기 어려습니다.

그래서 사람들은 주로 두 단계에서 머무릅니다.   
- 기계적으로 문제를 풀면서 감을 익히기
- 막연한 시도 반복

채를 휘둘러 공을 치는 것은 누구나 할 수 있습니다.   
여러번 치다 보면 감을 잡을 수도 있습니다.   
하지만 무작정 공을 여러 번 친다고 쉽게 늘지 않습니다.   
실력을 늘리려면 휘두르는 과정을 나누고 개선해야 합니다.   

마찬가지로 좋은 문제 해결자는 생각을 해야합니다.   
그리고 문제를 푸는 게 아닌 푸는 기술을 연마해야 합니다.  
- 자신이 어떤 방식으로 해결하는지 의식
- 어떤 부분을 개선할지 파악

## 2.2 문제 해결 과정
**파인만 알고리즘**
1. 칠판에 문제를 적는다.
2. 골똘히 생각한다.
3. 칠판에 답안을 적는다.

단순하지만 배울 점이 있습니다.
- 문제를 해결하기 위해 과정을 세분화
- 문제를 적으면서 문제를 읽고 이해하고 재정의

### 어떻게 문제를 풀 것인가
1. 문제를 읽고 이해한다.
2. 문제를 익숙한 용어로 재정의한다.
3. 어떻게 해결할지 계획을 세운다.
4. 계획을 검증한다.
5. 프로그램으로 구현한다.
6. 어떻게 풀었는지 돌아보고, 개선할 방법이 있는지 찾아본다.

**1단계: 문제를 읽고 이해하기**

문제를 꼼꼼히 읽고 제약 조건 제대로 이해합니다.

**2단계: 재정의와 추상화**

문제를 직관적으로 이해하기 위해 자신의 언어로 작성합니다.

현실 세계의 복잡한 개념을 본질만 남기고 축약하는 추상화합니다.

어떻게 추상화하느냐에 따라 문제의 난이도가 변동합니다.

**3단계: 계획 세우기**

알고리즘과 자료구조를 선택합니다.

**4단계: 계획 검증하기**

알고리즘이 요구조건 수행하는지 증명합니다.

수행에 걸리는 시간과 메모리 제한 사항 충족 확인합니다.

**5단계: 계획 수행하기**

구현을 정확하고 효율적으로 작성합니다.

**6단계: 회고하기**

문제와 함께 자신의 경험 기록으로 남깁니다.

해법과 어떤 방식으로 접근했고 찾는데 결정적이었던 깨달음 기록합니다.

틀렸을 때는 어떤 실수를 했는지 기록합니다.

다른 사람의 코드를 보고 통찰을 얻습니다.

**문제를 풀지 못할 때**

시간 내에 풀어보고 못 풀면 다른 사람 코드 보는 것이 좋습니다.

단 풀이를 참조할 때는 반드시 복기를 동반해야 합니다.

왜 자신은 한 번에 이런 풀이가 안떠올랐나 고민해봅니다.

## 2.3 문제 해결 전략

**직관과 체계적인 접근**

중요한 것은 문제와 답의 구조에 대한 직관의 중요성입니다.   
직관은 알고리즘이 어떤 형태일지 짐작하게 해줍니다.   
직관의 발달을 위해선 경험을 쌓아 나가야 합니다.   
막막한 경우 어떻게 체계적으로 아이디어를 접근해야 할까요?

### 비슷한 문제를 풀어본 적이 있는가?

비슷한 문제를 통해 접근 방법 예측이 가능합니다.   
발생 확률이나 경우의 수는 보통 동적 계획법으로 해결합니다.  
가장 짧은 경로는 보통 최단 경로 문제로 해결합니다.   

### 단순한 방법에서 시작할 수 있을까?
비슷한 문제가 떠오르지 않는다면 무엇부터 할까요?   
**"무식하게 풀 수 있을까?"** 라는 질문으로 시작합니다.   
시간과 공간 제약을 무시하고 가장 단순한 알고리즘 먼저 생각해봅니다.   
이후 중복 제거와 효율적인 자료 구조 등 최적화로 해결할 수 있습니다.   

_이 방법으로 해결하지 못하면요?_   
알고리즘의 효율성 판단 기준으로 사용 가능합니다.

**예제 문제**

# $N(N <= 30)$
개의 사탕을 세 명의 어린이에게 나눠줍니다.
사탕의 무게는 모두 20이하의 정수입니다.  
사탕 무게가 가장 무거운 사람과 가벼운 사람의 최소 차이는 얼마일까요?   

**가장 단순한 방법**

각 사탕마다 어느 어린이에게 줄지 결정합니다.   
3^N, 즉 최대 205조개의 방법을 만들어봅니다.

**중복 제거**

받은 사탕이 달라도 무게가 같으면 답은 같습니다.   
무게가 같으면 하나의 상태로 취급 가능합니다.   
사탕 최대 무게가 20입니다.   
각 어린이가 가진 사탕의 양는 0에서 20*N 사이가 됩니다.   
각 상태를 저장하면 (20*N+1)^3, 즉 대략 2억이 필요합니다.

**최적화**

가장 많이 받은 아이와 적게 받은 아이 차이가 20이 넘는다면?   
사탕의 최대 무게가 20이므로 하나를 주면 둘의 차이는 항상 감소합니다.   
즉 원래보다 차이가 감소하므로 20이상은 답이될 수 없습니다.   
따라서 (20*N)/3+20, 즉 대략 1000만을 넘는 경우는 무시해도 됩니다.  

**정렬**

세 어린이 중 누가 더 많이 받는지는 중요하지 않습니다.   
서로 다른 세 수는 여섯 가지 방법으로 나열할 수 있습니다.   
이것을 오름차순으로 정렬된 방법만 탐색해봅시다.    
1/6만큼 줄어드므로 대략 200만개 이하를 탐색하게 됩니다. 

처음보다 대략 1억분의 1로 줄어들었습니다.

### 내가 문제를 푸는 과정을 수식화할 수 있을까?
물론 점진적인 접근 방식이 만능은 아닙니다.   
완전히 새로운 방향에서 접근해야 풀리는 문제도 있습니다.   
이때 시도 가능한 건 **손으로** 간단한 입력을 직접 해결해보는 것입니다.   
해결한 과정을 공식화해서 답을 만드는 알고리즘이 흔히 있습니다.   

_이 방법으로 해결하지 못하면요?_  
풀이 시 어떤 점을 고려해야할 지 알게 됩니다.

### 문제를 단순화할 수 없을까?
문제를 좀 더 쉬운 변형판으로 먼저 풀어보는 방법입니다.   
- 제약 조건을 없애봅니다.
- 계산해야하는 변수의 수를 줄여봅니다.
- 다차원을 1차원을 줄여봅니다.

해결에 대한 직관을 제공할 수 있습니다.

**예제 문제**

2차원 격자에서 N개의 점이 있다고 합시다.  
가로선 혹은 세로선으로만 움직일 수 있습니다.   
따라서 두 점 사이의 거리는 x좌표와 y좌표의 합입니다.   
N개의 점 사이의 거리의 합이 최소가 되는 새 점의 위치는 어딜까요?

**1차원 형태로 바꾸기**

x좌표에서 왼쪽이 오른쪽보다 많다면 왼쪽으로 옮겨야합니다.   
y좌표축과 무관하게 x좌표축에만 연관이 됩니다.   
y좌표도 마찬가지로 축으로 사영한 결과와 같아 두 결과를 합하면 됩니다.


### 그림으로 그려볼 수 있을까?
사람은 숫자의 나열보다 기하학적 도형을 더 직관적으로 받아들입니다.   
- 정수쌍을 2차원 평면 상의 좌표로 그려봅니다.
- 직선상의 구간들로 그려봅니다.

기하학이 아니더라도 유용한 경우가 많습니다.

### 수식으로 표현할 수 있을까?
기존은 직관을 얻기 좋은 방향으로 사고를 전개하는 방식들입니다.   
반대로 평문으로 쓰인 문제를 수식으로 표현하는 것이 도움이 될 수 있습니다.    

### 문제를 분해할 수 있을까?
복잡한 조건 하나보다 단순한 조건 여러 개가 다루기 쉽습니다.   

**예제 문제**
400m 달리기 경주에 N명의 육상 선수가 참여합니다.   
각 선수의 최고기록 best[], 최저기록 worst[]가 있습니다.   
각 선수가 기존 기록 범위 내의 성적만 낼 수 있습니다.
기록을 기준으로 다음 형식의 M개의 신문기사가 나왔습니다.

1. 선수 i는 선수 j에게 반드시 패배한다.
2. 선수 i와 선수 j가 서로에게 이길 가능성이 있다.

이 신문 기사들에 오류가 있는지 확인합니다.   
예를 들어 A가 B에게 항상 이기고 B가 C에게 항상 이깁니다.   
그런데 A와 C가 서로에게 이길 가능성이 있는 건 오류입니다.   

문제 해결을 위해 형식의 오류를 수식으로 표현해봅니다.

1. worst[j] < best[i]
2. (best[j] < worst[i]) && (best[i] < worst[j])

두 조건을 만족하는 식으로 변경되었습니다.

### 뒤에서부터 생각해서 문제를 풀 수 있을까?
문제에 내재된 순서를 바꿔봅니다.

### 순서를 강제할 수 있을까?
순서가 없는 문제에 순서를 강제해봅니다.   
답에는 영향을 주지 않습니다.   
하지만 순서를 지정하면서 제약으로 사고를 도와줍니다.

### 특정 형태의 답만을 고려할 수 있을까?
순서를 강제하는 기법의 연장선으로 **정규화**가 있습니다.   
**정규화**는 형태가 달라도 결과적으로 같은 것들을 묶습니다.   

