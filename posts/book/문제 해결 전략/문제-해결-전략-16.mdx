---
title:  "문제 해결 전략 16"
date:   2021-06-24 00:01:00 +0900
category: book
tags: ['book']
keywords: ['book']
---

# 비트마스크 

## 16.1 도입

현재의 모든 CPU는 이진수를 이용해 모든 자료를 표현합니다.  
이와 같은 디자인 결정은 사실 컴퓨터를 사용하는 우리에게 중요할 때가 있습니다.  
내부적으로 이진수를 사용하는 컴퓨터들은 이진법 관련 연산이 아주 빠릅니다.  
이와 같은 특성을 이용해 정수의 이진수 표현을 자료구조로 쓰는 기법을 **비트마스크**라고 부릅니다.  

- 더 빠른 수행 시간: 대부분 O(1)의 수행 시간을 가집니다.  
- 더 간결한 코드: 다양한 집합 연산을 반복문 없이 한 줄에 쓸 수 있습니다.  
- 더 작은 메모리 사용량: 더 작은 메모리는 더 많은 데이터를 미리 계산해서 저장해둘 수 있습니다.   
  일반적으로 속도가 빨라지고 더 적은 메모리를 사용하므로 캐시 효율이 더 좋습니다.  
- 연관 배열을 배열로 대체: 배열을 배열로 감싸고 있는 형태가 많은데 이 경우 속도가 현저히 감소합니다.  

**용어 정의**

이진수의 한 자리를 비트라고 부릅니다.  

**비트 연산자**

비트마스크를 사용하기 위해서는 정수 변수를 비트별로 조작할 수 있는 비트 연산자를 사용해야 합니다.  

- 비트 AND 연산자는 두 정수를 한 비트씩 비교하며 해당 비트가 모두 켜져 있을 때만 비트를 켭니다.  
- 비트 OR 연산자는 두 비트 중 하나라도 켜져 있을 경우 켭니다.  
- 비트 XOR 연산자는 하나는 켜있고 하나는 꺼져 있을 때 켭니다.
- 비트 NOT 연산자는 켜져있는 비트는 끄고, 꺼져 있는 비트는 켭니다.  
- 시프트 연산자는 왼쪽이든 오른쪽인든 원하는 만큼 움직입니다.  

**유의할 점들**

비트마스크를 쓸 때 가장 많이 하는 실수는 연산자 간의 우선순위를 혼동하는 것입니다.  
비트 연산자의 우선순위는 ==, != 같은 비교 연산자보다 낮습니다.  

두번째로 많이 하는 실수는 64비트 정수를 비트마스크로 사용할 때 발생하는 오버플로입니다.  
원하는 값은 64비트인데 연산자 정수에 64비트 명시를 안하면 오버플로가 발생합니다.  

세번쨰는 부호 있는 정수형의 사용이 있습니다.  
비트를 전부 사용해야할 때는 부호 없는 정수형을 쓰는 것이 좋습니다.  

## 16.2 비트마스크를 이용한 집합의 구현

비트마스크의 가장 중요한 사용 사례는 집합을 구현하는 것입니다.  
이 표현에서 N비트 정수 변수는 0부터 N-1까지의 정수 원소를 가질 수 있는 집합이 됩니다.  
이때 원소 i가 집합에 속해 있는지 여부는 $2^i$를 나타내는 비트가 켜져 있는지 여부로 나타냅니다.  

**피자집 예제**

고객들이 원하는 토핑을 골라 주문할 수 있는 피자집의 주문 시스템을 만듭니다.  
이 피자집에는 0부터 19까지의 번호를 갖는 스무가지의 토핑이 있습니다.  
주문시 토핑을 넣기/넣지 않기를 선택할 수 있습니다.  
그러면 한 피자의 정보는 스무 종류의 원소만을 갖는 집합이 됩니다.  
20가지의 크기를 가진 불리언 집합으로도 표현이 가능합니다.   
비트마스크를 이용하면 빠르고 간단하게 구현이 가능합니다.  

**공집합과 꽉 찬 집합 구하기**

토핑을 올리지 않은 피자와 전부 올린 피자를 표현하려 합니다.  
비트마스크를 이용하는 집합에서 공집합을 표현하는 것은 상수 0입니다.  
꽉 찬 집합을 구하는 것도 간단합니다. 

```java
int fullPizza = (1<<20) - 1;
```

**원소 추가**

집합의 가장 기초적인 연산은 원소를 추가하고 삭제하는 것입니다.  
비트마스크를 사용한 집합에서 원소를 추가한다는 것은 비트를 켜는 것입니다.  
토핑 목록에 원소를 추가합니다.  

페퍼로니의 번호가 p에 주어질 때 다음 코드로 집합 toppings에 토핑을 추가할 수 있습니다.  

```java
toppings |= (1<<p)
```

**원소의 포함 여부 확인**
토핑 목록에 토핑이 잘 추가되었나 확인해 봅시다.  
집합 toppings에 토핑이 포함되어 있는지 다음 코드로 알 수 있습니다.  

```java
if(toppings & (1 << p)) System.out.println("Topping is in");
```

&의 결과값은 0또는
# $1 << p$
가 됩니다.

1이나 true가 반환된다고 생각하면 실수하게 됩니다.  

**원소의 삭제**

마음이 변해서 토핑 목록에서 페퍼로니를 삭제한다고 합시다.  
한가지 방법은
# $1 << p$
에서 toppings를 빼는 것입니다.

```java
toppings &= ~(1<<p);
```

**원소의 토글**

토글은 해당 비트가 켜져있으면 끄고, 꺼져 있으면 켭니다.  
XOR연산을 이용하면 토글 역할을 할 수 있습니다.  

```java
toppings ^= (1 << p);
```

**두 집합에 대해 연산하기**

p번 토핑을 추가하거나 삭제할 때
# $1 << p$
를 사용했는데 이 값은 크기가 1입니다.
이때 크기가 더 큰 집합을 사용해도 이 연산들을 그대로 적용할 수 있습니다.  

```java
int added = (a | b);
int intersection = (a & b);
int remove = (a & ~b);
int toggled = (a ^ b);
```

**집합의 크기 구하기**

비트 마스크를 이용할 때 집합에 포합된 원소의 수를 구하는 쉬운 방법은 딱히 없습니다.  
가장 간단한 방법은 각 비트를 순회하면서 켜져 있는 비트의 수를 직접 셉니다.  

```java
int bitCount(int x){
  if(x == 0) return 0;
  return x % 2 + bitCount(x / 2);
}
```

이것을 최적화할 수 있는 여러가지 방법이 있지만 한정된 시간에 구현하기 힘듭니다.  
이것을 위해 프로그래밍 환경에서 사용할 수 있는 내장 명령어들이 있습니다.  

```java
Integer.bitCount(toppings)
```

**최소 원소 찾기**

집합으로 포함된 가장 작은 원소를 쉽게 구할 수 있습니다.  
이 연산은 정수의 이진수 표현에서 끝에 붙어 있는 0이 몇개 인가? 형태입니다.  
켜져있는 최하위 비트 밑의 비트들은 전부 0일 것입니다.  
이 연산은 켜져있는 최하위 비트의 번호를 반환하게 됩니다.  

```java
Integer.numberOfTrailingZeros(toppings)
```

최하위 비트의 번호 대신 해당 비트를 직접 구하고 싶으면 어떻게 할까요?  

```java
int firstTopping = (toppings & -toppings);
```

컴퓨터의 음수를 표현학디 위해 2의 보수를 사용한다는 점입니다.  
2의 보수를 사용하는 음수는 비트에 NOT연산을 적용하고 1을 더합니다.  
이때 1을 더하면 최하위 비트까지 0이 됩니다.  

**최소 원소 지우기**

```java
toppings &= (toppings -1);
```
최소원소가 무엇인지 상관 없이 최소 원소를 지울 수 있습니다.  
최소 원소를 얻은 뒤, 그 원소를 지우는 것보다 훨씬 간결하지요.  

**모든 부분 집합 순회하기**

```java
for(int subset = pizza; subset; subset = ((subset-1) & pizza)){
  // subset은 pizza의 부분 집합
}
```

## 16.4 문제: 졸업 학기

졸업을 위해서 전공과목 N개 중 K개 이상을 수강해야 합니다.  
그런데 각 과목은 해당 과목의 선수과목을 미리 수강해야 수강할 수 있습니다.  
각 학기마다 모든 과목이 개설되는 것은 아닙니다.  
어떻게 해야 최소 학기에 졸업할 수 있을까요?  
각 과목의 정보와 앞으로 M학기 동안 개설될 과목의 목록이 주어집니다.  
태우가 최소 몇 학기를 다녀야 졸업할 수 있는지 계산합니다.  
한 과목도 수강하지 않는 학기는 휴학한 것으로 하며, 다닌 학기 수에 포함되지 않습니다.  

## 16.5 풀이: 졸업 학기

이 문제를 푸는 알고리즘은 전형적인 지수 시간 동적계획법입니다.  

**동적 계획법 알고리즘의 설계**

완전 탐색으로 알고리즘을 설계하고 메모리제이션으로 최적화해야 합니다.  
완전 탐색을 위해서 문제를 여러 조각으로 나눈 다음 한 조각을 해결하고 다음 조각을 재귀 호출합니다.  
이 문제에서는 각 학기를 한 조각으로 나눌 수 있습니다.  
완전 탐색으로 구현하는 방법은 각 학기마다 들을 수 있는 모든 과목의 조합을 만들어봅니다.  
이 때 들을 수 있는 과목의 조합을 만들 때 비트마스크가 유용합니다.  

주어진 집합의 부분 집합을 순회하는 코드를 쉽게 작성할 수 있습니다.  