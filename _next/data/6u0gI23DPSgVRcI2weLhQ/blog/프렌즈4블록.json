{"pageProps":{"postMetadata":{"layout":"post","title":"[프로그래머스] 프렌즈4블록 (JAVA)","date":"2022-01-11 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"프렌즈4블록"},"postContent":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      pre: \"pre\",\n      code: \"code\",\n      h2: \"h2\",\n      p: \"p\",\n      br: \"br\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"class Solution {\\n    boolean[][] visited;\\n    char[][] blocks;\\n    int[] dy = {0, 1, 0, 1};\\n    int[] dx = {0, 0, 1, 1};\\n\\n    public int solution(int m, int n, String[] board) {\\n        blocks = new char[m][];\\n        int answer = 0;\\n        for (int i = 0; i < board.length; i++)\\n            blocks[i] = board[i].toCharArray();\\n\\n        while (true) {\\n            int count = 0;\\n            visited = new boolean[m][n];\\n            for (int i = 0; i < m; i++) {\\n                for (int j = 0; j < n; j++) {\\n                    if (blocks[i][j] == Character.MIN_VALUE) continue;\\n                    if (!isMatched(i, j)) continue;\\n                    count += checkVisited(i, j);\\n                }\\n            }\\n            if (count == 0) break;\\n            removeBlocks(m, n);\\n            arrangeBlocks(m, n);\\n            answer += count;\\n        }\\n        return answer;\\n    }\\n\\n    private void removeBlocks(int m, int n) {\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (visited[i][j])\\n                    blocks[i][j] = Character.MIN_VALUE;\\n            }\\n        }\\n    }\\n\\n    private void arrangeBlocks(int m, int n) {\\n        for (int j = 0; j < n; j++) {\\n            for (int i = m - 1; i >= 0; i--) {\\n                if (blocks[i][j] != Character.MIN_VALUE) continue;\\n                int next = i - 1;\\n                while (next >= 0 && blocks[next][j] == Character.MIN_VALUE) {\\n                    next--;\\n                }\\n                if (next < 0) break;\\n                blocks[i][j] = blocks[next][j];\\n                blocks[next][j] = Character.MIN_VALUE;\\n            }\\n        }\\n    }\\n\\n    private boolean isMatched(int y, int x) {\\n        for (int i = 1; i < 4; i++) {\\n            int ny = dy[i] + y;\\n            int nx = dx[i] + x;\\n            if (ny >= blocks.length || nx >= blocks[0].length) return false;\\n            if (blocks[ny][nx] != blocks[y][x]) return false;\\n        }\\n        return true;\\n    }\\n\\n    private int checkVisited(int y, int x) {\\n        int visitCount = 0;\\n        for (int i = 0; i < 4; i++) {\\n            int ny = dy[i] + y;\\n            int nx = dx[i] + x;\\n            if (!visited[ny][nx]) visitCount++;\\n            visited[ny][nx] = true;\\n        }\\n        return visitCount;\\n    }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"실수했던 점\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"dfs로 재귀함수로 작성했을 때 시간초과가 발생했습니다.\", _jsx(_components.br, {}), \"\\n\", \"이전에도 그랬지만 되도록 반복문으로 처리해야겠습니다.\", _jsx(_components.br, {}), \"\\n\", \"중복되는 부분들을 더 최적화할 수 있을 것 같습니다.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"프렌즈4블록"},"__N_SSG":true}