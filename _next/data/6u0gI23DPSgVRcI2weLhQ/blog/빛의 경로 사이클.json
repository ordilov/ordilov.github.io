{"pageProps":{"postMetadata":{"layout":"post","title":"[프로그래머스] 빛의 경로 사이클 (JAVA)","date":"2022-01-03 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"빛의 경로 사이클"},"postContent":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      pre: \"pre\",\n      code: \"code\",\n      h3: \"h3\",\n      p: \"p\",\n      br: \"br\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"import java.util.ArrayList;\\nimport java.util.List;\\n\\npublic class Solution {\\n\\n    // S, L, R 순\\n    // 좌, 상, 우, 하 순\\n    int[][] dy = { {0, 1, 0, -1}, {-1, 0, 1, 0}, {1, 0, -1, 0} };\\n    int[][] dx = { {1, 0, -1, 0}, {0, 1, 0, -1}, {0, -1, 0, 1} };\\n    int[][] dd = { {0, 1, 2, 3}, {3, 0, 1, 2}, {1, 2, 3, 0} };\\n    boolean[][][] visited;\\n    char[][] dir;\\n    int count;\\n\\n    public int[] solution(String[] grid) {\\n        /*\\n        시작할 수 있는 위치 모든 점 * 4\\n        */\\n        dir = new char[grid.length][];\\n        for(int i = 0; i < grid.length; i++){\\n            dir[i] = grid[i].toCharArray();\\n        }\\n        visited = new boolean[dir.length][dir[0].length][4];\\n        List<Integer> list = new ArrayList<>();\\n\\n        for(int i = 0; i < dir.length; i++){\\n            for(int j = 0; j < dir[i].length; j++){\\n                for(int k = 0; k < 4; k++){\\n                    if(visited[i][j][k]) continue;\\n                    count = 0;\\n                    dfs(i, j, k);\\n                    list.add(count);\\n                }\\n            }\\n        }\\n        return list.stream().sorted().mapToInt(Integer::intValue).toArray();\\n    }\\n\\n    void dfs(int y, int x, int d){\\n\\n        while(!visited[y][x][d]){\\n            visited[y][x][d] = true;\\n            count++;\\n            int m = Direction.valueOf(String.valueOf(dir[y][x])).value;\\n            y = (y + dy[m][d] + dir.length) % dir.length;\\n            x = (x + dx[m][d] + dir[0].length) % dir[0].length;\\n            d = dd[m][d];\\n        }\\n    }\\n\\n    enum Direction{\\n        S(0), L(1), R(2);\\n        private final int value;\\n        Direction(int value) {\\n            this.value = value;\\n        }\\n    }\\n\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"실수했던 점\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"실제 시험 때 풀어보려다가 일이 생겨서 못 풀었던 문제였습니다.\", _jsx(_components.br, {}), \"\\n\", \"다시 풀어보려했을 때도 막막해보였지만 이번에는 방법이 보였습니다.\", _jsx(_components.br, {}), \"\\n\", \"그런데 테스트케이스 하나에서 계속 런타임 에러가 발생했습니다.\", _jsx(_components.br, {}), \"\\n\", \"배열 크기가 넘어가는 문제가 있나 계속 봤지만 찾을 수 없었습니다.\", _jsx(_components.br, {}), \"\\n\", \"그러다 최적화를 하다가 문제를 고칠 수 있었습니다.\", _jsx(_components.br, {}), \"\\n\", \"런타임 에러가 생겼던 이유는 재귀 함수로 인한 스택 오버 플로우였습니다.\", _jsx(_components.br, {}), \"\\n\", \"재귀함수를 썼는데 이유를 알 수 없는 런타임 에러라면 의심해볼만 합니다.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"빛의 경로 사이클"},"__N_SSG":true}