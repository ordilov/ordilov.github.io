{"pageProps":{"postMetadata":{"layout":"post","title":"[프로그래머스] 파일명 정렬 (JAVA)","date":"2022-01-08 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"파일명 정렬"},"postContent":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      pre: \"pre\",\n      code: \"code\",\n      h2: \"h2\",\n      p: \"p\",\n      strong: \"strong\",\n      br: \"br\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"import java.util.Map;\\nimport java.util.LinkedHashMap;\\nimport java.util.Arrays;\\nimport java.util.regex.Matcher;\\nimport java.util.regex.Pattern;\\nclass Solution {\\n    public String[] solution(String[] files) {\\n        /*\\n        HEAD 대소문자 구분 X\\n        앞에 0 무시 숫자 순\\n        TAIL은 순서에 영향 X\\n        */\\n        Map<String, FileName> fileNames = new LinkedHashMap<>();\\n        Pattern numberPattern = Pattern.compile(\\\"[0-9]+\\\");\\n        for (String file : files) {\\n            Matcher matcher = numberPattern.matcher(file);\\n            matcher.find();\\n            String head = file.substring(0, matcher.start()).toLowerCase();\\n            int number = Integer.parseInt(matcher.group());\\n            fileNames.put(file, new FileName(head, number));\\n        }\\n\\n        Arrays.sort(files, (o1, o2) -> {\\n            FileName fileName1 = fileNames.get(o1);\\n            FileName fileName2 = fileNames.get(o2);\\n\\n            if (!fileName1.head.equals(fileName2.head))\\n                return fileName1.head.compareTo(fileName2.head);\\n\\n            return fileName1.number - fileName2.number;\\n        });\\n\\n        return files;\\n    }\\n\\n    static class FileName {\\n        String head;\\n        int number;\\n\\n        public FileName(String head, int number) {\\n            this.head = head;\\n            this.number = number;\\n        }\\n    }\\n\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"몰랐던 점\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"map에서 입력한 순서를 유지할 때 \", _jsx(_components.strong, {\n          children: \"LinkedHashMap\"\n        }), \"을 사용합니다.\\nJava에서 정규식을 사용할 때 \", _jsx(_components.strong, {\n          children: \"Pattern\"\n        }), \"과 \", _jsx(_components.strong, {\n          children: \"Matcher\"\n        }), \"를 사용해야 합니다.\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n          children: \"Pattern\"\n        }), \"은 정규식 패턴을 만들고 패턴과 일치하는지 확인할 수 있습니다.\", _jsx(_components.br, {}), \"\\n\", \"일치된 패턴을 해석할 때 \", _jsx(_components.strong, {\n          children: \"Matcher\"\n        }), \"를 이용합니다.\", _jsx(_components.br, {}), \"\\n\", _jsx(_components.strong, {\n          children: \"find\"\n        }), \"로 다음 패턴을 찾고 \", _jsx(_components.strong, {\n          children: \"group\"\n        }), \"으로 찾은 값을 반환 받을 수 있습니다.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"파일명 정렬"},"__N_SSG":true}