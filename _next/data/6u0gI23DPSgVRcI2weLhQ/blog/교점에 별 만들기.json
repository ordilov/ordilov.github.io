{"pageProps":{"postMetadata":{"title":"[프로그래머스] 빛의 경로 사이클 (JAVA)","date":"2022-01-03 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"교점에 별 만들기"},"postContent":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      pre: \"pre\",\n      code: \"code\",\n      h3: \"h3\",\n      p: \"p\",\n      br: \"br\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"import java.util.Arrays;\\nimport java.util.HashSet;\\nimport java.util.Objects;\\nimport java.util.Set;\\n\\npublic class Solution {\\n\\n    public String[] solution(int[][] line) {\\n        /*\\n        Ax + By + E = 0\\n        Cx + Dy + F = 0\\n        */\\n        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;\\n        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;\\n        Set<Pair> set = new HashSet<>();\\n        for (int i = 0; i < line.length; i++) {\\n            for (int j = i + 1; j < line.length; j++) {\\n                if (i == j) continue;\\n                long A = line[i][0];\\n                long B = line[i][1];\\n                long E = line[i][2];\\n                long C = line[j][0];\\n                long D = line[j][1];\\n                long F = line[j][2];\\n\\n                long down = A * D - B * C;\\n                long ux = B * F - E * D;\\n                long uy = E * C - A * F;\\n                if (down == 0 || ux % down != 0 || uy % down != 0) continue;\\n                minX = Math.min(minX, (int) (ux / down));\\n                maxX = Math.max(maxX, (int) (ux / down));\\n                minY = Math.min(minY, (int) (uy / down));\\n                maxY = Math.max(maxY, (int) (uy / down));\\n                set.add(new Pair((int) (uy / down), (int) (ux / down)));\\n            }\\n        }\\n        int x = (int) (maxX - minX + 1);\\n        int y = (int) (maxY - minY + 1);\\n        char[][] map = new char[y][x];\\n        String[] answer = new String[y];\\n\\n        for (char[] m : map)\\n            Arrays.fill(m, '.');\\n\\n        for (Pair p : set)\\n            map[p.y - minY][p.x - minX] = '*';\\n\\n        for (int i = 0; i < y; i++) {\\n            answer[i] = new String(map[y - 1 - i]);\\n        }\\n\\n        return answer;\\n    }\\n\\n    static class Pair implements Comparable<Pair> {\\n        int y, x;\\n\\n        public Pair(int y, int x) {\\n            this.y = y;\\n            this.x = x;\\n        }\\n\\n        @Override\\n        public boolean equals(Object o) {\\n            if (this == o) return true;\\n            if (o == null || getClass() != o.getClass()) return false;\\n            Pair pair = (Pair) o;\\n            return y == pair.y && x == pair.x;\\n        }\\n\\n        @Override\\n        public int hashCode() {\\n            return Objects.hash(y, x);\\n        }\\n\\n        @Override\\n        public int compareTo(Pair o) {\\n            if (y == o.y) {\\n                return x - o.x;\\n            }\\n            return Integer.compare(y, o.y);\\n        }\\n    }\\n\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h3, {\n        children: \"실수했던 점\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"공식이 주어져서 구현만 잘하면 되는 문제라고 생각했습니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 테스트케이스 한 두개에서 계속 실패했습니다.\", _jsx(_components.br, {}), \"\\n\", \"로직상으로 잘못된 부분이 없다고 생각해서 오래 고민했습니다.\", _jsx(_components.br, {}), \"\\n\", \"그러다 찾은 문제는 자료형의 크기였습니다.\", _jsx(_components.br, {}), \"\\n\", \"최대로 나올 수 있는 크기가 10만 * 10만이라 100억까지 가게됩니다.\", _jsx(_components.br, {}), \"\\n\", \"음수로 처리되서 계속해서 잘못된 값이 나왔습니다.\", _jsx(_components.br, {}), \"\\n\", \"코딩하기 전에 최대값을 계산하고 자료형을 선택해야겠습니다.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"교점에 별 만들기"},"__N_SSG":true}