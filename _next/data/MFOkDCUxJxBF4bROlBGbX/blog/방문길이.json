{"pageProps":{"postMetadata":{"layout":"post","title":"[프로그래머스] 방문 길이 (JAVA)","date":"2022-01-06 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"방문길이"},"postContent":{"compiledSource":"/*@jsxRuntime automatic @jsxImportSource react*/\nconst {Fragment: _Fragment, jsx: _jsx, jsxs: _jsxs} = arguments[0];\nconst {useMDXComponents: _provideComponents} = arguments[0];\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? _jsx(MDXLayout, Object.assign({}, props, {\n    children: _jsx(_createMdxContent, {})\n  })) : _createMdxContent();\n  function _createMdxContent() {\n    const _components = Object.assign({\n      pre: \"pre\",\n      code: \"code\",\n      h2: \"h2\",\n      p: \"p\",\n      br: \"br\"\n    }, _provideComponents(), props.components);\n    return _jsxs(_Fragment, {\n      children: [_jsx(_components.pre, {\n        children: _jsx(_components.code, {\n          className: \"language-java\",\n          children: \"class Solution {\\n    \\n    private static final int MAX_X = 10, MAX_Y = 10, MIN_X = 0, MIN_Y = 0;\\n    \\n    public int solution(String dirs) {\\n        boolean[][][] visited = new boolean[10][10][2];\\n        int answer = 0, y = 5, x = 5;\\n        for(String dir : dirs.split(\\\"\\\")){\\n            DIRECTION d = DIRECTION.valueOf(dir);\\n            int vertical = d.vertical;\\n            int ny = y + d.y;\\n            int nx = x + d.x;\\n            if(nx > MAX_X || nx < MIN_X || ny > MAX_Y || ny < MIN_Y) continue;\\n            int pointY = Math.max(y, ny);\\n            int pointX = Math.max(x, nx);\\n            y = ny; \\n            x = nx;\\n            if(visited[pointY][pointX][vertical]) continue;\\n            visited[pointY][pointX][vertical] = true;\\n            answer++;\\n        }\\n        return answer;\\n    }\\n    \\n    enum DIRECTION {\\n        U(1, 0, 0), D(-1, 0, 0), R(0, 1, 1), L(0, -1, 1);\\n        final int y, x, vertical;\\n        DIRECTION(int y, int x, int vertical){\\n            this.y = y;\\n            this.x = x;\\n            this.vertical = vertical;\\n        }\\n    }\\n}\\n\"\n        })\n      }), \"\\n\", _jsx(_components.h2, {\n        children: \"실수했던 점\"\n      }), \"\\n\", _jsxs(_components.p, {\n        children: [\"처음에 방문한 위치를 선 기준이 아니라 점 기준으로 잡아서 틀렸습니다.\", _jsx(_components.br, {}), \"\\n\", \"선 기준으로 잡기 위해서 선의 두 점 중에서 더 큰 점을 기준으로 체크했습니다.\", _jsx(_components.br, {}), \"\\n\", \"그 다음으로 개선한 방법은 반복문을 인덱스로 처리하고 있었습니다.\", _jsx(_components.br, {}), \"\\n\", \"하지만 split을 이용하면 문자열 배열을 이용할 수 있다는 것을 찾아 수정했습니다.\"]\n      })]\n    });\n  }\n}\nreturn {\n  default: MDXContent\n};\n","frontmatter":{},"scope":{}},"id":"방문길이"},"__N_SSG":true}