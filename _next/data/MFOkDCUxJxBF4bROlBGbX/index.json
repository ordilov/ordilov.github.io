{"pageProps":{"postsMetaData":[{"metadata":{"layout":"post","title":"TIL 210309","date":"2022-03-09 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220309TIL"},"content":"\n## Real MySQL 8.0\n14:03 ~ 18:00\n- 8\n\n## 서버 작업 복습\n18:30 ~ 11:30"},{"metadata":{"layout":"post","title":"Spring JSON 한글 깨지는 경우","date":"2022-03-08 00:01:00 +0900","category":"trouble","tags":["trouble"],"keywords":["trouble"],"id":"JSON 한글 깨짐"},"content":"\n응답을 직접 보낼 때 한글이 깨지는 경우 CharacterSet을 설정해줘야 합니다.\n```java\n HttpServletResponse response;\n \n response.setCharacterEncoding(\"UTF-8\");\n```\n"},{"metadata":{"layout":"post","title":"Spring Filter 내부 Exception","date":"2022-03-08 00:01:00 +0900","category":"trouble","tags":["trouble"],"keywords":["trouble"],"id":"Filter 내부 Exception"},"content":"\n@RestControllerAdvice로 에러를 전역처리하는데 filter 내부에서 에러는 처리되지 않았습니다.\n이 경우 처리를 위해서 겪을 수 있는 문제점들이 있습니다.\n\n### AuthenticationEntryPoint\n인증되지 않은 에러인 401 에러인 경우 필터를 거치고 AuthenticationEntryPoint 구현체에서 에러가 처리됩니다.\n이 인터페이스를 구현하고 commence 메서드를 오버라이드하면 커스텀 처리가 가능해집니다.\n\n```java \npublic class RestAuthenticationEntryPoint implements AuthenticationEntryPoint {\n\n  @Override\n  public void commence(HttpServletRequest request, HttpServletResponse response,\n      AuthenticationException e) throws IOException {\n    log.error(\"잘못된 인증 요청이 들어왔습니다. Message - {}\", e.getMessage());\n\n    ErrorCode errorCode = (ErrorCode) request.getAttribute(\"errorCode\");\n    if (errorCode == null) {\n      errorCode = ErrorCode.UNAUTHORIZED;\n    }\n\n    ObjectMapper mapper = new ObjectMapper();\n    String error = mapper.writeValueAsString(CommonResponse.fail(errorCode));\n\n    response.setCharacterEncoding(\"UTF-8\");\n    response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n    response.setContentType(MediaType.APPLICATION_JSON_VALUE);\n    response.getWriter().write(error);\n  }\n}\n```\n\n### Filter 중간에서 처리\nFitler 중간에서 메서드 파리미터로 넘어온 HttpServletResponse를 이용해 중간에 응답을 보낼 수 있습니다.\n방법으로는 sendError 메서드를 이용하거나 response에 write 하는 방식으로 중간에 응답을 보내면 됩니다.\n하지만 중간에서 처리하는 경우 응답 보낸 response를 다음 filter로 보내면 안됩니다.\n응답이 이미 처리된 형태이기 때문에 다음 필터로 넘어가면 에러가 발생합니다.\n\n```java \nresponse.sendError(HttpServletResponse.SC_UNAUTHORIZED, \"Unauthorized\");\n\n...\n\nfilterChain.doFilter(request, response); // 에러 \n```\n"},{"metadata":{"layout":"post","title":"TIL 210308","date":"2022-03-08 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220308TIL"},"content":"\n## Real MySQL 8.0\n08:37 ~ 10:37\n- 5\n\n## 알고리즘\n10:47 ~ 11:30 \n- 테트로미노\n\n## 리슨 서버 작업\n15:30 ~ 21:30\n- 회원 리팩토링\n\n"},{"metadata":{"layout":"post","title":"TIL 210307","date":"2022-03-07 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220307TIL"},"content":"\n## 리슨 서버 작업\n09:47 ~ 11:30\n- 테스트 코드 수정\n- 클린 아키텍처 비교\n\n## Real MySQL 8.0\n14:00 ~ 16:30\n- 4 ~ 5\n\n## 알고리즘 문제\n16:40 ~ 17:10\n\n\n## 리슨 서버 작업\n17:30 ~ 23:00\n- access Token\n- 테스트 코드 에러 이유\n\n## 리슨 프론트 작업\n- 모바일 Viewport 추가"},{"metadata":{"layout":"post","title":"TIL 210306","date":"2022-03-06 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220306TIL"},"content":"\n## 만들면서 배우는 클린 아키텍처\n13:30 ~ 19:00\n\n## 2xn 타일링 2 \n19:10 ~ 19:20\n\n## 리슨 서버 작업\n19:20 ~ 23:00\n\n\n"},{"metadata":{"title":"Real MySQL 8.0 (4)","date":"2022-03-05 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"Reay MySQL 04"},"content":"\n# 인덱스\n인덱스는 데이터베이스 쿼리 성능에 중요하며 각 인덱스마다 특성과 차이가 있습니다.\n\n## 디스크 읽기 방식\n먼저 디스크 읽기 방식에는 랜덤 I/O와 순차 I/O가 존재합니다.\n데이터 저장 매체는 컴퓨터에서 가장 느린 부분으로 데이터베이스 성능 튜닝도 디스크 I/O를 줄이는 것이 중요합니다.\n\n### HDD와 SDD\nCPU나 메모리는 전자식 장치지만 하드 디스크 드라이브는 기계식 장치로 병목 지점이 됩니다.\n이 때문에 전자식 저장 매체인 SSD를 많이 사용합니다.\n\n순차 I/O에서는 SSD가 하드 디스크 드라이브와 비슷한 속도를 내지만 랜덤 I/O에서는 훨씬 빠릅니다.\n데이터베이스에서는 순차적으로 읽기보다 작은 데이터를 랜덤으로 읽고 쓰는 일이 많아 SSD가 유리합니다.\n\n### 랜덤 I/O와 순차 I/O\n랜덤 I/O 라는 표현은 하드 디스크 드라이브의 플래터를 돌려서 데이터가 저장된 위치를 디스크 헤더로 이동시켜 읽는 걸 의미합니다.\n그 다음 데이터를 읽는 것은 순차 I/O나 랜덤 I/O나 동일합니다.\n차이점은 순차로 읽는 경우 한 번의 시스템 콜이면 연속적으로 읽을 수 있지만 랜덤은 개별로 다시 요청해야 합니다.\n그만큼 디스크 헤더를 옮기면서 시간이 오래 걸리게 됩니다.\n즉 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 기록하느냐에 결정됩니다.\n디스크 원판이 없는 SSD에서도 랜덤 I/O는 전체 스루풋이 떨어집니다.\n\n쿼리를 튜닝해서 랜덤 I/O를 순차 I/O로 바꿔서 실행할 방법은 많지 않지만 목적은 랜덤 I/O 자체를 줄여주는 것입니다.\n꼭 필요한 데이터만 읽도록 쿼리를 개선하는 작업입니다.\n\n## 인덱스란?\n인덱스는 말그대로 목차에 해당하며 원하는 페이지의 주소를 빨리 찾기 위해 부분마다 찾아갈 수 있는 정보를 정렬해서 보관합니다.\n다른 특징으로 데이터는 ArrayList처럼 정렬 없이 보관되어 있지만 인덱스는 SortedList처럼 항상 정렬된 상태를 유지합니다.\n\nSortedList처럼 인덱스도 장단점이 존재하는데 값이 저장될 때마다 항상 정렬이 필요해 느리지만, 값을 찾을 때는 빠릅니다.\n데이터의 저장 성능을 희생해 읽기 속도를 높이는 기능입니다.\n\n프라이머리 키는 레코드를 대표하는 칼럼의 값으로 만들어진 인덱스를 의미합니다. 중복이나 NULL을 허용하지 않습니다.\n프라이머리 키를 제외한 인덱스는 모두 세컨더리 인덱스로 분류합니다.\n\n인덱스 저장 방식은 대표적으로 B-Tree와 Hash 인덱스로 구분합니다.\n둘의 차이점은 B-Tree는 칼럼 값을 변형하지 않고 인덱싱하고 Hash는 값을 변형해서 인덱싱합니다.\n완전 일치 값일 때는 Hash가 빠르지만 값을 변형해서 사용해 값의 일부 일치나 범위 검색에 사용할 수 없습니다.\n\n데이터의 중복 허용 여부로 분류하면 유니크 인덱스와 유니크하지 않은 인덱스로 구분합니다.\n이는 옵타마이저에게 상당히 중요한게 유니크 인덱스를 동등 조건으로 비교하면 1건만 찾으면 검색을 종료해도 됨을 알려줍니다.\n\n## B-Tree 인덱스\n가장 먼저 도입되었고 일반적이며 범용적인 목적으로 사용되는 인덱스 알고리즘입니다.\n일반적으로 B-Tree의 변형된 형태인 B+-Tree 또는 B*-Tree로 사용됩니다.\nB-Tree의 B는 Balanced를 의미합니다.\n\n### 구조 및 특성\nB-Tree는 트리 구조의 최상위에 하나의 루트 노드가 존재하고 하위에 자식 노드가 붙어있습니다.\n가장 하위에 있는 노드를 리프 노드, 트리 구조에서 루트 노드도 아니고 리프 노드도 아닌 중간 노드를 브랜치 노드라고 합니다.\n인덱스는 실제 데이터가 저장된 데이터는 다로 관리되는데 리프 노드가 실제 데이터 레코드를 찾아 가기 위한 주솟값을 가집니다.\n인덱스의 키 값은 모두 정렬되어 있지만 데이터 파일의 레코드는 정렬되어 있지 않고 임의의 순서로 저장되어 있습니다.\n레코드가 INSERT한 순서대로 저장되어 있지 않고 가능한 공간에 넣도록 설계되어 있어 순서는 달라질 수 있습니다.\n\n### B-Tree 인덱스 키 추가\nB-Tree에 새로운 값이 저장될 때 저장될 위치를 검색하고 리프 노드에 레코드의 키 값과 주소 정보를 저장합니다.\n리프 노드가 꽉차서 더 자장할 수 없는 경우 리프 노드를 분리해야 하는데, 이 작업에서 상위 브랜치 노드까지 처리해야 합니다.\n이런 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 듭니다.\n이로 인한 영향의 크기를 대략적으로 계산하면 기본 비용이 1일 때 인덱스 추가 작업은 1.5 정도로 계산합니다.\n\n### 인덱스 키 삭제\n키 값이 삭제되는 경우는 해당 키의 리프 노드를 찾아서 삭제 마크만 하면 됩니다.\n삭제 마킹된 공간은 그대로 방치해서 재활용할 수 있습니다.\n마킹 작업조차도 디스크 쓰기가 필요하기 때문에 InnoDB에서는 버퍼링되어 지연 처리될 수 있습니다.\nMyISAM이나 MEMORY 엔진의 경우 버퍼 기능이 없으므로 인덱스 키가 바로 삭제됩니다.\n\n### 인덱스 키 변경\n인덱스의 키 값은 리프 노드의 위치와 연관되어 있기 때문에 단순 인덱스 키 값 변경은 불가능합니다.\n변경을 위해선 키 값을 삭제하고 다시 새로운 키값을 추가하는 형태로 처리됩니다.\n키 값의 변경 때문에 발생하는 B-Tree 인덱스 키 값의 삭제와 추가 작업은 절차대로 처리됩니다.\n\n### 인덱스 키 검색\n인덱스 검색은 루트 노드부터 시작해서 최종 리프 노드까지 이동하며 비교 작업을 수행하며 이를 트리 검색이라고 합니다.\n트리 검색은 SELECT 뿐만 아니라 UPDATE, DELETE 시에도 해당 레코드를 먼저 검색해야 할 때도 사용됩니다.\nB-Tree 인덱스 검색은 완전 일치나 앞 부분 일치, 비교 조건에도 활용할 수 있습니다.\n하지만 앞 부분을 잘라서 키 값으로 사용하기 때문에 뒷부분만 검색하는 용도로는 사용할 수 없습니다.\n또 함수나 연산 수행 결과로 인덱스 키 값에 변형된 경우 B-Tree 검색 기능을 사용할 수 없습니다.\n\n### B-Tree 인덱스 사용에 영향을 미치는 요소\n인덱스를 구성하는 칼럼의 크기, 레코드 건수, 유니크한 인덱스 키 값의 개수등에 따라 영향을 받습니다.\n\n### 인덱스 키 값의 크기\nInnoDB 엔진은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며 읽기, 쓰기 작업의 최소 작업 단위입니다.\n페이지는 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 합니다.\n인덱스도 결국은 페이지 단위로 관리되며 루트와 브랜치, 리프 노드도 페이지 단위로 구분됩니다.\n\n이진 트리는 각 노드가 자식 노드 2개만 가지는데 B-Tree가 이진 트리라면 인덱스 검색이 상당히 비효율적입니다.\n따라서 B-Tree의 자식 노드의 개수는 가변적으로 페이지 크기와 키 값의 크기에 따라 결정됩니다.\n인덱스의 페이지 크기의 기본값은 16KB로 4KB ~ 64KB 사이의 값으로 선택할 수 있습니다.\n인덱스의 키 값의 크기를 16바이트라고 하면 키 값과 함께 6 ~ 12바이트 크기의 자식 노드 주소를 담은 데이터가 위치합니다.\n\n여기서 저장할 수 있는 키의 개수는 `페이지 크기 / (키 값의 크기 + 자식 노드 주소 크기)` 가 됩니다.\n인덱스 키 값이 커지면 그만큼 저장할 수 있는 키의 개수가 줄어들게 됩니다.\n레코드를 찾을 때 이 개수를 넘는 만큼 디스크로부터 읽어야 하는 횟수가 늘어나고 그만큼 으려지게 됩니다.\n또 키 값의 크기가 늘어나면 인덱스를 캐시해두는 영역에 보관할 수 있는 양이 줄어들어 메모리 효율이 줄어듭니다.\n\n### B-Tree 깊이\nB-Tree의 깊이는 중요하지만 직접 제어할 방법은 없습니다. 인덱스 키 값이 커질수록 페이지에 담을 수 개수가 적어져 깊이가 깊어집니다.\n따라서 중요한 것은 인덱스 키 값은 가능하면 작게 만드는 것이 좋습니다.\n\n### 선택성\n선택도 또는 기수성은 거의 같은 의미로 사용되며 인덱스 키 값 가운데 유니크한 값의 수를 의미합니다.\n인덱스 키 값이 100개일 때 유니크한 값의 수가 10개라면 기수성은 10입니다.\n인덱스 키 값 가운데 중복된 값이 많아질 수록 기수성은 낮아지고 선택도가 떨어집니다.\n인덱스는 선택도가 높을수록 검색 대상이 줄어들기 때문에 그만큼 빠르게 처리됩니다.\n\n예를 들어 레코드 건수가 1만 건이고 한 칼럼으로 인덱스가 생성된 두 케이스를 비교하겠습니다.\n- 케이스 A: 칼럼의 유니크한 값의 개수가 10개\n- 케이스 B: 칼럼의 유니크한 값의 개수가 1000개\n\nWhere으로 해당 칼럼을 비교하는 경우 A는 1000개씩 비교하고 B는 10개씩 비교하게 됩니다.\n만약 해당 케이스의 데이터가 1개라고 한다면 비교할 때 A는 1을 위해 999개를 더 읽게 됩니다.\nB는 1을 위해 9건만 더 읽을 수 있기 때문에 효율적입니다.\n\n### 읽어야 하는 레코드의 건수\n인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 레코드를 읽는 것보다 비용이 높습니다.\n예를 들어 100만 개의 레코드에서 50만 건을 읽을 때 전부 읽고 50만 건을 버릴지, 인덱스로 50만 건만 읽어올지 판단해야 합니다.\n옵티마이저에서 인덱스를 통해 1건을 읽는 게 직접 1건 읽는 것보다 4~5배 비용이 더 든다고 예측합니다.\n인덱스를 통해 읽어야할 레코드의 건수가 전체 테이블 레코드의 20~25%를 넘어서면 인덱스 대신 모두 읽어서 필터링합니다.\n\n100만건 중 50만 건을 읽는 경우 50%나 되기 때문에 인덱스 대신 테이블을 처음부터 끝까지 읽어서 처리합니다.\n인덱스를 사용하도록 힌트를 추가해도 성능성 얻을 수 있는 이점도 없고 옵티마이저가 기본적으로 무시해서 처리합니다.\n\n### B-Tree 인덱스를 통한 데이터 읽기\n어떤 경우에 인덱스를 사용하게 유도할지, 사용하지 못하게 할지 판단하려면 어떻게 인덱스를 이용해서 실제 레코드를 읽는지 알아야 합니다.\n\n### 인덱스 레인지 스캔\n인덱스 레인지 스캔은 인덱스의 접근 방법 중 대표적인 접근 방식으로 다른 방법보다 빠른 방법입니다.\n인덱스를 통해 레코드를 한 건만 읽는 경우와 한 건 이상 읽는 경우 다른 이름으로 구분하지만 묶어서 인덱스 레인지 스캔으로 표현할 수 있습니다.\n인덱스 레인지 스캔은 검색해야할 인덱스의 범위가 결정됐을 때 사용하는 방식입니다.\n검색하려는 수나 검색 결과 레코드 건수와 관계없이 레인즈 스캔이라고 합니다.\n브랜치 노드에서 리프 노드까지 찾아들어가 시작 지점을 찾고서 순서대로 리프 노드를 읽으면 됩니다.\n차례대로 쭉 일갇가 리프 노드 끝가지 읽으면 리프 노드 간의 링크를 이용해 다음 리프 노드를 찾아가 스캔합니다.\n\n실제 데이터를 가져오는 경우도 데이터 정렬 순이 아닌 인덱스 구성 칼럼 순으로 레코드를 가져옵니다.\n이 말은 레코드 한건 한건마다 랜덤 I/O가 일어나는 것을 의미하며 인덱스를 통해 읽는 작업이 비용이 많이 드는 이유가 됩니다.\n\n인덱스 레인지 스캔은 다음 단계를 거칩니다.\n1. 인덱스에서 조건을 만족하는 값이 저장된 위치를 찾습니다. 이 과정을 인덱스 탐색이라고 합니다.\n2. 1번에서 탐색한 위치부터 필요한 만큼 인덱스를 차례대로 쭉 읽습니다. 이 과정을 인덱스 스캔이라고 합니다.\n3. 2번에서 읽어 들인 인덱스 키와 레코드 주소를 이용해 레코드가 저장된 페이지를 가져오고, 최종 레코드를 읽어옵니다.\n\n쿼리가 필요로 하는 데이터에 따라 3번은 필요하지 않을 수 있는데, 이를 커버링 인덱스라고 합니다.\n이 쿼리는 디스크 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 줄어들어 성능이 빨라집니다.\n\n### 인덱스 풀 스캔\n인덱스를 사용하지만 인덱스의 처음부터 끝까지 모두 읽는 방식으로 조건절에 사용된 칼럼이 인덱스의 첫번째 칼럼이 아닌 경우 사용됩니다.\n일반적으로 인덱스의 크기는 테이블 크기보다 작으므로 테이블을 처음부터 끝까지 읽는 것보다 인덱스만 읽는 것이 효율적입니다.\n이 방식은 인덱스에 포함된 칼럼으로만으로 처리할 수 있는 경우 효율적이지만, 일반적으로 비효율적이며 인덱스를 생성하는 목적과 다릅니다.\n\n### 루스 인덱스 스캔\n앞선 두 인덱스 스캔은 타이트 인덱스 스캔이라고 할 수 있으며 루스 인덱스 스캔은 느슨하게 인덱스를 읽습니다.\n인덱스 레인지 스캔과 비슷하지만 중간에 필요하지 않은 인덱스 키 값은 스킵하고 넘어가는 형태입니다.\n\n### 인덱스 스킵 스캔\n인덱스의 핵심은 값이 정렬되어 있는 것이며 인덱스를 구성하는 칼럼의 순서가 매우 중요합니다.\n```MySQL\nALTER TABLE employess\n    AND INDEX ix_gender_birthdate (gender, birth_date);\n```\n이 인덱스를 사용하려면 WHERE 조건 절에 gender 칼럼에 대한 비교 조건이 필수입니다.\n\n```mysql\nSELECT * FROM employees WHERE birth_Date >= '1965-02-01'; \n```\n\n다읔 뭐리에서는 gender 칼럼에 대한 비교가 없어 위에서 생성한 인덱스를 사용할 수 없었습니다.\nMySQL 8.0부터는 인덱스 칼럼을 건너 뛰어 사용 가능하게 해주는 인덱스 스킴 스캔이 도입되었습니다.\n인덱스 스킵 스캔을 사용하지 않으면 위의 쿼리는 인덱스 풀 스캔을 진행하고 사용하면 레인지 스캔을 사용합니다.\n\n새로 도입된 기능이라 아직 선행 칼럼의 유니크 값 개수가 적어야 하고 쿼리가 인덱스에 존재하는 칼럼으로만 처리가 되야합니다.\n유니크 값 개수가 많다면 인덱스 스캔을 시작할 지점을 검색하는 작업이 많이 필요해져 느려질 수 있습니다.\n\n### 다중 칼럼 인덱스\n2개 이상의 칼럼이 연결된 인덱스로 레코드의 건수가 적은 경우 브랜치 노드는 없을 수 있습니다.\n중요한 점은 칼럼 구성에 따라 정렬되어 있어 첫 번째 컬럼 기준으로 정렬되고 그 다음 컬럼 기준으로 정렬됩니다.\n따라서 칼럼 순서가 상당히 중요합니다.\n\n### B-Tree 인덱스의 정렬 및 스캔 방향\n인덱스의 정렬 순서는 오름차순, 내림차순으로 정렬되는데 어디부터 읽을지는 옵티마이저가 실실간으로 만들어냅니다.\n\n### 내림차순 인덱스\n다중 칼럼 인덱스 시 칼럼마다 오름차순과 내림차순을 따로 구성할 수 있습니다.\n이 때 인덱스를 구성하는 방식에 따라 성능의 차이가 있을 수 있습니다.\n- 오름차순 인덱스: 작은 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬\n- 내림차순 인덱스: 큰 값의 인덱스 키가 B-Tree의 왼쪽으로 정렬\n- 인덱스 정순 스캔: 인덱스 키의 크고 작음과 관계 없이 인덱스 리프 노드 왼쪽부터 오른쪽까지 스캔\n- 인덱스 역순 스캔: 인덱스 키의 크고 작음과 관계 없이 인덱스 리프 노드 오른쪽부터 왼쪽까지 스캔\n\n역순 정렬 쿼리가 정순 정렬 쿼리보다 대략 30% 정도 시간이 더 걸립니다.\n- 페이지 잠금이 인덱스 정순 스캔에 적합한 구조\n- 페이지 내에서 인덱스 레코드가 단방향으로만 연결된 구조\n\n정렬 순서 반대로 읽을 수 있다고 해도 인덱스 정렬 순서와 반대로 읽었을 시 성능이 떨어집니다.\n따라서 데이터 조회 쿼리에서 많이 사용하는 정렬 순서대로 인덱스를 생성하는 것이 효율적입니다.\n\n### B-비교 조건의 종류와 효율성\n```mysql\nSELECT * FROM dept_emp\nWHERE dept_no='d002' AND emp_no >= 10014;\n```\n- 케이스 A: INDEX(dept_no, emp_no)\n- 케이스 B: INDEX(emp_no, dept_no)\n\n케이스 A의 경우 dept_no=d002 와 emp_no>=10014 를 만족하는 인덱스를 찾고 emp_no 가 d002가 아닐때까지 읽으면 됩니다.\n조건 만족 기준부터 조건을 만족하지 않을 때까지 탐색과 정확히 일치합니다.\n하지만 B의 경우 emp_no>=10014 인 경우 중에서 dept_no=d002 인지 비교하는 과정이 필요합니다.\n\n### 인덱스의 가용성\nB-Tree 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있습니다.\n이는 한 칼럼 내에서 뿐만 아니라 다중 칼럼에서도 적용됩니다.\nLIKE를 이용해 뒷부분만 비교하는 경우도 왼쪽이 정해지지 않아 인덱스를 사용할 수 없습니다.\n\n### B-Tree 인덱스 사용 불가능\n- NOT-EQUAL\n- LIKE '%??'\n- 스토어드 함수, 다른 연산자로 인덱스 칼럼 변경 후 비교\n- NOT-DETERMINISTIC 속성\n- 데이터 타입이 서로 다른 비교\n- 문자열 데이터 타입의 콜레이션이 다른 경우\n\n## 전문 검색 인덱스\n전문 검색은 문서 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색합니다.\n\n### 어근 분석 알고리즘\n- 불용어 처리\n- 어근 분석\n\n불용어 처리에서 불필요한 단어들을 필터링하고 어근 분석으로 단어의 뿌리를 찾습니다.\n한글이나 일본어는 단어의 변형이 거의 없어 어근 분석보다 형태소 분석이 더 중요한 편입니다.\n대표적으로 Mecab 알고리즘이 있습니다.\n\n### n-gram 알고리즘\nMecab은 많은 시간과 노력을 필요로 하는데 단순히 키워드 검색에는 n-gram으로 키워드를 검색해냅니다.\nn-gram은 몇 글자씩 글자를 잘라서 사용하는 방법입니다.\n\n### 가상 칼럼 인덱스\n두 칼럼을 합쳐서 검색해야 하는 경우 실제 칼럼 대신 가상 칼럼을 추가해 인덱스를 생성할 수 있습니다.\n함수를 통해 나온 결과 값을 기준으로 인덱스를 만드는 방법도 있습니다.\n\n### 멀티 밸류 인덱스\n기본적으로 인덱스는 레코드 1건이 1개의 인덱스를 가집니다.\nJSON 포맷의 경우 전체 JSON 보다 필드 원소에 대한 인덱스가 필요합니다.\n```mysql \nMEMBER OF()\nJSON_CONTAINS()\nJSON_OVERLAPS()\n```\n다음 명령어들로 멀티 밸류 인덱스를 지원합니다.\n\n## 클러스터링 인덱스\n클러스터링은 여러 개를 하나로 묶는데 MySQL 서버에서는 레코드를 프라이머리 키를 기준으로 묶어서 저장하는 것을 의미합니다.\n주로 비슷한 값들은 동시에 조회하는 경우가 많다는 점에 착안합니다.\n따라서 프라이머리 키 값에 의해 레코드의 저장 위치가 결정되며 프라이머리 키 값이 변경되면 위치도 변경되는 걸 의미합니다.\n프라이머리 키 기반의 검색은 빠르지만 레코드 저장이나 변경은 상대적으로 느려집니다.\n\n1. 프라이머리 키가 있으면 프라이머리를 클러스터링 키로 선택\n2. NOT NULL 옵션의 유니크 인덱스 중 첫 번째를 클러스터링 키로 선택\n3. 자동으로 유니크한 값을 가지도록 증가되는 칼럼을 내부적으로 추가후, 클러스터링 키로 선택\n\n클러스터링 인덱스는 테이블당 단 하나이므로 가능한 프라이머리 키를 명시적으로 생성하는 것이 좋습니다.\n\n### 세컨더리 인덱스에 미치는 영향\nMyISAM이나 MEMORY 테이블처럼 클러스터링 되지 않은 테이블은 처음 젖아된 공간에서 이동하지 않습니다.\n프라이머리 키나 세컨드 인덱스는 내부적인 레코드 아이디를 이용하며 둘의 차이점은 없습니다.\nInnoDB에서도 실제 레코드 주소를 가진다면 클러스터링 키 값이 변경될 때마다 모든 인덱스 주솟값을 변경해야합니다.\n이런 오버헤드 제거를 위해 세컨더리 인덱스는 해당 레코드 주소가 아닌 프라이머리 키 값을 저장합니다.\n\n## 클러스터링 인덱스의 장단점\n장점은 프라이머리 키로 검색할 때 빠르고, 세컨더리 인덱스가 프라이머리 키를 가져 인덱스만으로 처리되는 경우가 많습니다.\n단점은 세컨더리 인덱스가 클러스터링 키 값을 가져 그만큼 인덱스의 크기가 커지고 세컨더리 인덱스로 검색시 프라이머리 키를 거쳐야합니다.\nINSERT할 때도 프라이머리 키에 의해 레코드 저장 위치가 결정되어 느리고 키를 변경할 때 DELETE와 INSERT 작업이 필요합니다.\n\n### 주의사항\n- 프라이머리 키는 AUTO-INCREMENT보다 업무적인 칼럼으로 생성\n- AUTO-INCREMENT를 사용하더라도 프라이머리 키는 반드시 생성\n\n## 유니크 인덱스\n인덱스보다는 제약조건에 가까우며 테이블에 같은 값이 2개 이상 저장될 수 없습니다.\n\n### 유니크 인덱스와 일반 세컨더리 인덱스 비교\n\n**인덱스 읽기**\n\n유니크 인덱스는 1건만 읽으면 되고 세컨더리는 1건 더 읽어 유니크 인덱스가 더 빠르다고 생각할 수 있습니다.\n하지만 한 번 더 하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼 값 비교하는 작업이라 성능상 영향이 거의 없습니다.\n즉 유니크하지 않은 세컨더리 인덱스는 중복된 값이 허용되어 읽어야 할 레코드가 많아 느린 것이지 인덱스 자체 특성 때문이 아닙니다.\n\n**인덱스 쓰기**\n\n새로운 값이 INSERT되거나 변경될 때 유니크 인덱스의 경우 중복된 값이 있는지 체크하는 과정이 필요해 세컨더리보다 느립니다.\n\n## 외래키\n외래키는 InnoDB 에서만 생성할 수 있으면 외래키 제약이 설정되면 자동으로 연관되는 테이블 칼럼에 인덱스까지 생성됩니다.\n외래키가 제거되지 않은 상태에서는 자동으로 생성된 인덱스를 삭제할 수 없습니다.\n\n- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생합니다.\n- 외래 키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생시키지 않는다.\n\n\n\n\n\n"},{"metadata":{"title":"Real MySQL 8.0 (3)","date":"2022-03-05 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"Reay MySQL 03"},"content":"\n# 5. 트랜잭션과 잠금\n트랜잭션은 작업의 완전성을 보장해줍니다. 논리적이 작업 셋을 모두 완벽하게 처리하거나, 처리하지 못할 경우 복구합니다.\n잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 보장합니다.\n여러 커넥션에서 동시에 한 데이터를 수정하면 값은 예측할 수 없어집니다.\n잠금으로 한 시점에 한 커넥션만 변경할 수 있는 역할을 담당합니다.\n격리 수준은 트랜잭션 내에서 작업 내용 공유와 차단 수준을 결정합니다.\n\n## 트랜잭션\nMyISAM이나 MEMORY 엔진은 트랜잭션을 보장하지 않으며 InnoDB 엔진은 지원합니다.\n트랜잭션을 보장하지 않는 경우 정합성을 보장하기 힘든 예제입니다.\n```mysql\nCREATE TABLE tab_myisam (id INT NOT NULL, PRIMARY KEY (id)) ENGINE=MyISAM;\nINSERT INTO tab_myisam (id) VALUES(3);\n\nSET AUTOCOMMIT=ON;\nINSERT INTO tab_myisam (id) VALUES (1), (2), (3);\n```\nInnoDB 엔진이라면 다음 상황에서 테이블에 남는 값은 3이 됩니다.\n하지만 MyISAM의 경우 중간에 키 중복 오류로 쿼리가 실패해도 1, 2가 남아있어 1, 2, 3이 남아있습니다.\n이렇게 부분 업데이트가 발생하면 원치 않는 값들이 들어갈 수 있습니다.\n따라서 남은 쿼리를 삭제하는 재처리 작업이 필요할 수 있습니다.\nIF, ELSE로 로직을 분리할 수 있지만 마찬가지로 재처리 작업으로 지저분해집니다.\n\n## 주의사항\n트랜잭션은 DBMS 커넥션처럼 필요한 최소의 코드에만 적용해 범위를 최소화하는 것이 좋습니다.\n트랜잭션을 시작한 상태에서 미리 읽어올 수 있던 데이터를 읽어오거나, 메일을 발송하는 등 외부 처리는 피하는 것이 좋습니다.\n\n## MySQL 엔진의 잠금\nMySQL에서 사용되는 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나눌 수 있습니다.\nMySQL 엔진은 스토리지 엔진을 제외한 나머지 부분으로 모든 스토리지 엔진에 영향을 미칩니다.\nMySQL 엔진에서는 테이블 데이터 동기화를 위한 테이블 락, 메타데이터 락, 네임드 락을 제공합니다.\n\n### 글로벌 락\n글로벌 락은 `FLUSH TABLES WITH READ LOCK` 명령으로 획득할 수 있습니다.\nMySQL에서 제공하는 잠금 중 가장 범위가 크며 한 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외하면 대기 상태가 됩니다.\n글로벌 락이 미치는 영향은 MySQL 서버 전체로 작업 대상 테이블이나 데이터베이스가 다르더라도 동일한 영향을 미칩니다.\nMyISAM이나 MEMORY 테이블에 대해 mysqldump로 일관된 백업을 받아야 할 때 글로벌 락을 사용합니다.\n글로벌 락이 실행되기 전에 이전 모든 명령이 끝나야 실행되며, 락으로 다른 명령이 오랫동안 실행되지 못할 수 있습니다.\n따라서 웹 서비스용 서버에는 가급적 사용하지 않는 것이 좋습니다.\n\nInnoDB에서는 트랜잭션을 지원하기 때문에 일관된 데이터 상태를 위해 모든 데이터 변경 작업을 멈출 필요가 없습니다.\n그래서 좀 더 가벼운 글로벌 락을 사용할 수 있습니다.\n\n```mysql \nLOCK INSTANCE FOR BACKUP;\n\nUNLOCK INSTANCE;\n```\n\n특정 세션에서 백업 락을 획득하면 테이블 스키마나 사용자 인증 관련 정보만 변경할 수 없습니다.\n일반적인 테이블의 데이터 변경은 사용 가능합니다.\n백업은 주로 레플리카 서버에서 실행되는데 도중에 스키마 변경이 일어나면 백업이 실패해 백업 락은 이를 막습니다.\n\n### 테이블 락\n개별 테이블 단위로 설정되는 잠금으로 명시적, 묵시적으로 `LOCK TABLES table_name [READ | WRITE]`로 테이블 락을 획득할 수 있습니다.\n테이블 락은 MyISAM, InnoDB 모두 동일하게 설정할 수 있습니다. 잠금 해제는 UNLOCK TABLES` 명령으로 반납합니다.\n특별한 상황 외에는 온라인 작업에 상당한 영향을 끼쳐 사용하지 않습니다.\n\nInnoDB의 경우 데이터 변경 시에는 무시되고 스키마를 변경하는 경우에만 영향을 미칩니다.\n\n### 네임드 락\n`GET_LOCK()` 함수를 이용해 임의의 문자열에 대해 잠금을 설정하며 데이터베이스 객체가 대상이 아닙니다.\n네임드 락은 단순히 사용자가 지정한 문자열을 획득하고 반납하는 잠금입니다.\n여러 서버에서 DB에 어떤 정보를 동기화를 하는 경우 락을 통해 접근 가능한지 확인할 수 있습니다.\n\n```mysql\nSELECT GET_LOCK('mylock', 2);\n\nSELECT IS_FREE_LOCK('mylock');\n\nSELECT RELEASE_LOCK('mylock');\n\nSELECT RELEASE_ALL_LOCKS();\n```\n\n### 메타데이터 락\n메타데이터 락은 데이터베이스 객체의 이름이나 구조등을 변경하는 경우에 자동으로 획득하는 잠금입니다.\n`RENAME TABLE` 같은 명령을 사용하는 경우 원본 이름과 변경하는 이름 모두 잠금을 설정합니다.\n\n## InnoDB 스토리지 엔진 잠금\n레코드 기반의 잠금 방식으로 MyISAM 보다 동시성 처리에서 뛰어나지만 MySLQ 명령으로 잠금 정보를 얻기 까다롭습니다.\n기존에는 `lock_monitor`, `SHOW ENGINE INNODB STATUS`등으로 파악하는 명령이 전부였습니다.\n최근에는 잠금과 대기 중인 목록을 `INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS`를 조인해 조회할 수 있습니다.\n\n### InnoDB 스토리지 엔진의 잠금\n레코드 단위로 락이 걸리며 레코드와 레코드 사이 간격을 잠그는 갭락이 존재합니다.\n\n**레코드 락**\n\n레코드 자체만을 잠그며 InnoDB의 차이점은 레코드가 아닌 인덱스의 레코드를 잠급니다.\n인덱스가 하나도 없는 테이블이더라도 내부적으로 생성된 클러스터 인덱스를 이용해 잠금을 설정합니다.\n\n**갭 락**\n\n레코드와 인접한 레코드 사이의 간격만을 잠그며 그 사이의 간격에 새로운 레코드 생성을 제어합니다.\n\n**넥스트 키 락**\n\n레코드 락과 갭 락을 합쳐놓은 형태로 STATEMENT 포맷의 바이너리 로그에서는 REPEATABLE READ를 사용해야 합니다.\n갭 락과 넥스트 키 락의 주 목적은 레플리카 서버에서 소스 서버에 바이너리 로그 쿼리를 동일하게 만들어내도록 보장합니다.\n다만 이로 인해 데드락이나 다른 트랜잭션을 기다리게 만드는 일이 많으므로 되도록 로그를 ROW로 바꿔 락을 줄이는 것이 좋습니다.\n\n**자동 증가 락**\n\nAUTO_INCREMENT 칼럼 속성인 경우 동시에 여러 레코드가 INSERT되는 경우 중복되지 않고 순서대로 증가해야 합니다.\n이를 위해 내부적으로 자동증가락으로 테이블 수준의 잠금을 제공합니다.\n\n새로운 레코드 생성시에만 필요하므로 UPDATE, DELETE 등의 쿼리에는 걸리지 않습니다.\n트랜잭션과 상관없이 INSERT나 REPLACE 문장에서 AUTO_INCREMENT 값을 가져오는 순간만 락이 걸렸다가 해제됩니다.\n명시적으로 설정할 수 있는 방법은 없으며 시간이 아주 짧기 때문에 대부분 문제가 되지 않습니다.\n\n### 인덱스와 잠금\nInnoDB는 레코드가 아닌 인덱스를 잠그는 방식으로 변경 레코드를 찾기 위해 인덱스와 레코드 모두 락을 겁니다.\n인덱스에 해당하는 개수가 많다면 그만큼의 레코드가 모두 락이 걸립니다.\n인덱스가 없다면 풀 스캔으로 모든 테이블에 락을 걸게 되기 때문에 인덱스 설계가 중요합니다.\n\n## MySQL의 격리 수준\n트랜잭션의 격리 수준이란 여러 트랜잭션이 동시에 처리될 때 다른 트랜잭션에서 변경이나 조회를 허용할지 결정하는 것입니다.\n\"DIRTY READ\"라고 하는 READ UNCOMMITTED는 일반적인 데이터베이스에서 잘 사용하지 않습니다.\nSERIALIZABLE은 동시성이 중요한 데이터베이스에서 거의 사용되지 않습니다.\nInnoDB에서는 REPEATABLE READ에서도 PHANTOM READ가 발생하지 않습니다.\n\n### READ UNCOMMITTED\n트랜잭션의 변경 내용이 COMMIT이나 ROLLBACK 여부에 상관없이 다른 트랜잭션에서 보이는 경우입니다.\n더티 리드 현상은 데이터가 나타났다가 사라졌다가 하는 현상을 초래해 사용자들을 혼란스럽게 만듭니다.\n\n### READ COMMITTED\n오라클 DBMS 에서 기본으로 사용되는 격리수준으로 가장 많이 사용되는 격리 수준입니다.\n어떤 트랜잭션에서 데이터를 변경했더라도 COMMIT이 완료된 데이터만 조회할 수 있습니다.\n트랜잭션 내에서 테이블을 수정하는 중이더라도 다른 트랜잭션에서는 언두 로그에서 백업된 레코드를 가져옵니다.\n생길 수 있는 문제는 NON-REPEATABLE READ가 불가능하다는 점이 있습니다.\nNON-REPEATABLE READ는 한 트랜잭션 내에서 초반에는 결과가 없다가 다른 트랜잭션 커밋 결과로 후반에 생기는 경우입니다.\n이 경우 한 트랜잭션 내에서 같은 명령어가 같은 결과를 보장하지 않아 정합성이 깨집니다.\n일반적인 경우에는 문제가 없지만 금전적인 처리처럼 동일 데이터를 여러번 읽으면 문제가 생깁니다.\n\nSELECT 문도 트랜잭션 내에서 실행하면 트랜잭션 범위 내에서만 작동합니다.\nREPEATABLE READ 수준에선 다른 트랜잭션 밖에서 변경하고 COMMIT을 실행하더라도 항상 같은 값을 보게 됩니다.\n\n### REPEATABLE READ\nInnoDB에서 기본으로 사용되는 격리 수준으로 바이너리 로그를 가진 MySQL 서버에서는 최소 REPEATABLE READ를 사용해야 합니다.\n언두 로그에 기존 값을 백업해두고 동일한 트랜잭션 내에서는 동일한 결과를 보여줍니다.\nREAD COMMITTED와의 차이점은 언두 영역에 백업된 레코드의 여러 버전 가운데 몇번째 이전까지 찾아 들어가느냐 입니다.\nREPEATABLE READ의 처리는 자신의 트랜잭션에서 처리한 언두 영역을 확인하는 것입니다.\n한 트랜잭션에서 데이터를 확인하고 끝나지 않았을 때 다른 트랜잭션에서 데이터를 업데이트합니다.\n다른 트랜잭션이 끝나고 아직 끝나지 않은 트랜잭션에서 값을 확인하면 언두 로그를 통해 같은 값을 확인할 수 있습니다.\n\n모든 InnoDB 트랜잭션은 고유한 트랜잭션 번호를 가지며 언두 영역에 백업된 데이터는 불필요한 시점에 주기적으로 삭제됩니다.\nMVCC를 보장하기 위해서는 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 앞선 언두 영역은 삭제할 수 없습니다.\n\n물론 이렇게 작업을 하다보면 언두 영역의 백업 데이터가 매우 커질 수 있어 처리 성능이 떨어질 수 있습니다.\n그리고 생길 수 있는 부정합은 SELECT ... FOR UPDATE 쿼리 결과는 위에 상황일 때 서로 다르게 나옵니다.\nSELECT ... FOR UPDATE는 잠금을 걸게 되는데 언두 레코드는 잠금을 걸 수가 없습니다.\n따라서 언두 레코드가 아닌 현재 레코드의 값을 가져와 다르게 보이게 되는 PHANTOM READ가 발생합니다.\n\n### SERIALIZABLE\n가장 단순하면서 엄격한 격리 수준으로 동시 처리 성능은 떨어집니다.\nSERIALIZABLE은 읽기 작업도 공유 잠금이 되며 한 트랜잭션이 어떤 작업을 하든 다른 트랜잭션은 접근할 수 없습니다.\nInnoDB엔진은 REPEATABLE READ에서도 갭 락과 넥스트 키 락으로 PHANTOM READ를 막아 SERIALIZABLE의 필요성이 없습니다.\n"},{"metadata":{"title":"Real MySQL 8.0 (2)","date":"2022-03-05 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"Reay MySQL 02"},"content":"\n# 4. 아키텍처\nMySQL 서버는 머리 역할을 담당하는 MySQL 엔진과 손발 역할을 담당하는 스토리지 엔진으로 구분합니다.\n스토리지 엔진은 핸들러 API를 만족하면 구현해서 서버에 추가해서 사용할 수 있습니다.\n\n## MySQL 엔진 아키텍처\n![전체 구조](/assets/img/RealMySQL/4-1.png)\n\nMySQL 엔진은 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서, 전처리기, 옵티마이저로 구성됩니다.\n스토리지 엔진은 디스크 스토리지에 저장과 읽어오는 부분을 담당합니다.\nMySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 동시에 여러 개 사용할 수 있습니다.\n쿼리 실행기에서 데이터를 쓰거나 읽을 때 스토리지 엔진에 요청하는 것을 핸들러 요청이라고 합니다.\n이 때 사용되는 API를 핸들러 API 라고 합니다.\n\n### 스레드 \nMySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며 크게 포그라운드와 백그라운드로 구분합니다.\n실행중인 스레드의 정보는 performance_schema와 thread 테이블을 통해 확인할 수 있습니다.\n\n**포그라운드 스레드**\n\n프그라운드 스레드는 최소 MySQL 서버에 접속한 클라이언트의 수만큼 존재하며, 주로 사용자의 요청 쿼리 문장을 처리합니다.\n작업을 마치고 커넥션을 종료하면 스레드는 스레드 캐시로 되돌아갑니다.\n이미 스레드 캐시에 일정 개수 이상의 대기 스레드가 있다면 스레드를 종료시켜 일정 개수만 유지시킵니다.\n포그라운드 스레드는 데이터를 데이터 버퍼나 캐시로부터 가져오며 없는 경우 디스크에서 불러옵니다.\nInnoDB의 경우 버퍼나 캐시까지만 포그라운드에서 처리하고 나머지는 백그라운드에서 처리합니다.\n\n**백그라운드 스레드**\n\n- 인서트 버퍼를 병합\n- 로그를 디스크로 기록\n- InnoDB 버퍼 풀의 데이터를 디스크에 기록\n- 데이터를 버퍼로 읽기\n- 잠금이나 데드락을 모니터링\n\n이 중 가장 중요한 것은 로그 스레드와 쓰기 쓰레드 입니다.\n데이터를 읽는 작업은 클라이언트에서 주로 처리되지만 쓰기는 아주 많은 작업이 백그라운드에서 진행되어 2~4 정도로 설정해야 합니다.\n\n데이터의 쓰기 작업은 버퍼링 되어 처리될 수 있어서 일괄 처리 기능이 존재합니다.\n\n### 어댑티브 해시 인덱스\n일반적으로 인덱스라고 하면 테이블에 사용자가 생성해둔 B-Tree 인덱스를 의미합니다. \n어댑티브 해시 인덱스는 사용자가 수동으로 생성하는 인덱스가 아니라 InnoDB에서 사용자가 자주 요청하는 데이터에 대해 자동으로 생성합니다.\n사용자는 `innodb_adaptive_hash_index` 변수를 이용해 기능을 활성화시킬 수 있습니다.\n\nB-Tree 인덱스를 이용하면 빨라진다고 해도 이는 상대적이며 어떤 일을 하느냐에 따라 속도가 느려질 수 있습니다.\n어댑티브 해시 인덱스는 이런 검색 시간을 줄여주기 위해 자주 읽히는 데이터의 키 값을 해시 인덱스로 만들어줍니다.\n이렇게 되면 루트 노드부터 리프 노드까지 찾아가는 비용이 없어집니다.\n\n이런 어댑티브 해시 인덱스가 도움이 안될 때는 다음과 같습니다.\n- 디스크 읽기가 많은 경우\n- 특정 패턴의 쿼리가 많은 경우\n- 매우 큰 데이터를 가진 테이블의 레코드를 폭넓게 읽는 경우\n\n도움이 되는 경우는 다음과 같습니다.\n- 디스크의 데이터가 InnoDB 버퍼 풀 크기와 비슷한 경우\n- 동등 조건 검색(동등 비교, IN) 연산이 많은 경우\n- 쿼리가 데이터 중 일부 데이터에만 집중되는 경우\n\n또 다른 단점으로는 해시 인덱스도 당연히 메모리를 차지하고, 변경이나 삭제할 때 인덱스도 함께 삭제하는 작업이 필요합니다.\n이럴 때 도움이 되는지 불필요한지 판단할 수 있는 방법은 서버의 상태 값을 확인하는 것입니다.\n\n```mysql \nSHOW ENGINE INNODB STATUS\\G\n```\n\nhash-searches 와 non-hash searches 의 비율과 메모리 공간, CPU 사용량을 종합해 효율적인지 판단합니다.\n\n### 메모리 할당 및 사용 구조\n\n크게 글로벌 메모리 영역과 로컬 메모리 영역으로 나뉩니다.\n글로벌 메모리 영역은 운영체제가 할당해주며 하나의 메모리 공간에서 모든 스레드에 의해 공유됩니다.\n\n- 테이블 캐시\n- InnoDB 버퍼 풀\n- InnoDB 어댑티브 해시 인덱스\n- InnoDB 리두 로그 버퍼\n\n로컬 메모리 영역은 세션 메모리 영역이라고도 하며 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역입니다.\n대표적으로 커넥션 버퍼와 정렬 버퍼가 있습니다.\n로컬 메모리는 스레드별로 독립적으로 할당되며 공유되지 않습니다.\n\n### 플러그인 스토리지 엔진 모델\n\n플러그인으로 스토리지 엔진이나 검색어 파서, 인증등을 플러그인으로 구현되어 제공합니다.\n\n**컴포넌트**\n\nMySQL 8.0부터는 플러그인 아키텍처를 대체하기 위해 컴포넌트 아키텍처가 지원됩니다.\n플러그인 아키텍처는 다음 문제가 있었습니다.\n- 플러그인은 MySQL 서버와 인터페이스할 수 있고, 플러그인끼리는 통신이 불가능\n- 플러그인이 MySQL 서버의 변수나 함수를 직접 호출해 위험\n- 플러그인은 상호 의존 관계를 설정할 수 없어 초기화가 어려움\n\n**쿼리 실행 구조**\n\n쿼리 파서, 전처리기, 옵티마이저, 실행 엔진, 핸들러로 구성됩니다.\n쿼리 파서에서 문장을 최소 단위의 어휘로 분리하고 기본적인 문법 오류를 찾습니다.\n전처리기에서 쿼리 문장에 구조적인 문제(테이블, 칼럼, 함수 존재 여부)등을 찾습니다.\n옵티마이저에서 쿼리 문장을 최적화합니다.\n실행 엔진은 핸들러에게 요청하고 요청받은 결과로 출력을 만들어냅니다.\n\n### 스레드 풀\n커뮤니티 에디션에서는 제공되지 않으며 엔터프라이즈 에디션과 페르코나 에서 지원합니다.\n스레드 풀을 이용하면 요청을 처리하는 스레드의 개수를 줄여서 제한된 개수의 스레드 처리로 자원 소모를 줄입니다.\n당연히 스레드 개수가 너무 적다면 쿼리 처리가 더 느려질 수 있습니다.\n일반적인 방법은 스레드 개수와 CPU 코어의 개수를 맞추는 방법이 있습니다.\n\n모든 스레드가 일을 처리 중인데 다음 작업을 받을 때까지 걸리는 시간이 제한 시간보다 길다면 스레드를 추가합니다.\n\n## 4.2 InnoDB 스토리지 엔진 아키텍처\nMySQL에서 가장 많이 사용되는 스토리지 엔진으로 레코드 기반 잠금을 제공하고, 높은 동시성 처리가 가능합니다.\n\n### 프라이머리 키에 의한 클러스터링\n\n프라이머리 키값 순서대로 디스크에 저장되어 다른 인덱스들은 프라이머리의 키 값을 논리적 주소로 사용합니다.\n장점으로 프라이머리 키를 이용한 레인지 스캔의 속도가 올라갑니다.\nMyISAM 엔진에서는 프라이머리 키도 그저 인덱스처럼 레코드의 주소 값을 가집니다.\n\n### 외래 키 지원\n\nMyISAM이나 MEMORY 테이블에서는 외래 키를 지원하지 않습니다.\nInnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요합니다.\n그리고 변경 시에 부모 테이블과 자식 테이블에 데이터가 있는지 확인하기 때문에 잠금이 전파되고 데드락이 발생할 수 있습니다.\n\n또 수동으로 데이터를 적재하거나 스키마 변경등을 신경쓰지 않으면 실패할 수 있습니다.\n긴급 조치 때문에 외래키에 대한 체크를 잠시 멈출 수 있습니다.\n부가적인 체크가 없기 때문에 속도가 빨라지지만 테이블 간의 관계가 깨진 채로 유지해서는 안됩니다.\n외래키 체크가 비활성화 되면 `CASCADE` 옵션 처럼 외래키 관계 작업도 무시하게 됩니다. \n\n```mysql \nSET foreign_key_checks=OFF;\n```\n\n### MVCC\n\n레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능으로 잠금을 사용하지 않는 일관된 읽기를 제공합니다.\nInnoDB에서는 언두 로그를 이용해 이 기능을 구현합니다.\n\n### 잠금 없는 일관된 읽기\nMVCC 기술을 이용하면 잠금을 걸지 않고 읽기 작업을 수행할 수 있습니다.\n격리 수준이 SERIALIZABLE이 아닌 수준일 때 읽기 작업은 다른 트랜잭션과 관계 없이 바로 실행됩니다.\n\n### 자동 데드락 감지\n데드락 감지를 위해 잠금 대기 목록을 그래프 형태로 관리합니다.\n교착 상태에 빠진 경우 트랜잭션 중 하나를 강제 종료합니다.\n어떤 트랜잭션을 종료할지 기준은 언두 로그 양을 비교해 더 적은 쪽을 롤백시킵니다.\n\n데드락 감지는 동시 처리 스레드가 매우 많아지거나 잠금이 많아지면 느려지게 됩니다.\n이때 잠금 목록을 검사할 때 잠금 목록이 저장된 리스트를 잠금하고 찾는데 느려지면 진행중인 작업을 대기해야 합니다.\n이 때문에 데드락 감지를 멈추려면 `innodb_deadlock_detect`를 off로 설정하면 됩니다.\n이럴때 데드락이 걸리면 무한정 대기하게 되는데 timeout을 통해 일정시간이 지나면 자동으로 요청을 실패시킬 수 있습니다.\n`innodb_lock_wait_timeout` 변수로 데드락 감지를 끈 상태라면 기본값인 50초보다 훨씬 낮게 설정하고 써야 합니다.\n\n### InnoDB 버퍼 풀\nInnoDB 엔진에서 가장 핵심적인 부분으로 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간입니다.\n쓰기 작업을 지연시켜 일괄작업을 처리하는 버퍼 역할도 같이 합니다.\n데이터를 변경하는 쿼리는 데이터 파일의 이곳저곳에 위치한 레코드를 변경하므로 랜덤한 디스크 작업을 발생시킵니다.\n버퍼 풀로 모아서 처리하면 랜덤한 디스크 작업의 횟수를 줄일 수 있습니다.\n\n버퍼 풀은 페이지 크기의 조각으로 쪼개어 필요할 때 페이지를 읽어 각 조각에 저장합니다.\n페이지 크기 조각을 관리하기 위해 LRU 리스트, 플러시 리스트, 프리 리스트라는 3개의 자료구조를 관리합니다.\n프리 리스트는 InnoDB 버퍼 풀에서 실제 사용자 데이터로 채워지지 않은 비어 있는 페이지들의 목록입니다.\n사용자의 쿼리가 새롭게 디스크의 데이터 페이지를 읽어와야 하는 경우 사용됩니다.\n\nLRU 리스트는 디스크로부터 한 번 읽어온 페이지를 최대한 오랫동안 유지해서 디스크 읽기를 최소화하는 것이 목적입니다.\n1. 필요한 레코드가 저장된 데이터 페이지가 버퍼 풀에 있는지 검사\n2. 디스크에 필요한 데이터 페이지를 버퍼 풀에 적재하고, 적재된 페이지에 대한 포인터를 LRU 헤더 부분에 추가\n3. 버퍼 풀의 LRU 헤더 부분에 적재된 데이터 페이지가 실제로 읽히면 MRU 헤더 부분으로 이동\n4. 버퍼 풀에 상주하는 데이터 페이지는 사용자 쿼리가 얼마나 최근에 접근했는지에 따라 나이가 부여\n    오래된 페이지는 버퍼 풀에서 제거, 버퍼 풀의 데이터 페이지가 사용되면 나이가 초기화되고 MRU의 헤더 부분으로 이동\n5. 필요한 데이터가 자주 접근됐다면 해당 페이지의 인덱스 키를 어댑티브 해시 인덱스에 추가\n\n플러시 리스트는 디스크로 동기화되지 ㅇ낳은 데이터를 가진 데이터 페이지를 변경 시점 기준의 페이지 목록을 관리합니다.\n디스크에서 읽은 상태 그대로 변경이 없다면 관리되지 않지만 변경이 가해지면 플러시 리스트에 기록되고 디스크에 기록되야합니다.\n\n### 버퍼 풀과 리두 로그\n버퍼 풀은 서버의 메모리가 허용하는 만큼 크게 설정할수록 쿼리의 성능이 빨라집니다.\n버퍼 풀은 데이터 캐시와 쓰기 버퍼링의 용도가 있는데 버퍼 풀 메모리 공간이 늘어도 데이터 캐시 기능만 향상시킵니다.\n쓰기 버퍼링 기능을 향상시키려면 버퍼 풀과 리두 로그의 관계를 이해해야 합니다.\n\n버퍼 풀은 변경되지 않은 클린 페이지와 더티 페이지를 가집니다.\n더티 페이지는 디스크와 상태가 다르기 때문에 언젠가는 디스크로 기록해야 합니다.\n리두 로그는 고정 크기 파일을 연결해서 사용하는데 데이터 변경이 계속되면 새로운 로그 엔트리로 덮어 쓰입니다.\n따라서 재사용 가능한 공간과 재사용 불가능한 공간을 구분해서 관리합니다.\n재사용 불가능한 공간을 활성 리두 로그라고 합니다.\n\n이때 리두 로그 파일의 크기가 작다면 더티 페이지를 적게 보관할 수 밖에 없어 버퍼링 효과가 거의 없습니다.\n반대로 리두 로그 파일의 크기가 크다면 한번에 기록해야 하는 더티 페이지가 너무 커지게 됩니다.\n따라서 적정 수준으로 선택하는 것이 중요합니다.\n\n### 언두 로그\n트랜잭션과 격리 수준 보장을 위해 이전 버전의 데이터를 백업해놓는 것을 언두 로그라고 합니다.\n언두 로그는 커밋된 값들이 백업되어 있는 것으로 변경된 데이터를 롤백하면 이 값을 불러와 복구합니다.\n\nMySQL 5.5 이전 버전의 MySQL 서버에서는 한 번 증가한 언두 로그 공간은 다시 줄어들지 않았습니다.\n예시로 100GB 짜리 테이블의 데이터를 삭제하면 그 기록이 그대로 언두 로그에 쌓이게 됩니다.\n테이블에는 데이터가 전혀 없는 상태인데 말입니다.\n\n뿐만 아니라 트랜잭션이 오래 지속되는 경우 언두 로그를 계속해서 보관하게 됩니다.\n이렇게 늘어난 언두 로그 사용 공간을 서버를 새로 구축하지 않는 이상 줄일 수 없었는데 업그레이드 되면서 해결되었습니다.\n\n## 로그 파일 \n\n### 에러 로그 파일\n설정 파일에서 log_error 라는 이름의 파라미터로 정의된 경로에 생성됩니다.\n\n- 시작 과정, 관련 정보 에러 메시지\n- 마지막으로 종료할 때 비정상적으로 종료된 경우 트랜잭션 복구 메시지\n- 쿼리 처리 도중에 발생하는 문제 에러 메시지\n- 비정상적 종료 커넥션 메시지\n- 모니터링, 상태 조회 메시지\n- 종료 메시지\n\n### 슬로우 쿼리 로그\nlong_query_time 시스템 변수에 설정한 시간 이상의 시간이 소요된 쿼리가 모두 기록됩니다.\nlog_output 옵션을 이용해 슬로우 쿼리 로그를 파일로 기록할지 테이블로 기록할지 선택할 수 있습니다.\n테이블로 선택한 경우 slow_log에 저장합니다.\n\n\n"},{"metadata":{"title":"Real MySQL 8.0 (1)","date":"2022-03-05 00:01:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"Reay MySQL 01"},"content":"\n## 1. MySQL 소개\nDBMS를 선택하는 기준 중 첫 번째는 \"자기가 가장 잘 활용할 수 있는 DBMS\"입니다.\n그 다음으로는 안정성, 성능, 인지도가 있습니다.\n\n## 2. 설치와 설정\n비밀번호가 없는 관리자 계정 유저 생성하기\n\n```shell\nmysqld --defaults-file=/etc/my.cnf --initialize-insecure\n```\n\n시작과 종료\n```shell\n## 서버 시작\nsystemctl start mysqld\n\n## 서버 상태 확인\nsystemctl status mysqld\nps -ef | grep mysqld\n\n## 서버 종료\nsystemctl stop mysqld\n\n## 원격 종료\nmysql> SHUTDOWN;\n```\n\n클라이언트 없이 서버 연결 테스트\n```shell \ntelnet 23.3.3.2 3306\n\n## Netcat 으로 확인\nnc 23.3.3.2 3306\n```\n\n### 서버 설정\n1. /etc/my.cnf\n2. /etc/mysql/my.cnf\n3. /usr/etc/my.cnf\n4. ~/my.cnf\n\n다음 순서로 설정 파일을 찾으며 설정 파일이 다 있는 경우 어느 설정 파일을 참조했는지 찾을 수 있습니다.\n```shell\nmysqld --verbose --help\n\nmysql --help \n```\n\n### 시스템 변수 확인\n```mysql \nSHOW GLOBAL VARIABLES;\n```\n\n### 글로벌 변수 & 세션 변수\n글로벌 변수는 서버 인스턴스에서 전체적으로 영향을 미칩니다.\n세션 변수는 각 클라이언트별로 유지되며 접속하면 기본값, 변경하면 세션별로 유지됩니다.\n즉 커넥션 단위로 다른 값으로 변경이 가능한 값입니다.\n예를 들면 `autocommit` 변수가 세션 변수입니다.\n\n### 정적 변수 & 동적 변수\n서버가 기동 중인 상태에서 변경 가능하냐에 따라 동적과 정적으로 구분됩니다.\n변수는 설정 파일에서 기본적으로 불러오는데 기동 중에는 재시작 전에 변수가 변경되지 않습니다. \n변수를 확인할 수 있는 방법은 명령어로 가능합니다.\n\n```mysql\nSHOW GLOBAL VARIABLES LIKE '$max_connections$';\n\nSET GLOBAL max_connections=500;\n```\n\nGLOBAL 변수의 경우 GLOBAL을 붙이면 되고 아닌 경우 자동으로 세션 변수입니다.\n\n### SET PERSIST\nSET을 통해 GLOBAL 변수를 교체하더라도 서버를 재시작하면 변경되지 않습니다.\n그 이유는 설정 파일에는 변경사항이 적용되지 않기 때문입니다.\n적용하려면 PERSIST 명령어가 필요합니다.\n반대로 삭제하려는 경우 RESET 명령어로 가능합니다.\n\n```mysql \nSET PERSIST max_connections=5000;\n\nRESET PERSIST max_connections;\n```\n\n## 3. 사용자 및 권한\nMySQL에서는 사용자와 호스트명도 함께 계정의 일부가 됩니다.\n사용자와 호스트명은 따옴표로 감싸서 표현합니다.\n호스트의 경우 %를 통해 모든 IP나 모든 호스트명을 표현 가능합니다.\n```\n`svc_id`@`127.0.0.1` \n\n`svc_id`@`%`\n```\n\n### CREATE USER\n사용자를 생성할 때 `CREATE USER`로 가능하며 여러 옵션이 있습니다. \n\n**IDENTIFIED WITH**\n\n비밀번호 인증 방식을 사용하는 경우 `password`를 함께 명시해야 합니다.\n```mysql \nIDENTIFIED WITH `mysql_native_password` BY `password`\n```\n\nMYSQL 8.0 MySQL 8.0 버전부터 Caching SHA-2 Authentication이 기본 인증 방식입니다.  \n따라서 이 방식은 SSL 또는 RSA 키페어가 필요합니다. \nMYSQL 8.0 에서도 비밀번호를 기본 인증 방식으로 바꾸려면 설정 파일을 바꿔야 합니다.\n\n```mysql \nSET GLOBAL default_authentication_plugin=\"mysql_native_password\"\n```\n\n**REQUIRE**\n\nSSL/TLS 채널을 사용할지 여부를 결정하는 옵션입니다.\n\n### 이중 비밀번호\n응용 프로그램에서 데이터베이스 서버를 공용으로 사용하고 있는 경우가 많습니다.\n이런 특성 떄문에 데이터베이스 서버의 계정 정보는 쉽게 변경하기 어렵고 서비스가 실행중일 때는 불가능합니다.\n그래서 처음 설정한 비밀번호를 오래 사용하는 경우가 많습니다.\n보안을 위해서 주기적으로 바꿔주려면 서비스를 모두 멈추지 않고서는 불가능한 일이었습니다.\n이 같은 문제점을 해결하기 위해 8.0 버전 부터는 비림번호를 2개를 동시에 사용 가능합니다.\n\n```mysql\n-- // old_password로 비밀번호 설정\nALTER USER `root`@`localhost` IDENTIFIED BY 'old_password';\n\n-- // 비밀번호를 \"qwerty\"로 변경하면서 기존 비밀번호를 세컨더리로 변경\nALTER USER `root`@`localhost` IDENTIFIED BY `new_password` RETAIN CURRENT PASSWORD;\n```\n\n최근 설정된 비밀번호는 프라이머리로, 이전 비밀번호는 세컨더리 비밀번호가 됩니다.\n변경한 이후에 사용중이던 서비스들에서 재시작마다 `new_password`로 변경하면 됩니다.  \n모든 서비스가 변경되고 나면 세컨더리 비밀번호에서 `old_password`를 삭제하면 됩니다.\n\n```mysql \nALTER USER `root`@`localhost` DISCARD OLD_PASSWORD;\n```\n\n### 권한(Privilege)\nMySQL 8.0에서 권한은 글로벌, 객체, 동적 권한으로 구분됩니다.\n데이터베이스, 테이블 이외의 객체에 적용되는 권한은 `글로벌 권한`입니다.\n객체 권한은 데이터베이스와 테이블에 해당하며 권한을 부여할 객체를 반드시 명시해야 합니다.\nALL을 명시하는 경우 객체는 객체에 적용되는 모든 권한을, 글로벌은 글로벌 수준에서 모든 권한을 부여합니다.\n미리 소스코드에 명시되어 있는 권한들은 정적 권한이라고 하며, 플러그인이나 추가로 등록되는 권한은 동적 권한입니다.\n권하능ㄹ 부여할 때는 `GRANT` 명령어를 이용합니다.\n\n```mysql\nGRANT privilege_list ON db.table TO 'user'@'host';\n```\n\n글로벌 권한의 경우 특정 대상에 부여될 수 없기 때문에 on 절에 항상 `*.*`을 이용합니다.\n```mysql \nGRANT EVENT ON *.* TO 'user'@'localhost';\n```\n\n### 역할(ROLE)\nMySQL 8.0 부터는 권한들을 묶어서 역할로 사용할 수 있습니다.\n\n```mysql\nCREATE ROLE\n    role_emp_read,\n    role_emp_write;\n```\nrole_emp_read와 role_emp_write 역할을 생성했지만 아직 어떤 권한도 없는 껍데기입니다.\nGRANT 명ㄹ령을 통해 실질적인 권한을 부여할 수 있습니다.\n\n```mysql \nGRANT SELECT ON employess.* TO role_emp_read;\n```\n\n역할을 계정에 부여하는 방법은 GRANT 명령어로 가능합니다.\n```mysql \nGRANT role_emp_read TO reader@`127.0.0.1`;\n```\n\n역할에 부여되어 있는 권한은 `SHOW GRANTS`로 확인 가능합니다.\n현재 계정의 역할을 확인은 `SELECT current_role()`로 가능합니다.\n하지만 만든 상태에서 사용하려고하면 권한이 없다는 에러를 만나게 됩니다.\n역할을 사용하려면 `SET ROLE` 명령어로 역할을 활성화해야 합니다.\n로그아웃하고 다시 로그인하면 다시 활성화되지 않은 상태가 됩니다.\n만약 로그인마다 역할을 자동으로 활성화하려면 옵션을 활성화해야 합니다.\n\n```mysql \nSET activate_all_roles_on_login=ON;\n```\n\nmysql에서 user테이블을 살펴보면 역할과 사용자가 구분없이 저장되어 있습니다.\n다만 역할들은 account_locked 칼럼의 값이 Y으로 되어 있습니다.\n그리고 host는 %로 모든 호스트가 자동으로 추가됩니다.\n따라서 역할을 부여하면 다른 계정과 권한을 합치는 것으로 처리됩니다.\n\n\n"},{"metadata":{"layout":"post","title":"TIL 210305","date":"2022-03-05 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220305TIL"},"content":"\n## Reay MySQL 8.0\n16:00 ~ 17:25\n- 01 ~ 03\n\n"},{"metadata":{"layout":"post","title":"만들면서 배우는 클린 아키텍처 (10 ~ 11)","date":"2022-03-04 00:00:04 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"만들면서 배우는 클린 아키텍처(10~12)"},"content":"\n## 아키텍처 경계 강제하기\n\n### 경계와 의존성\n아키텍처에서 경계를 구분하려면 어떤 요소들이 경계에 있을지 구분해야 합니다.\n가장 안쪽에는 도메인 엔티티, 애플리케이션 계층 서비스 안에 유즈케이스가 위치합니다.\n어댑터는 인커밍 포트로 서비스에 접근하고, 서비스는 아웃고잉 포트로 어댑터에 접근합니다.\n\n### 접근 제한자\n경꼐를 강제하기 위한 가장 기본적인 도구는 접근 제한자입니다.\npackage-private 제한자를 이용하면 클래스들을 응집적인 모듈로 만들어줍니다.\n패키지 바깥에서는 접근할 수 없으므로 모듈의 진입점만 public으로 만들면 됩니다.\n\n### 컴파일 후 체크\n클래스에 public 제한자를 쓰면 의존성 방향이 잘못되어도 컴파일러는 허용합니다.\n적용할 수 있는 다른 방법은 컴파일 후 체크를 도입합니다.\n캄파일된 후에 런타임에 체크해서 자동화된 테스트 과정에서 가장 잘 동작합니다.\n이러한 체크를 도와주는 자바용 도구는 ArchUnit이 있습니다.\n단위 테스트 프레임워크에서 의존성 규칙을 위반하면 테스트를 실패시킵니다.\n\n## 의식적으로 지름길 사용하기\n\n### 깨끗한 상태로 시작할 책임\n한 번 지름길을 쓰기 시작하면 계속해서 사용하게 됩니다.\n\n### 유스케이스 간 모델 공유하기\n모델에서 특정 세부사항을 변경할 경우 두 유스케이스 모두에 영향이 갑니다.\n만약 두 유스케이스가 독립적으로 진화해야 한다면 분리해서 시작해야 합니다.\n\n### 도메인 엔티티를 입출력 모델로 사용하기\n엔티티에 존재하지 않는 정보를 유스케이스가 필요로 한다면 엔티티가 아닌 다른 곳에 저장되야 합니다.\n하지만 유스케이스 인터페이스에서 사용할 수 있어 엔티티에 필드를 추가하고 싶다고 생각이 듭니다.\n서비스가 커질수록 단순한 도메인에서 복잡한 입출력이 필요해지므로 변경이 필요합니다.\n\n### 인커밍 포트 건너뛰기\n인커밍 포트는 애플리케이션 중심에 접근하는 진입점입니다.\n바로 애플리케이션에 접근하면 어떤 서비스 메서드를 호출할지 내부를 파악해야 합니다.\n또 인커밍 포트가 있어야 아키텍처를 강제할 수 있습니다.\n\n### 애플리케이션 서비스 건너뛰기\n영속성 어댑터가 인커밍 포트를 대체하는 방법입니다.\n단순한 CRUD 유스케이스에서는 어댑터에 전달하고 받는게 전부이기 때문에 대신할 수 있습니다.\n하지만 이 방법은 인커밍과 아웃고잉 어댑터 사이에 모델을 공유해야 합니다.\n또 애플리케이션 코어에 유스케이스라고 할만한 게 없습니다.\n나중에 CRUD에서 복잡해지면 아웃잉 어댑터를 추가하고 싶어집니다.\n문제는 이렇게 되면 도메인 로직이 흩어져서 도메인 로직을 찾거나 유지보수하기 어렵습니다.\n\n지름길을 택하더라도 중요한 것은 왜 선택했는지 기록을 남겨야 합니다.\n기록을 남겨서 나중에 작업할 사람들이 이 결정에 대해 다시 평가할 수 있어야 합니다.\n"},{"metadata":{"layout":"post","title":"만들면서 배우는 클린 아키텍처 (7 ~ 9)","date":"2022-03-04 00:00:03 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"만들면서 배우는 클린 아키텍처(7~9)"},"content":"\n## 아키텍처 요소 테스트하기\n\n### 테스트 피라미드\n테스트의 기본 전제는 만드는 비용이 적고, 유지보수하기 쉽고, 빨리 실행되고 안정적이어야 합니다.\n단위와 단위를 넘는 테스트들은 만드는 비용이 비싸지고 설정에 따라 깨지기 쉬워집니다.\n테스트가 다른 클래스에 의존한다면 의존되는 클래스들은 mock으로 대체합니다.\n\n단위 테스트 다음은 통합 테스트로 인터페이스로 데이터를 보낸 뒤 제대로 동작하는지 확인합니다.\n이때 단위를 넘는 테스트의 경우 어떤 시점에는 mock으로 대체해야 합니다.\n\n### 단위 테스트로 도메인 엔티티 테스트하기 \n도메인 엔티티 테스트들은 대체로 다른 클래스에 의존하지 않기 때문에 단위 테스트로 충분합니다.\n\n### 단위 테스트로 유즈케이스 테스트하기\n유즈케이스도 단위 테스트를 하지만 모든 행동보다 특정 핵심만 집중해서 테스트하는 것이 좋습니다.\n모든 동작을 검증하려고 하면 클래스가 조금이라도 바뀔 때마다 테스트를 변경해야 합니다.\n\n### 통합 테스트로 웹 어댑터 테스트하기\n실제 http 프로토콜로 테스트하기 보다 mockMvc 객체를 이용해 모킹하는 경우가 많습니다.\n통합 테스트를 통해 유효한 입력에 따라 유즈 케이스의 호출과 응답을 제대로 하는지 확인할 수 있습니다.\n실제로 네트워크로 연결되었을 때 처리되는 JSON 매핑, 요청 경로, 입력 검증등을 통합으로 테스트할 수 있습니다.\n\n### 통합 테스트로 영속성 어댑터 테스트하기\n@DataJpaTest로 데이터베이스에 실제로 접근해 제대로 매핑되는지 확인합니다.\n인메모리 데이터베이스로 잘 돌아가더라도 실제 운영 데이터베이스와 다른 경우 에러가 발생하는 경우도 체크가 가능해집니다.\n\n### 시스템 테스트로 주요 경로 테스트하기\n@SpringBootTest로 실제로 네트워크를 띄워 HTTP 통신을 통해 API를 테스트합니다.\n이때 서드파티 시스템의 경우 사용하기 어려운 경우 모킹이 필요할 수 있씁니다.\n\n### 얼마만큼의 테스트가 충분할까?\n라인 커버리지가 80%가 넘더라도 버그가 없을지 확신할 수 없습니다.\n버그가 없는 걸 불가능하기 때문에 버그를 수정하고 이 과정에서 왜 생각하지 못했을지, 해결 방법을 생각해야 합니다.\n그리고 이런 버그를 잡을 수 있는 테스트를 추가하면 됩니다.\n\n## 경계 간 매핑하기\n\n### 매핑하지 않기 전략\n웹, 애플리케이션, 영속성 모두 같은 도메인 모델 클래스를 사용하는 경우입니다. \n단순한 CRUD 유스케이스라면 매핑하지 않는 것도 괜찮습니다. \n하지만 확장하게 된다면 웹, 어플리케이션, 영속성등 다양한 이유로 변경 이유가 생겨 단일 책임 원칙을 위반합니다.\n\n### 양방향 매핑 전략\n각 계층이 전용 모델을 갖고 있는 모델로 양방향 매핑 전략이라고 합니다.\n모든 계층에서 모두 양방향으로 매핑하기 때문에 양방향 매핑으로 불립니다.\n각 계층이 전용 모델을 갖고 있어 각 계층이 모델을 변경하더라도 다른 계층에는 영향이 없습니다.\n단일 책임 원칙을 만족하는 장점이 있지만 너무 많은 보일러플레이트 코드가 생깁니다.\n매핑 프레임워크를 쓰더라도 두 모델 간의 매핑을 구현하는데 시간이 들게 됩니다.\n또한 도메인 모델이 계층 경계를 넘어서 통신하는데 사용되는 구조입니다.\n도메인 객체를 입력 파라미터와 반환값으로 사용하고 있어 바깥쪽 계층 요구상항에 의해 변경될 위험이 있습니다.\n\n### 완전 매핑 전략\n각 연산마다 별도의 입출력 모델을 사용합니다.\n입력에는 Command 처럼 입력에 특화된 모델을 따로 사용하는 구조입니다.\n이런 매핑 전략은 여러 가지를 섞어쓸 수 있고 전역적으로 사용하지 않고 계층 사이에 명확한 구분할 때 좋습니다.\n애플리케이션 계층과 영속성 계층 사이에서는 매핑 오버헤드 때문에 단점이 더 큽니다.\n\n### 단방향 매핑 전략 \n각 계층의 모델들이 동일한 인터페이스를 구현합니다.\n도메인 모델 객체를 바깥 계층에 전달하고 싶으면 매핑 없이 전달이 가능합니다.\n인터페이스를 사용할지 전용 모델로 매핑할지를 바깥 계층에서 결정할 수 있습니다.\n하지만 매핑이 계층마다 넘나들며 퍼져있어 개념적으로 어렵습니다.\n이 전략은 계층 간의 모델이 비슷할 때 효과적입니다.\n\n## 애플리케이션 조립하기\n\n### 왜 조립까지 신경 써야 할까?\n유즈케이스와 어댑터가 필요할 때 그냥 인스턴스화 하지 않는 이유는 의존성이 올바른 방향을 가리키게 하기 위해서입니다.\n모든 의존성은 안쪽으로, 애플리케이션의 도메인 코드 방향으로 향해야 바깥 계층의 변경에서 안전합니다.\n유즈케이스가 영속성 어댑터를 호출해야하고 스스로 인스턴스화 한다면 의존성은 잘못된 방향이 됩니다.\n\n이렇게 객체 인스턴스를 생성할 책임은 모든 클래스에 대한 의존성을 가지는 설정 컴포넌트가 가져야 합니다.\n설정 컴포넌트는 다음과 같은 역할을 수행해야 합니다.\n- 웹 어댑터 인스턴스 생성\n- HTTP 요청이 실제로 웹 어댑터로 전달되도록 보장\n- 유즈케이스 인스턴스 생성\n- 웹 어댑터에 유즈케이스 인스턴스 제공\n- 영속성 어댑터 인스턴스 생성\n- 유즈케이스에 영속성 어댑터 인스턴스 제공\n- 영속성 어댑터가 실제로 데이터베이스에 접근할수 있도록 보장\n\n이렇게 많은 책임을 지고 있으면 단일 책임 원칙을 위반하는게 맞지만 나머지 부분들을 깔끔하게 만들어줍니다.\n\n### 스프링의 클래스패스 스캐닝으로 조립하기\n스프링에서 애플리케이션을 조립한 결과물을 `애플리케이션 컨텍스트` 라고 합니다.\n애플리케이션 컨텍스트를 구성하는 객체를 `빈`이라고 합니다.\n조립하는 방법에서 가장 인기있고 편리한 방법은 `클래스패스 스캐닝`입니다.\n@Component 애너테이션이 붙은 클래스를 찾아서 각 필드의 생성할 수 있는 객체를 생성합니다.\n\n단점은 클래스패스 스캐닝 방식을 사용한다면 애너테이션을 사용한다는 점에서 프레임워크에 의존적입니다.\n만약 라이브러리나 프레임워크를 만드는 입장에선 사용하지 말아야 할 방법입니다.\n\n다른 단점은 문제점이 생겼을 때 스프링 내부에서 원인을 찾아야하기 때문에 부수효과가 생길 수 있습니다.\n\n### 스프링 자바 컨피그로 조립하기\n자바 컨피그는 애플리케이션 컨텍스트에 추가할 빈을 생성하는 설정 클래스를 만듭니다.\n\n\n\n"},{"metadata":{"layout":"post","title":"만들면서 배우는 클린 아키텍처 (4 ~ 6)","date":"2022-03-04 00:00:02 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"만들면서 배우는 클린 아키텍처(4~6)"},"content":"\n## 유즈케이스 구현하기\n\n### 유즈케이스 둘러보기\n유즈케이스가 하는 역할은 다음 단계를 거칩니다.\n1. 입력을 받는다.\n2. 비즈니스 규칙을 검증한다.\n3. 모델 상태를 조사한다.\n4. 출력을 반환한다.\n\n여기서 입력 부분에서 입력 유효성 검증 과정은 거치지 않습니다.\n유즈케이스가 검증하는 부분은 비즈니스 규칙만 채임지며 입력 유효성은 다른 곳에서 책임을 집니다.\n\n### 입력 유효성 검증\n입력 유효성 검증을 어댑터에게 맡기게 되면 모든 어댑터가 검증했는지 확신할 수 없습니다.\n그렇다고 유즈케이스에서 하기엔 유즈케이스의 책임이 커지기 때문에 다른 방식이 필요합니다.\n바로 입력 모델 자체에서 검증을 수행합니다.\n즉 입력 모델 생성 시부터 유효성을 검증해 유효하지 않은 경우 객체 생성을 막습니다.\n입력 모델도 API의 일부이기 때문에 인커밍 포트에 포함하기는 하지만 유즈케이스와 구분됩니다.\n\n### 생성자의 힘\n입력 모델은 생성자에 많은 책임을 지게 되는데 불변 객체를 만들기 위해 각 인자는 속성 값으로 채워지게 됩니다.\n이 과정에서 유효하지 않은 상태의 객체는 만들 수 없게 됩니다.\n이렇게 파라미터가 많다보면 빌더 패턴을 사용해 객체를 만들 생각을 할 수 있습니다.\n빌더 패턴을 사용했을 때의 단점은 필드를 추가하거나 했을 때 유효하지 않은 상태의 객체를 만든다면 컴파일 에러가 나지 않습니다.\n긴 파라미터이더라도 생성자를 사용한다면 컴파일 에러를 쉽게 찾고 IDE의 도움으로 각 요소의 파라미터가 무엇인지 찾기 쉽습니다.\n\n### 유즈케이스마다 다른 입력 모델\n하나의 서비스가 아닌 여러 유즈케이스로 나누다보면 입력 모델이 비슷한 경우 같이 사용하고 싶을 때가 있습니다.\n하지만 보통 유즈케이스가 다른 경우 다른 부분이 하나 이상 있기 마련입니다.\n등록하는 부분과 업데이트하기의 경우 ID의 유무가 차이가 됩니다.\n\n이런 경우를 점점 허용할수록 불변 객체에 null 값을 허용한 상태가 됩니다.\n뿐만 아니라 입력 유효성 검증 때도 유즈케이스 별로 구분하는 로직이 따로 필요하게 됩니다.\n따라서 비슷해서 중복처럼 보이더라도 유즈케이스별로 구분해서 만드는 것이 미래의 유지보수에 도움이 됩니다.\n\n### 비즈니스 규칙 검증하기 \n비즈니스 규칙은 도메인 모델 현재 상태와 관련된 검증입니다.\n입력 유효성은 구문상의 유효성이라고 한다면 비즈니스 규칙은 의미적인 유효성 검증을 의미합니다.\n\n### 풍부한 도메인 모델 vs 빈약한 도메인 모델\n엔티티 내에서 많은 도메인 로직을 처리하는 경우 풍부한 도메인 모델이라고 합니다.\n반대로 엔티티는 상태만 표현하고 도메인 로직을 가지고 있지 않은 경우 빈약한 도메인 모델이라고 합니다.\n대신에 도메인 로직들은 유즈케이스 클래스에 구현되어 있는데 필요에 따라 구분해서 사용하면 됩니다.\n\n### 유스케이스마다 다른 출력 모델\n입력과 비슷하게 출력도 가능하면 각 유스케이스에 맞게 구체적일수록 좋습니다.\n출력은 꼭 필요한 데이터만 들고 있는 것이 좋습니다.\n물론 상황에 따라서 업데이트된 전체 데이터를 필요로 할지도 모르고 현재 결정되지 않았다면 가능한 적게 반환합니다.\n최대한 구체적으로 유지하는 것이 중요합니다.\n\n### 읽기 전용 유스케이스는 어떨까?\n읽기 전용 작업은 유스케이스라고 표현하기 애매합니다.\n도메인으로 처리하는 것이 아닌 코어 관점에서 보았을 때 단순한 데이터 쿼리라고 할 수 있습니다.\n이를 구현하는 방법 중 하나는 쿼리 서비스를 따로 구현하는 것입니다.\n쿼리 서비스로 명시적으로 분리하게 되면 CQRS 개념처럼 읽기와 쓰기를 분리하기 쉬워집니다.\n\n## 웹 어댑터 구현하기\n\n### 의존성 역전\n웹 계층의 제어 흐름은 웹에서 애플리케이션 계층으로 흐르며 포트가 필요없다고 느껴질 수 있습니다.\n그럼에도 추가하는 이유는 명세를 확실히 할 수 있고, 아웃고잉 포트가 필요한 경우 공유할 수 있습니다.\n웹소켓처럼 실시간으로 아웃고잉이 필요한 경우 인커밍은 기존의 포트를 사용하고 아웃고잉만 추가해 사용할 수 있게 됩니다.\n\n### 웹 어댑터의 책임\n1. HTTP 요청을 자바 객체로 매핑\n2. 권한 검사\n3. 입력 유효성 검증\n4. 입력을 유즈케이스의 입력 모델로 매핑\n5. 유즈케이스 호출\n6. 유즈케이스의 출력을 HTTP로 매핑\n7. HTTP 응답을 반환\n\n입력 모델에서 유효성 검증을 하지만 웹 계층에서도 유효성 검증은 필요합니다.\n웹에서 받은 입력 모델이 유스케이스 입력 모델로 변환할 수 있다는 것에 대한 검증이 필요한 것입니다.\n\n### 컨트롤러 나누기\n컨트롤러도 유즈케이스를 나눈 것처럼 특정 기능에 따라 나누는 것이 좋습니다.\n하나의 도메인에 관련된 입력을 하나의 컨트롤러에서 다 받게 되면 컨트롤러 클래스의 코드가 비대해질 수 밖에 없습니다.\n그리고 늘어난 코드만큼 코드를 파악하는데 난이도가 올라가게 됩니다.\n테스트 작성 시에도 한 컨트롤러에 대한 테스트 코드가 비대해지게 됩니다.\n따라서 별도의 패키지에 별도의 컨트롤러를 만들어서 작업하면 동시작업이 쉬워집니다.\n\n## 영속성 어댑터 구현하기\n\n### 의존성 역전\n영속성 어댑터는 아웃고잉 어댑터로 애플리케이션에 의해 호출되는 어댑터입니다.\n\n### 영속성 어댑터의 책임\n1. 입력을 받는다.\n2. 입력을 데이터베이스 포맷으로 매핑한다.\n3. 입력을 데이터베이스로 보낸다.\n4. 데이터베이스 출력을 애플리케이션 포맷으로 매핑한다.\n5. 출력을 반환한다.\n\n영속성 어댑터는 입력 모델을 데이터베이스와 통신하기 위한 포맷으로 매핑합니다.\n자바에선 JPA를 일반적으로 사용하기 때문에 JPA 엔티티 객체로 매핑하게 됩니다.\n핵심은 영속성 어댑터 내부를 변경하더라도 코어에는 영향이 가지 않는 점입니다.\n이후 데이터베이스 응답을 출력 모델로 변환하는데 출력 모델은 애플리케이션 코어에 위치합니다.\n\n### 포트 인터페이스 나누기\n포트로 하나의 리포지토리에서 관리하면 서비스와 마찬가지로 너무 많은 부분에서 의존하는 넓은 포트가 됩니다.\n따라서 인터페이스를 분리해 필요한 인터페이스별로 분리하는 것이 좋습니다.\n\n### 영속성 어댑터 나누기\n영속성 계층에서 필요에 따라 JPA 혹은 기본 SQL 어댑터를 사용하는 등 다양하게 구현해도 상관없습니다.\n중요한 것은 이렇게 분리된 구현체들을 접하는 바운디드 컨텍스트가 필요합니다.\n다른 바운디드에 있는 영속성 어댑터를 접근하려면 전용 인커밍 포트를 통해 접근해야 합니다.\n\n\n"},{"metadata":{"layout":"post","title":"만들면서 배우는 클린 아키텍처 (1 ~ 3)","date":"2022-03-04 00:00:01 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"만들면서 배우는 클린 아키텍처(1~3)"},"content":"\n## 학습 목표\n- 계층형 아키텍처의 잠재적인 단점 파악\n- 아키텍처 경계를 강제하는 방법들\n- 잠재적인 지름길들이 소프트웨어 아키텍처에 끼치는 영향\n- 언제 어떤 스타일의 아키텍처를 사용할지 결정\n- 아키텍처에 따른 코드 구성\n- 아키텍처의 각 요소를 포함하는 테스트 적용\n\n## 계층형 아키텍처의 문제는 무엇일까?\n![1.1](/assets/img/만들면서배우는클린아키텍처/1.1.png)\n\n일반적인 3계층 아키텍처는 웹 계층에서 요청을 받아 도메인 혹은 비즈니스 계층에 있는 서비스로 요청을 보냅니다.\n서비스에서는 비즈니스 로직을 수행하고, 도메인 엔티티의 상태 조회나 변경을 위해 영속성 계층의 컴포넌트를 호출합니다.\n\n이런 계층형 아키텍처의 문제점은 코드에 나쁜 습관이 스며들기 쉽고 시간이 지날수록 변경하기 어려워지는 허점이 있습니다.\n\n### 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.\n전통적인 계층형 아키텍처의 토대는 데이터베이스입니다.\n그림 1.1처럼 영속성 계층을 가장 기본으로 의존하기 떄문에 모든 것은 영속성 기준으로 만들어집니다.\n\n우리가 만드는 애플리케이션의 목적은 규칙이나 정책을 반영한 모델을 만들어 규칙과 정책을 편리하게 활용하게 만듭니다.\n이때 우리는 상태가 아니라 행동을 중심으로 모델링하게 됩니다. 행동을 통해 상태를 바꿔나갑니다.\n\n계층형 아키텍처로 구성할 때를 생각해보면 도메인 로직보다 데이터베이스 구조를 먼저 생각하게 됩니다.\n이는 합리적인 것이 의존성의 방향에 따라 자연스럽게 구현한 것이기 때문입니다.\n하지만 비즈니스적 관점에서는 다른 무엇보다도 도메인 로직을 먼저 만들어야 합니다.\n그래야 우리가 로직을 제대로 이해했는지 확인할 수 있고 그를 기반으로 영속성과 웹 계층을 만들어야 합니다.\n\n데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM 프레임워크를 사용하기 때문입니다.\nORM 프레임워크를 사용하면서 비즈니스 규칙과 영속성 관점을 섞고 싶은 유혹을 쉽게 받게 됩니다.\n이렇게 되면 서비스는 영속성 모델을 비즈니스 모델처럼 사요앟게 되고 도메인로직과 영속성 작업을 같이 하게 됩니다.\n\n### 지름길을 택하기 쉬워진다.\n전통적인 계층형 아키텍처에서의 전체적으로 적용되는 유일한 규칙은, 특정 계층은 같거나 아래 계층만 접근 가능합니다.\n상위 계층에 위치한 컴포넌트에 접근해야 한다면 컴포넌트를 아래 계층으로 내려야 합니다.\n하지만 이렇게 컴포넌트를 내리다보면 영속성 계층이 비대해지게 됩니다.\n기본적으로 리포지토리를 포함해 헬퍼, 유틸리티 클래스등이 포함되 점점 커지게 됩니다.\n이런 지름길을 멈추려면 추가적인 아키텍처 규칙을 강제로 만드는 것이 최선입니다.\n\n### 테스트하기 어려워진다.\n웹 계층에서 간단한 조작의 경우 영속성 계층에 바로 접근하다보면 처음엔 편하더라도 나중에 확장성이 떨어지게 됩니다.\n테스트를 할 때도 웹 계층인데도 영속성 계층도 함께 모킹이 필요하게 되어 단위 테스트의 복잡도가 올라갑니다.\n\n\n### 유즈케이스를 숨긴다.\n개발자들은 새로운 유즈케이스를 구현하는 새로운 코드를 짜는 것을 선호합니다.\n레거시 프로젝트를 리팩토링하거나 하는 일은 새로운 코드보다 더 오랜 시간이 걸립니다.\n이럴 때 계층형 아키텍처에서 한 서비스의 너비가 크게 확장된 서비스가 만들어지기도 합니다.\n이 경우 서비스는 영속성 계층에 많은 의존성을 갖고, 많은 웹 레이어가 이 서비스에 의존하게 됩니다.\n서비스를 테스트하기도 어려워지고 작업해야할 유즈케이스를 책임지는 서비스를 찾기도 어려워집니다.\n\n### 동시 작업이 어려워진다.\n계층형 구조에서 작업하는 사람이 늘어난다고 해서 효율이 극대화되지 않습니다.\n이유는 모든 것이 영속성 계층 위에 만들어지기 때문에 영속성 -> 도메인 -> 웹 순서로 만들게 됩니다.  \n개발자끼리 한 기능에 대해 역할을 분담하기 힘들어집니다.\n특히 한 서비스에서 서로 다른 기능을 만들 때도 같은 파일을 편집하고 있어 병합 충돌이 날 가능성이 높습니다.\n\n## 의존성 역전하기\n\n### 단일 책임 원칙\n\n> 하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.\n\n> 컴포넌트를 변경하는 이유는 오직 하나 뿐이어야 한다.\n\n단일 책임 원칙의 실제 정의는 후자에 가까우며 다른 이유로 바뀐다면 컴포넌트가 영향받지 않는 걸 의미합니다.\n\n### 의존성 역전 원칙\n계층형 아키텍처에서 계층 간 의존성은 항상 다음 아래 계층을 가리킵니다.\n따라서 영속성 계층을 변경하면 그 위의 계층인 도메인 계층도 변경하게 됩니다.\n도메인 계층을 영속성 계층의 변경에 영향을 안 받으려면 의존성 역전 원칙을 사용하면 됩니다.\n\n> 코드상의 어떤 의존성이든 그 방향을 바꿀 수 있다.\n\n먼저 엔티티를 도메인 계층으로 옮기고 리포지토리를 인터페이스로 만들어 도메인으로 옮깁니다.\n이전의 ORM 구현체는 영속성 계층에 두고 도메인의 인터페이스를 구현하게 만듭니다.\n\n### 클린 아키텍처\n엔티티를 중심으로 유즈 케이스가 위치하는 아키텍처입니다. \n유즈케이스는 서비스와 비슷하지만 단일 책임을 위해 세분화되어있다는 차이점이 있습니다.\n따라서 서비스가 넓어지는 문제를 피할 수 있습니다.\n\n### 육각형 아키텍처\n\n육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있습니다.\n육각형 바깥에는 애플리케이션과 상호 작용하는 웹, 데이터베이스 같은 어댑터들이 존재합니다.\n어댑터가 코어를 호출한다면 입력 포트로, 코어에서 호출된다면 출력 포트와 연결됩니다.\n\n### 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?\n\n가장 중요한 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 되어 코드를 변경할 이유의 수를 줄여줍니다.\n\n## 코드 구성하기\n\n어떤 아키텍처인지 파악하기 쉽게 구성하는 방법은 패키지 구조로 만들 수 있습니다.\n\n### 계층으로 구성하기\n\nweb, domain, persistence 상위 패키지 아래에 각 요소들을 구성하는 방식입니다.\n이런 구조의 문제점은 기능에 따라 구분하기 어렵습니다.\n하나의 기능을 추가하기 위해선 web, domain, persistence 모든 패키지에 각각 필요한 기능들을 추가해야 합니다.\n다음으로 어떤 유즈케이스를 제공하는지 알기 힘듭니다.\n특정 기능에 대한 구현을 어떤 도메인이 했겠지라고 추측하고 찾아봐야 합니다.\n\n### 기능으로 구성하기\n\n각 도메인 별로 구성하는 방법입니다.\naccount 도메인이라면 한 패키지 안에 acocunt, accountRepository등이 들어가게 됩니다.\n이렇게 구성하게 되면 접근 수준을 이용해 패키지 간의 경계를 강화할 수 있습니다.\n하지만 이러한 구성은 각 어댑터나 포트 같은 역할에 따른 구성을 파악하기 힘듭니다.\n\n## 아키텍처적으로 표현력 있는 패키지 구조\n\n각 도메인 밑에 adapter, domain, application 등 아키텍처의 요소들을 매핑시킵니다.\n경계선이 되는 도메인 밑에 필요한 요소들을 명시적으로 구분한 구조로 코드가 아키텍처를 그대로 반영하게 됩니다.\n"},{"metadata":{"layout":"post","title":"Logback Slack","date":"2022-03-04 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Logback slack"},"content":"\n## Spring logback Slack 메시지\n에러가 발생하거나 했을 때 가장 쉽게 받아볼 수 있는 방법 중 하나로 슬랙이 있습니다.\n로그 레벨에 따라서 슬랙으로 로그를 받아볼 수 있습니다.  \n\n\n## 설정 방법\n\n### incoming webhooks 설정하기\n\n슬랙 앱에 추가하고 나면 생성되는 webhook_uri 가 필요합니다.\n\n### Spring 설정하기\n\nlogback과 slack을 연결하기 위해서 필요한 dependency를 추가해줘야 합니다.\ngradle 기준으로는 다음 코드를 입력합니다.\n\n``` \nimplementation \"com.github.maricn:logback-slack-appender:1.4.0\"\n```\n\n### logback-spring.xml 에 추가하기\n\n```xml\n  <appender name=\"SLACK\" class=\"com.github.maricn.logback.SlackAppender\">\n    <!-- Slack API token -->\n<!--    <token>1111111111-1111111-11111111-111111111</token>-->\n    <!-- Slack incoming webhook uri. Uncomment the lines below to use incoming webhook uri instead of API token. -->\n    <webhookUri>${SLACK_WEBHOOK_URI}</webhookUri>\n    <!-- Channel that you want to post - default is #general -->\n    <channel>#noti</channel>\n    <!-- Formatting (you can use Slack formatting - URL links, code formatting, etc.) -->\n    <layout class=\"ch.qos.logback.classic.PatternLayout\">\n      <pattern>%-4relative [%thread] %-5level %class - %msg%n</pattern>\n    </layout>\n    <!-- Username of the messages sender -->\n    <username>${HOSTNAME}</username>\n    <!-- Emoji to be used for messages -->\n    <iconEmoji>:stuck_out_tongue_winking_eye:</iconEmoji>\n    <!-- If color coding of log levels should be used -->\n    <colorCoding>true</colorCoding>\n  </appender>\n  <!-- Currently recommended way of using Slack appender -->\n  <appender name=\"ASYNC_SLACK\" class=\"ch.qos.logback.classic.AsyncAppender\">\n    <appender-ref ref=\"SLACK\" />\n    <filter class=\"ch.qos.logback.classic.filter.ThresholdFilter\">\n      <level>WARN</level>\n    </filter>\n  </appender>\n```\n\n위의 코드는 대부분을 위에서 추가한 라이브러리에서 제공한 readme에서 가져왔습니다.\n변경한 부분은 token 대신 slack_webhook_uri 를 사용하는 점입니다.\n설명 그대로 noti를 보낼 채널을 설정하고 로그 레벨을 설정할 수 있습니다.\n\n### slack webhook uri 설정하기\n만약 위의 코드에서 SLACK_WEBHOOK_URI 주소를 그대로 넣게 되면 메일이 오게 됩니다.\nSlack 에서 webhook 주소를 직접 입력하면 위험하다고 Webhook 주소가 변경되었다는 메일입니다.  \n따라서 webhook 주소를 직접 이용하는 것은 가능하지도 않고 위험합니다.  \n\n따라서 환경 변수를 따로 지정해서 입력합니다.\napplication.yml 기준으로는 다음과 같이 가능합니다.\n\n```yaml \nlogging:\n  slack:\n    webhook-uri: ${SLACK_WEBHOOK_URI}\n  config: classpath:logback-spring.xml\n```\n\nyml 파일을 따로 로컬로 관리하거나 SLACK_WEBHOOK_URI 그대로 시스템 환경변수로 등록해 사용합니다.\n설정한 이후로 슬랙으로 로그가 오는걸 확인할 수 있습니다."},{"metadata":{"layout":"post","title":"TIL 210304","date":"2022-03-04 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220304TIL"},"content":"\n## 만들면서 배우는 클린 아키텍처\n14:53 ~ 16:00\n\n## 프론트 수정\n\n### 슬라이드바 색상 수정\n- 다른 브라우저 지원 필요\n\n## 로그 작업\n16:50 ~ 21:30\n- 로그 롤링 작업\n- 슬랙 로그 연동\n- 프로파일 분리\n\n"},{"metadata":{"layout":"post","title":"TIL 210303","date":"2022-03-03 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220303TIL"},"content":"\n## 프론트 수정\n- 재생중 리스트 수정\n\n### 홈화면 리스트 삭제 없애기\n- readonly로 playbar 구분\n\n### 유튜브 화면 최대 크기 조절\n- 극장모드 추가\n\n### 검색 페이지 추가\n- 검색 페이지만 미리 생성\n\n### 시작 버튼 기능 수정\n- 시작 버튼 시 새로 시작 말고 중단부분부터 시작"},{"metadata":{"layout":"post","title":"TIL 210302","date":"2022-03-02 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220302TIL"},"content":"\n## Scheduler\n- 랜덤 구성을 위해 Scheduler 추가\n\n## 적록색약\n- 그래프 문제"},{"metadata":{"layout":"post","title":"TIL 210301","date":"2022-03-01 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220301TIL"},"content":"\n## 프론트 플레이리스트 수정\n- 리스트 썸네일 불러오기\n- 리스트 깔끔하게 바꾸기\n- [ ] 길이 수정 필요\n\n### conditional onclick\n```\nonClick={canClick ? this.handler : undefined }\n```\n\n### youtube thumbnail url\nhttps://img.youtube.com/vi/[video-id]/[thumbnail-number].jpg\n\n## 랜덤 플레이리스트 구성\n- 데이터 추가\n- 랜덤 구성"},{"metadata":{"layout":"post","title":"TIL 210228","date":"2022-02-28 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220228TIL"},"content":"\n## 재생 목록에서 삭제 \n- 재생 목록에서 삭제시 유튜브 재생 목록에서 삭제\n\n## 알고리즘\n- 케빈 베이컨의 6단게 법칙\n\n## 배포 \n- vercel\n- binary error 시 package-lock.json 삭제\n\n"},{"metadata":{"layout":"post","title":"TIL 210227","date":"2022-02-27 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220227TIL"},"content":"\n## 플레이바 사운드 조절\n12:00 ~ 12:20  \n- input range 로 범위 조절 생성\n- onChange 시 점 이동 밖에 안되어서 onInput 으로 수정\n\n## 플레이바 컴포넌트 분리\n12:22 ~ 14:45\n- props state 변경 함수 전달\n\n## 마이 플레이리스트 내 플레이바\n플레이바 데이터 타입 수정\n\n"},{"metadata":{"layout":"post","title":"KCM Travel","date":"2022-02-26 00:01:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"KCM Travel"},"content":"\n```kotlin\npackage boj.graph\n\nimport java.util.*\n\n// [KCM Travel] https://www.acmicpc.net/problem/10217\nfun main() {\n    val sb = StringBuilder()\n    val t = readLine()!!.toInt()\n    repeat(t) {\n        val (n, m, k) = readLine()!!.split(\" \").map { it.toInt() }\n        val graph = Array(n + 1) { ArrayList<Ticket>() }\n        repeat(k) {\n            val (u, v, c, d) = readLine()!!.split(\" \").map { it.toInt() }\n            graph[u].add(Ticket(v, c, d))\n        }\n        val queue = PriorityQueue<Ticket>()\n        val dist = Array(n + 1) { Array(m + 1) { Int.MAX_VALUE } }\n        dist[1][0] = 0\n        queue.add(Ticket(1, 0, 0))\n        var answer = Int.MAX_VALUE\n\n        while (queue.isNotEmpty()) {\n            val cur = queue.poll()\n            if (cur.v == n) {\n                answer = cur.d\n                break\n            }\n            if (dist[cur.v][cur.c] < cur.d) continue\n            for (ticket in graph[cur.v]) {\n                val cost = cur.c + ticket.c\n                val time = cur.d + ticket.d\n\n                if (cost > m) continue\n                if(dist[ticket.v][cost] <= time) continue\n                dist[ticket.v][cost] = time\n                queue.add(Ticket(ticket.v, cost, time))\n            }\n        }\n        sb.append(if (answer == Int.MAX_VALUE) \"Poor KCM\" else answer).append(\"\\n\")\n    }\n    println(sb)\n}\n\nprivate class Ticket(val v: Int, val c: Int, val d: Int) : Comparable<Ticket> {\n    override fun compareTo(other: Ticket): Int = d.compareTo(other.d)\n}\n```\n\n## 실수했던 점\n시간초과가 계속 나와서 반복작업을 줄여봤지만 계속해서 시간이 초과됐습니다.\n결국 문제였던 부분은 다른 부분이 아니라 출력 때문이었습니다.\n처음에 반복마다 println() 으로 출력하는 식으로 해서 오래 걸렸습니다.\nstringbuilder로 모아서 출력했더니 통과할 수 있었습니다.\n만약 로직에서 맞는 것 같은데 시간초과가 나온다면 출력을 모아서 해보는걸 추천드립니다."},{"metadata":{"layout":"post","title":"TIL 210226","date":"2022-02-26 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220226TIL"},"content":"\n## react-youtube\nYoutube API를 내부적으로 이용하는 라이브러리\n- API를 이용해 추가적으로 Youtube 영상 재생을 관리하도록 개발\n\n## padding\npadding 0 으로 잡으면 빈 칸이 생긴다\n\n## 가로 가운데 정렬\ndisplay: flex\njustify-content: center\n\n## KCM Travel\n- 최단 경로 문제\n- 출력 신경 쓰기"},{"metadata":{"layout":"post","title":"TIL 210225","date":"2022-02-25 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220225TIL"},"content":"\n## Front\n- 높이가 길 때 height: 100%가 스크롤 전까지만 될 때 해결법\n  - min-height: 100% 사용하기"},{"metadata":{"title":"LIS","date":"2022-02-24 00:01:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"LIS"},"content":"\n## Longest Increasing Subsequence\n최장 증가 수열 문제로 어떤 수열에서 순서를 유지한 채 부분을 뽑아낼 때 만들 수 있는 가장 긴 수열을 찾습니다.\n처음에 헷갈렸던 부분은 증가의 의미가 \"~ 이상 ( >= )\" 이라고 생각했는데 순수하게 증가하는 \"초과\"의 의미를 갖습니다.\n`[1, 2, 3, 4]` 는 가능하지만 `[1, 2, 3, 3]` 은 증가 수열이 아닙니다.\n\n## 가장 간단한 방법\n문제를 해결하는 가장 간단한 방법은 모든 경우를 만드는 방법입니다.\n예제로 `[1, 3, 2, 4]`를 가정하겠습니다.\n현재까지 완성된 순열을 저장하는 리스트를 저장하는 이차원 리스트가 있다고 가정합니다.\n매 순서마다 각 인덱스에서 시작하는 리스트를 추가합니다.\n그리고 현재까지 생성된 리스트의 마지막보다 현재 인덱스가 크면 그 리스트에 현재 인덱스 값을 추가한 리스트를 추가합니다.\n\n```java\nList<List<Integer>> sequences;\n```\n\n첫 번째 인덱스에서 만들어지는 리스트는 첫 번째 원소를 포함합니다.\n추가되는 리스트는 `[1]`이 됩니다.\n\n그리고 두 번째 인덱스에서 시작하는 리스트를 추가합니다.\n두 번째 인덱스에서는 기존에 존재하는 리스트는 `[1]` 이었고 3이 더 크기 때문에 추가합니다.\n이렇게 추가된 리스트는 `[1], [3], [1, 3]`이 됩니다.\n\n세 번째 인덱스에서도 위의 방식을 반복합니다.  \n이렇게 추가된 리스트는 `[1], [2], [3], [1, 2], [1, 3]`이 됩니다.\n\n네 번째까지 반복하면 `[1], [2], [3], [4], [1, 4], [2, 4], [3, 4], [1, 3, 4], [1, 2, 4]`이 됩니다.\n\n이런 리스트가 만들어진다고 하면 LIS는 `[1, 3, 4], [1, 2, 4]` 중 하나가 되고 최장 길이는 3이 됩니다.\n\n위의 방식을 보면 최악의 경우 모든 인덱스에서 증가하는 경우 증가 수열의 개수가 늘어납니다.\n1, 3, 6, 10 ... 폭으로 증가하는 계차수열로 시간 복잡도는 O(n^3)이 됩니다.\n"},{"metadata":{"layout":"post","title":"TIL 210224","date":"2022-02-24 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220224TIL"},"content":"\n## NextJS build\nbuild 방법"},{"metadata":{"layout":"post","title":"Github Action Spring","date":"2022-02-23 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Github Action Spring"},"content":"\n## Java with Gradle\n\nCI를 위해서 Gradle을 이용해 Java를 빌드해야 했습니다.\n\n### Git에 안 올리는 변수 처리\n데이터베이스 비밀번호, API Secret Key, Token Secret등 Git에 포함하지 않는 변수들이 있습니다.\n이런 변수들을 사용하는데 포함하지 않은 경우 빌드에 실패하게 됩니다. 따라서 속성값을 따로\n저장하고 관리하는 방법이 필요합니다.\n\n일단 가장 접근하기 쉬운 방법은 Github Secrets을 이용하는 방법이었습니다.\nGithub Secrets 에 변수들을 저장하고 Github actions에서 저장한 비밀 변수들을 불러옵니다.\n\n비밀 변수들은 `{{ secrets.secret-key}}` 로 불러올 수 있습니다.\n그리고 application.properties나 application.yml처럼 속성등을 명시하는 곳의 변수를 바꿔줘야 합니다.\nSpring에서는 빌드하고 있는 환경에서 `${변수}`가 존재하면 환경 변수 값으로 교체됩니다.\n따라서 변수들을 위의 형식으로 교체하면 됩니다.\n\n## S3에 빌드 파일 올리기\nGithub Actions의 실행 명령으로 S3에 빌드 파일을 올릴 수 있습니다.\n\n## Code Deploy로 빌드 파일 서버에 옮기기\nS3에 올라간 이후로 Code Deploy 작업을 수행할 수 있습니다.\n\n### 서버 환경 변수\n서버에서 중요한 점은 빌드된 jar에 환경 변수들이 저장된 상태가 아니라는 점입니다.\n따라서 실제로 사용하는 서버에도 환경 변수로 똑같이 존재해야 합니다.\n\nSSH로 연결해서 하는 경우 주의할 점은 환경 변수를 설정하고 SSH 연결을 끊고 다시 접속해야 합니다.\n그렇지 않으면 환경 변수가 잘 나오는 것처럼 보여도 빌드를 할 때 안되는 경우가 보입니다.\n\n서버가 하나일 때는 상관없지만 서버가 여러 개인 경우 이렇게 관리하는 것은 번거로워집니다.\n따라서 `Spring Config Server`나 `Amazon Parameter Store`처럼 서버에서 환경 변수들을 관리합니다.\n\n\n\n\n\n"},{"metadata":{"layout":"post","title":"TIL 210223","date":"2022-02-23 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220223TIL"},"content":"\n## gh-pages netlify\n배포 방법"},{"metadata":{"layout":"post","title":"[백준] 리모컨","date":"2022-02-22 00:01:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"리모컨"},"content":"\n```kotlin\npackage boj.bruteforce\n\nimport kotlin.math.abs\n\n// [리모컨] https://www.acmicpc.net/problem/1107\nfun main() {\n    val n = readLine()!!.toInt()\n    val m = readLine()!!.toInt()\n    val broken = BooleanArray(10)\n    if (m != 0)\n        readLine()!!.split(\" \").forEach { broken[it.toInt()] = true }\n    val justMove = abs(100 - n)\n\n    var min = 987654321;\n    for (i in 0 until 1000000) {\n        val str = i.toString()\n        var movable = true\n        for (element in str) {\n            if (broken[element.digitToInt()]) {\n                movable = false\n                break\n            }\n        }\n        if (!movable) continue\n        min = min.coerceAtMost(str.length + abs(i - n))\n    }\n    println(justMove.coerceAtMost(min))\n}\n```\n\n## 실수했던 점\n한 번 숫자가 정해지고 나면 그 이후로는 더하거나 빼서 값을 구하는 문제였습니다.\n문제는 그 숫자가 정해지는 방법인데 최적의 방법이 있을 것이라 생각하고 구하려 했습니다.\n하지만 계속해서 예외 케이스가 나왔고 결국 완전 탐색으로 해결했습니다.\n다시 한 번 시간이 충분하다면 완전 탐색으로 푸는 걸 먼저 해보는게 더 빠른 방법이라 배웠습니다.\n"},{"metadata":{"layout":"post","title":"TIL 210222","date":"2022-02-22 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220222TIL"},"content":"\n## Code Deploy\nCode Deploy 사용법\n\n## Github Secret\nGithub Secret action에서 사용법\n"},{"metadata":{"layout":"post","title":"TIL 210221","date":"2022-02-21 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220221TIL"},"content":"\n## CI / CD\nCI / CD 적용 방법\n"},{"metadata":{"layout":"post","title":"TIL 210220","date":"2022-02-20 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220220TIL"},"content":"\n## stream reduce\nreduce 정리\n\n"},{"metadata":{"layout":"post","title":"TIL 210219","date":"2022-02-19 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220219TIL"},"content":"\n## 코딩 테스트\n\n"},{"metadata":{"layout":"post","title":"위상 정렬","date":"2022-02-18 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"위상정렬"},"content":"\n## 위상 정렬\n`위상 정렬(Topological sort)`은 정점들의 순서를 찾는 알고리즘입니다.\n순서가 존재한다는 것은 시작점이 존재한다는 것을 의미합니다.\n따라서 시작점이 존재하지 않고 반복되는 사이클의 경우 정렬할 수 없습니다.\n\n## 위상 정렬 특징\n사이클이 생기지 않을 때 그래프에서 시작점은 여러 곳이 될 수 있습니다.\n시작점과 연결 순서에 따라서 위상 정렬은 여러가지 순서가 나올 수 있습니다.\n\n## 위상 정렬 방법\n1. 진입 차수가 0인 정점들을 큐에 넣습니다.\n2. 선택된 정점들의 진입 차수를 감소시킵니다.\n3. 큐가 빌 때까지 1~2번을 반복합니다.\n\n"},{"metadata":{"layout":"post","title":"TIL 210218","date":"2022-02-18 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220218TIL"},"content":"\n## 개념 정리\n- Cascade\n- GeneratedValue\n\n"},{"metadata":{"layout":"post","title":"Generated Value","date":"2022-02-17 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Generated Value"},"content":"\n## JPA ID 생성 방식\n데이터베이스에서 기본키를 생성하는 방식은 크게 두 가지로 나뉩니다.\n- 자동으로 생성되는 키 방식\n- 데이터의 의미 있는 부분에서 키 생성 방식\n\n의미 있는 키 방식이면 데이터를 보고 구분하기 쉽고 ID에서 의미 있는 정보를 추출할 수도 있습니다.\n하지만 가장 큰 문제점이 있는데 데이터가 많아졌을 때도 키의 유일성을 보장할 수 있을지 모른다는 점입니다.\n유일성을 보장하는 개인 정보를 사용하는 방법도 상황에 따라 데이터베이스에서 사용하지 못할 수 있습니다.\n따라서 자주 사용하는 방식은 의미 없는 랜덤 키를 데이터베이스에서 생성받아 사용합니다.\n\n## 데이터베이스에 따라 다른 생성 방식\n\n### GenerationType.IDENTITY\nIDENTITY 방식은 auto increment 방식으로 생성합니다.\nMySQL, PostgreSQL 등에서 주로 사용하는 방식입니다.\n\n### GenerationType.SEQUENCE\n데이터베이스에서 유일한 값을 생성받아 만드는 방식입니다.\nOracle, H2 등에서 주로 사용하는 방식입니다.\n\n### GenerationType.TABLE\n데이터베이스에서 테이블에서 생성전략을 받아서 사용하는 방식입니다.\n\n### GenerationType.AUTO\n데이터베이스의 방언에 따라 생성 방식을 자동으로 지정합니다.\n\n## 선택 방법\n당연히 선택할 때 중요한 점은 사용할 DB와 어울리는 방법을 선택하는 것입니다.\n방식을 명시해도 결국에 모든 방식은 DB에서 생성되는 Key에 의존하게 됩니다.\n따라서 선택한 DB에서 쉽게 사용할 수 있는 지원 방식을 사용하는 것이 좋습니다.\n\n그렇다면 AUTO를 선택하면 가장 좋은 방식이라고 생각할 수 있습니다.\n하지만 버전에 따라, AUTO가 선택하는 방식은 달라질 수 있습니다.\n예를 들어 MySQL의 경우 Hibernate 1.5에서는 IDENTITY를 2.0에서는 TABLE 방식을 선택합니다.\ntable 방식을 사용하려면 테이블을 따로 만들어서 생성 전략 방식을 제공해야 합니다.\n간단하게 id를 증감시키는 auto increment에 비해 번거로울 수 있습니다.\n\n따라서 AUTO가 상황에 가장 맞는 방식을 제공한다는 보장이 없으므로 본인이 선택하는 것을 추천합니다."},{"metadata":{"layout":"post","title":"JPA Cascade","date":"2022-02-17 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Cascade"},"content":"\n## JPA Cascade\n한 영속성 객체에서 수행한 행동이 자식까지 전이 되는 것을 의미합니다.\n어떤 객체를 삭제했는데 연관된 객체가 모두 삭제되거나, 생성했을 때 모두 생성되는 등이 가능해집니다.\n\n## Cascade 종류\n- ALL\n- PERSIST\n- MERGE\n- REMOVE\n- REFRESH\n- DETACH\n\n### ALL\n모든 Cascade를 포함합니다.\n\n### PERSIST, MERGE, REMOVE, DETACH\n말 그대로 각 영속성 상태에 동작한 결과를 그대로 연관 객체도 같이 동작하게 됩니다.\n\n### REFRESH\n영속성을 flush한 상태처럼 캐시에 존재하지 않아 객체를 불러오는 경우 함께 새로 불러옵니다.\n연관 객체는 영속성 컨텍스트에 존재하더라도 새로 불러오게 됩니다."},{"metadata":{"layout":"post","title":"TIL 210217","date":"2022-02-17 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220217TIL"},"content":"\n## 프론트 작업\n- 모달\n- Input 토글\n"},{"metadata":{"layout":"post","title":"TIL 210216","date":"2022-02-16 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220216TIL"},"content":"\n## N+1 문제 고민\n- N+1 문제를 해결하는 방법\n- 데이터를 받아왔을 때 어떻게 처리할지 고민\n\n"},{"metadata":{"title":"라이브러리 vs 프레임워크","date":"2022-02-15 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"라이브러리 vs 프레임워크"},"content":"\n프레임워크와 라이브러리의 차이점에 대해서 종종 물어보곤 합니다.\n그럴 때마다 개념적으로 어렴풋이는 알지만 정확한 대답을 하지 못했습니다.\n그러다 배워가면서 추가된 내용을 정리하려합니다.\n\n#### **프레임워크**\n\n처음 프레임워크를 들었을 때 배운 것은 \"틀\", \"뼈대\" 입니다.\n단어의 뜻만 알고 있어도 기반구조 같은 거구나 하고 인식할 수 있었습니다.\n소프트웨어의 정의로는 다음과 같습니다.\n\n> 소프트웨어의 특정 문제를 해결하기 위해서 상호 협력하는 클래스와 인터페이스의 집합\n\n이후에 프레임워크를 직접 써보고 배우게 된 것은 제어의 역전(Inversion of Control)입니다.\n일반적으로 코드를 작성하면 사람이 어떤 것을 먼저 호출하고 사용할지 결정합니다.\n하지만 프레임워크의 경우 프로그램의 흐름을 프레임워크가 결정합니다.\n프레임워크가 필요할 때 제 코드를 호출해 사용하는 방식입니다.\n프레임워크의 대표적인 예로는 Spring, Django 등이 있습니다.\n라이브러리는 \"도서관\" 이라는 뜻처럼 함수나 기능들을 모아놓은 것입니다.\n도서관에서 책을 빌려서 읽을 수는 있지만, 빌린 책으로 무언가를 만들 수는 없습니다.\n단순히 소비자로써 사용만 가능한 것을 라이브러리라고 합니다.\n소프트웨어적으로는 사용가능한 클래스들의 집합이 됩니다.\n라이브러리의 대표적인 예로는 JQuery가 있습니다.\n\n---\n\n여기까지는 다른 글들에서도 많이 봤을 것이라 생각됩니다.\n사실 위의 내용을 충분히 숙지했다면 문제가 될 것은 없습니다.\n문제는 저처럼 대충 알고 넘어갔을 때 혼동이 생기는 경우입니다.\n제가 혼동이 오기 시작했던 건 Java Collections 때문입니다.\nJava Collections는 프레임워크일까요, 아니면 라이브러리일까요?\n그리고 React는 프레임워크일까요, 아니면 라이브러리일까요?\n\n첫 번째 정답은 프레임워크입니다.\n\nJava Collections는 자주 사용하는 자료구조들에 대한 인터페이스와 구현체 클래스들을 갖고 있습니다.\n위의 프레임워크의 소프트웨어 설명에 따르면 맞는 말입니다.\n그럼에도 제게 낯설게 느껴졌던 것은 주 사용 목적 때문입니다.\n\n주로 Collections를 사용할 때 라이브러리처럼 ArrayList, HashMap 같은 자료구조를 그냥 가져다 씁니다.\n개인적으로 Collections의 자료 구조의 Interface를 구현해서 사용할 일은 없었습니다.\n물론 이런 특성 때문에 Java Collections는 라이브러리의 방식으로 동작하는 프레임워크라고 불립니다.\n따라서 무언가 틀 안에서 코드를 만들어야할 것 같은 프레임워크와 괴리감이 느껴졌습니다.\n\n두 번째 정답은 라이브러리입니다.\n\n이번에는 반대로 React로 UI 컴포넌트들을 만들어나간다는 느낌 때문에 프레임워크라고 생각했습니다.\n하지만 공식 홈페이지에서도 명시되어있듯이 React는 라이브러리입니다.\n단순히 프로그램을 만드는 틀이 프레임워크입니다, 흐름을 제어합니다로 구분할 수 있을까요?\nReact로 만들다 보면 React에 명시된 규칙대로 프로그램을 작성하게 됩니다.\n검색만 하면 사용하고 있는 것이 프레임워크인지 라이브러리인지는 구분할 수 있습니다.\n하지만 쉬운 개념인 것 같은데도 구분이 안되는 데는 부족한 개념이 있다고 생각되었습니다.\n헷갈리는 이유 중 하나에는 프레임워크는 라이브러리의 특성을 포함한다는 점입니다.\n즉 프레임워크 = 라이브러리 + ? 로 설명할 수 있습니다.\n그래서 프레임워크만 가지는 특성들을 찾아봤습니다.\n\n#### **확장성**\n\n프레임워크는 가지고 있는 기능을 확장 가능해야 합니다.\n중요한 것은 기존의 프레임워크 코드를 수정하지 않아야 한다는 점입니다.\n일반적으로 생각해볼 수 있는 방법은 세 가지가 있습니다.\n\n1\\. 일반 클래스를 상속 받는다.\n\n2\\. 인터페이스를 구현한다.\n\n3\\. 추상 클래스를 상속 받는다.\n\nJava Collections의 경우에는 1번과 2번이 가능했습니다.\nArrayList, HashMap 같은 클래스를 상속받을 수 있습니다.\n혹은 List, Map 같은 인터페이스를 직접 구현해서 사용할 수 있습니다.\n3번의 경우에는 Java Collections에서는 사용되지 않습니다.\nSpring의 DB 연결이나 Servlet 구조가 이 형태로 되어 있습니다.\n사용 방법은 디자인 패턴에 따라 달라지게 됩니다.\n3번의 경우는 대부분의 작업은 동일하지만 특정 기능이 다르게 만드려고 할 때 주로 사용합니다.\n디자인 패턴에서 템플릿 메서드 패턴를 떠올릴 수 있습니다."},{"metadata":{"title":"Spring 환경 변수","date":"2022-02-15 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring 환경 변수"},"content":"\n## Spring 환경별 환경 변수\n\n로컬환경, 테스트환경, 배포환경등 다양한 환경에 따라 변수값을 바꿔줘야할 때가 있습니다.\n\n가장 간단하게 적용해볼 수 있는 방법은 커맨드라인이나 환경변수 인자 값으로 넣어주고 실행하는 것입니다.\n\n하지만 이렇게 사용하는 경우 변수가 많아지면 복잡하고, 다른 사람과 공유하기 힘듭니다.\n\n이런 경우 설정파일에 값을 정리하고 프레임워크에서 불러오는 방법을 주로 사용합니다.\n\nSpring에서는 주로 .properties, .yml 파일 형식을 이용합니다.\n\n환경 변수로 사용할 수 있는 요소는 다양한데 값들이 겹치는 경우 우선순위에 따라 적용됩니다.\n\n예를 들어 `.properties`와 `.yml`에서 값이 겹친다면 `.properties`가 우선됩니다.\n\n\n## @Value\n\n\n```java\n\n\nimport org.springframework.beans.factory.annotation.Value;\n\n\nimport org.springframework.stereotype.Component;\n\n\n\n@Component\n\n\npublic class MyBean {\n\n\n\n    @Value(\"${name}\")\n\n\n    private String name;\n\n\n\n    // ...\n\n\n\n}\n\n\n```\n\n\n\n@Value를 사용한 방법은 SpEL(Spring Expression Language)를 지원합니다.\n\n\n정규식, 클래스, 선언문, 컬렉션등 다양한 표현을 이용한 값을 불러올 수 있습니다.\n\n\n이런 표현식을 통해 위에서 말한 환경변수에 해당하는 값들과 일치하는 경우 불러와 사용할 수 있습니다.\n\n\n\n## @ConfigurationProperties\n\n\n@ConfigurationProperties는 값이 많을 때, 그리고 복잡할 수록 유용합니다.\n\n\n먼저 사용하려면 configuration processor 플러그인과 설정이 필요합니다.\n\n\n\n```gradle\n\nannotationProcessor \"org.springframework.boot:spring-boot-configuration-processor\"\n\n```\n\n\n그리고 아래와 같이 설정을 추가해야 합니다.\n\n\n\n```java\n\n\n@Configuration()\n\n\n@EnableConfigurationProperties(MyProperties.class)\n\n\npublic class MyConfiguration {\n\n\n}\n\n\n```\n\n\n\n이후 간단하게 값을 명시해주는 경우 `@ConfigurationProperties`로 가능합니다.\n\n\n다른 곳에서 값을 사용하려면 당연히 getter가 필요할 겁니다.\n\n\nsetter의 경우 properties 값이 바인딩 될 때 사용되므로 필수로 넣어줘야 합니다.\n\n\n롬복을 사용한다면 둘다 간단하게 적용할 수 있습니다.\n\n\n```java\n\n@ConfigurationProperties(\"my.service\")\n\npublic class MyProperties {\n\n\n    private boolean enabled;\n\n\n    private InetAddress remoteAddress;\n\n\n    private final Security security = new Security();\n\n\n    // getters / setters...\n\n\n    public static class Security {\n\n\n        private String username;\n\n\n        private String password;\n\n\n        private List<String> roles = new ArrayList<>(Collections.singleton(\"USER\"));\n\n\n        // getters / setters...\n\n\n    }\n\n\n}\n\n```\n\n\n## 열려있는 setter\n\n위에서 봤듯이 값을 바인딩하기 위해서 setter가 필수로 필요한데 이는 다른 곳에서 값을 변경할 수 있습니다.\n\n보통 환경변수 값은 변경하지 않고 불변값으로 사용하므로 이를 막을 수 있는 방법을 제공합니다.\n\n멤버 변수를 final로 선언하고 `@ConstructorBinding`을 선언하면 됩니다.\n\n\n```java\n\n@ConstructorBinding\n\n@ConfigurationProperties(prefix = \"my.service\")\n\npublic class MyProperties {\n\n\n    private final String redirectUri;\n\n\n    private final String clientId;\n\n\n    private final String clientSecret;\n\n\n    private final String accessToken;\n\n\n}\n\n```\n\n\n## 변수 작성 시 이름 짓는 규칙\n\nJava에서 변수명을 보통 camel case로 작성하듯 yaml 변수 명도 자주 사용하는 방식이 있습니다.\n\nKebab case로 두 단어를 - 로 구분해 표시합니다.\n\nSpring 문서에서 제공한 규칙은 다음과 같습니다.\n\n\n- first-name : 제일 추천하는 방식\n\n- first_name : 대체 방식\n\n- firstName : camel case 방식\n\n- FIRSTNAME : 시스템 환경 변수 방식\n\n\n어느 것을 써도 일관성 있게 사용하기만 하면 되지만 추천하는 방식을 사용하면 값을 불러올 때 달라지게 됩니다.\n\nfirst-name 과 firstName 처럼 값이 달라지게 되는데 `@ConstructorBinding`에서는 이를 해석해 바인딩합니다.\n\n따라서 어느쪽을 써도 Java에서 camel case로 작성하면 그대로 사용할 수 있습니다.\n\n\n## 메타 데이터 지원\n\n추가적으로 `@ConstructorBinding`에서는 메타 데이터를 지원하는데 IDE에서 변수에 대한 자동완성을 돕습니다.\n\nyml 파일을 작성할 때도 변수에 키 값들이 자동완성되거나 설명을 볼 수 있었을텐데 그런 값들을 지정할 수 있습니다."},{"metadata":{"layout":"post","title":"Java 버전은 뭘 써야할까?","date":"2022-02-15 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Java 버전"},"content":"\n2021년 기준 Java 17까지 나왔습니다.\n\n이 중에서 어떤 버전을 써야할까요?\n\n### LTS 버전일까?\n\n현재 Java 에서 지원하는 LTS 버전은 **8, 11, 17**입니다.\n\nLTS 버전은 A/S 보증 기간과 비슷합니다.\n평소에는 상관없지만 문제가 생겼을 때 LTS는 개발사에서 직접 해결해줄 수 있습니다.\n취약점이나 버그, 연동되는 툴들에서 사용자가 신경써야하는 부분이 줄어듭니다.\n예를 들면 예전 Docker와의 호환성이 안좋았더라도 LTS 버전은 이를 해결한 업데이트를 제공합니다.\n따라서 8보다 9, 10이 높더라도 LTS인 8을 주로 선택하는 이유입니다.\n\n### 당연히 최신 것 써야하는 거 아냐?\n\nLTS 버전끼리 서로 지원되는 기간이 비슷하다고 하면 더 높은 버전을 쓰는게 좋을까요?\n다른 문법적인 변화는 제쳐두고 성능으로만 비교하면 맞습니다.\n자바에서 \"성능\"이라고 하면 제일 먼저 비교의 대상으로 GC를 생각할 수 있습니다.\nGC 기준으로 8 보다는 11이, 11보다는 17이 성능면에서 향상된 것을 확인할 수 있습니다.\n따라서 새로 시작하는 프로젝트라면 새로운 버전을 사용하는것이 합리적입니다.\n다만 이전의 프로젝트에서 버전을 높이려고 하는 경우라면 생각해야할 점이 많습니다.\n\n1.  호환성\n2.  정책\n3.  빌드 툴 지원\n\n다른 연결되는 소프트웨어와 호환이 잘되는지 확인하는데 시간이 걸릴 수 있습니다.\n그리고 다른 팀 혹은 다른 회사와 업데이트에 관한 논의와 규칙이 정해졌는지 생각해야 합니다.\n또 IDE나 빌드 도구들에서 간혹 업데이트가 늦어 새로운 버전에 지원이 미흡한 경우가 있습니다.\n이런 모든 과정을 생각했을 때의 비용보다 성능으로 얻는 이점이 클 때 이전하는 작업을 할 겁니다.\n당연히 기존에 잘 작동했으므로 이런 작업들은 우선순위가 낮을 수 밖에 없습니다.\n하지만 보증 기간이 얼마 남지 않았거나, 새로운 버전의 검증이 충분히 된 경우 시간을 들일 필요가 있습니다.\n\n### OpenJDK? OracleJDK?\n\nJava 설치에 있어서 보통 OpenJDK와 OracleJDK 중에 선택할 겁니다.\n이름을 봤을 때는 둘이 다른 것 같지만 OpenJDK와 OracleJDK 모두 오라클 사에서 만듭니다.\n차이점은 OpenJDK는 무료이지만 오라클에서 추가 업데이트나 지원을 받기 어렵습니다.\nOracleJDK는 개발시에는 무료이지만 상용인 경우 요금을 내야하며, 오라클에서 지원을 받을 수 있습니다.\n따라서 OpenJDK를 써도 무방하지만 추후에 안전성이 더 필요한 경우 OracleJDK를 선택하면 됩니다."},{"metadata":{"layout":"post","title":"Http 헤더 대소문자 구분","date":"2022-02-15 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Http 헤더 대소문자"},"content":"\n## 대소문자 구분?\n\n정답은 Name는 구분하지 않고 Value는 상관 없습니다.\n[RFC 2616](https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2)에 명시된 내용에 따르면 헤더는 \":\" 를 기준으로 name과 value로 구성되어 있습니다.\n그리고 name은 대소문자를 구분하지 않는다고 명시되어 있습니다.\n\n---\n\n당연한 내용일 수도 있지만 몰랐던 사실을 알게 된건 Httpheaders를 사용하면서였습니다.\nJava에서 기본으로 제공하는 HttpHeaders는 기본 생성자가 private으로 인자를 넣어준 생성자만 접근가능합니다.\n\n```java\nimport java.net.http.HttpHeaders\n...\n\nprivate HttpHeaders(){\n...\n}\n```\n\n그렇지만 Spring에서 제공하는 HttpHeaders는 기본 생성자를 사용할 수 있습니다.\n\n```java\nimport org.springframework.http.HttpHeaders;\n...\n\npublic HttpHeaders() {\n  this(CollectionUtils.toMultiValueMap(new LinkedCaseInsensitiveMap<>(8, Locale.ENGLISH)));\n}\n```\n\nLinkedCaseInsensitiveMap은 이름에서 보듯이 대소문자를 구분하지 않는 Map입니다.\n\n```java\nmap.put(\"name\", \"value1\");\nmap.put(\"Name\", \"value2\");\n\nSystem.out.println(map.get(\"name\"));      // 결과는 value2\n```\n\n이런 자료구조를 사용하는 걸 봤을 때 http 헤더의 키는 대소문자를 구분하지 않는다고 예상할 수 있었습니다."},{"metadata":{"layout":"post","title":"Gradle","date":"2022-02-15 00:00:01 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Gradle"},"content":"\n# Gradle\nGradle은 오픈 소스 빌드 자동화 도구입니다.\n\n- 고성능 (변경 부분만 실행해서 불필요한 작업 방지)\n- JVM (JDK 필요)\n- 빌드 문제 식별 (문제가 발생하면 해결 정보 제공)\n\n## Gradle에 대해 알아야 할 5가지 사항\n\n### 1. Gradle은 범용 빌드 도구입니다.\nGradle은 빌드하려는 대상을 특정하지 않다고 가정합니다.\n그래도 제한 사항이 있다면 의존성 관리가 Maven, Ivy와 호환되는 시스템만 지원합니다.\n빌드하려면 플러그인을 추가해서 작업합니다.\n\n### 2. 핵심 모델은 Task입니다.\nGradle은 비순환 그래프를 만들어서 공통적인 Task을 다시 처리하지 않습니다.\nTask는 3가지로 구성됩니다.\n\n- Actions: 작업으로 파일을 복사하거나 컴파일등의 작업\n- Inputs: 값이나, 파일, 경로처럼 Actions에서 사용하는 것\n- Outputs: 파일이나 경로들이 Actions에서 만들어지는 것\n\n하지만 모든 Task는 위의 3가지를 선택사항으로 가집니다.\n그렇기 때문에 작업도 필요한 작업만 선택해서 실행할 수 있습니다.\n`incremental build`는 안정적이고 빠른 작업에 도움되므로 clean은 꼭 필요한 때만 씁니다.\n\n### 3. Gradle에는 고정 빌드 단계가 있습니다.\n1. Initialization\n\n빌드 환경을 설정하고 어느 프로젝트를 실행할지 결정합니다.\n\n2. Configuration\n\ntask를 구성하고 설정하고, 실행할 task와 실행 순서를 어떻게 할지 결정합니다.\n\n3. Execution\n\n선택한 task를 실행합니다.\n\n### 4. Gradle은 확장 가능한 방법이 많습니다.\nTask 타입을 추가하거나 action, action의 순서, convetion, model등을 추가할 수 있습니다.\n\n### 5. Gradle Build Script는 API 처럼 동작합니다.\nGradle script는 실행 가능한 코드처럼 보이지만 API처럼 구현을 설명하지 않습니다.\n구현 세부 사항은 플러그인에게 있고 script는 실행 단계만 설명합니다.\n따라서 명령형처럼 실제 실행할 로직을 넣는 것은 피해야 합니다.\n\n"},{"metadata":{"layout":"post","title":"TIL 210215","date":"2022-02-15 00:00:01 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220215TIL"},"content":"\n## Gradle \nGradle 기본 학습\n"},{"metadata":{"layout":"post","title":"TIL 210214","date":"2022-02-14 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220214TIL"},"content":"\n## QueryDsl\nQueryDsl 강의 학습 \n"},{"metadata":{"layout":"post","title":"TIL 210213","date":"2022-02-13 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220213TIL"},"content":"\n## Mockito\nMock entity id \n"},{"metadata":{"layout":"post","title":"TIL 210212","date":"2022-02-12 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220212TIL"},"content":"\n## OKHttp\nHttp Client 기능"},{"metadata":{"layout":"post","title":"MySQL Max Key Length","date":"2022-02-11 00:01:00 +0900","category":"trouble","tags":["trouble"],"keywords":["trouble"],"id":"MySQL Max Key"},"content":"\nMySQL에서 unique 옵션이나 키로 설정한 값이 1000 바이트가 넘어간 경우 에러가 발생합니다.\n> Specified key was too long; max key length is 1000 bytes\n\n흔히 발생하는 경우가 varchar(255)로 설정하는 경우 1020 바이트로 1000 바이트를 넘습니다.\n이런 칼럼을 unique 옵션을 넣거나 하면 에러가 발생합니다.\n이렇게 막는 이유 중 하나는 인덱스 때문입니다.\n키나 유니크는 자동으로 인덱스 처리가 되는데 이때 길이가 너무 길게 되면 처리에 문제가 있습니다.\n따라서 아무리 커도 varchar의 경우 인덱스 처리가 필요할 시 아무리 커도 250으로 설정해야 합니다.\n"},{"metadata":{"layout":"post","title":"TIL 210211","date":"2022-02-11 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220211TIL"},"content":"\n## Youtube API\nyoutube api 기능\n\n## Refresh Token\nrefresh token 발급\n"},{"metadata":{"layout":"post","title":"Spring Security OAuth2 Client Refresh Token","date":"2022-02-10 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring Security OAuth2 Client"},"content":"\n## Google OAuth2 Refresh Token\n`구글` OAuth2 기준 다른 설정 없이 Authorization Code 로 Token을 받으면 refresh Token을 받을 수 없습니다.\n구글 OAuth2에서 refresh token을 요청하려면 필요한 조건들이 있습니다.\n\n- access_type : offline 설정\n- prompt : consent (처믕 설정 시)\n\naccess_type 옵션은 브라우저가 아닌 서버에서 재요청하기 위해 refresh token을 요청하는 옵션입니다.\nprompt는 OAuth2 인증을 위해 요청하는 화면이 나오는 기준을 설정합니다.\n설정하지 않으면 기본적으로 처음 요청시에만 확인을 받고 그 이후에는 받지 않습니다.\n처음에 refresh token을 받았으면 상관 없지만 테스트를 위해 refresh token을 확인하고 싶은 경우 consent를 설정해야 합니다.\n그 이유는 구글에서 refresh token은 사용자에게 직접 인증을 받는 순간에만 제공됩니다. \n그 이후에는 access_type이 offline 이더라도 이미 인증 받은 경우 refresh token이 제공되지 않습니다.\n\n## Spring Security OAuth2 Client에서 설정하기\nspring security oauth2 client를 사용하면 oauth2 연결을 쉽게 사용할 수 있습니다.\napplication.yml에서 client-id와 client-secret 그리고 인증을 받을 범위등 옵션등을 설정할 수 있습니다.\n\n```yaml\n  security:\n    oauth2:\n      client:\n        registration:\n          google:\n            client-id: {client-id}\n            client-secret: {client-secret}\n            redirectUri: \"{baseUrl}/oauth2/callback/{registrationId}\"\n            scope:\n              - email\n              - profile\n```\n\n하지만 yml 설정에서 할 수 없는 부분은 refresh token을 받기 위한 설정을 추가할 수 없습니다. \naccess_type이나 prompt 같은 옵션 파라미터를 추가하려면 추가적인 설정이 필요합니다.\n설정할 수 있는 방법은 두 가지가 방법이 있습니다.\n\n### ClientRegistrationRepository 수정하기\nClientRegistrationRepository는 위에서 등록한 client registration들을 불러와 정보들을 보관합니다.\n여기에서 인증 요청을 위해 사용되는 주소는 `authorizationUri`입니다.\n이 주소 뒤에 필요한 파라미터 쿼리를 추가해주면 됩니다.\naccess_type을 추가한다면 다음과 같은 주소가 됩니다.\n> \"https://accounts.google.com/o/oauth2/v2/auth/?access_type=offline\"\n\n```java \n@Configuration\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic ClientRegistrationRepository clientRegistrationRepository() {\n\t\treturn new InMemoryClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n\t\treturn ClientRegistration.withRegistrationId(\"google\")\n\t\t\t.clientId(\"google-client-id\")\n\t\t\t.clientSecret(\"google-client-secret\")\n\t\t\t.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n\t\t\t.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n\t\t\t.redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n\t\t\t.scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n\t\t\t.authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n\t\t\t.tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n\t\t\t.userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n\t\t\t.userNameAttributeName(IdTokenClaimNames.SUB)\n\t\t\t.jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n\t\t\t.clientName(\"Google\")\n\t\t\t.build();\n\t}\n}\n```\n스프링 공식 문서에서 제공하는 ClientRegistration 구성 코드입니다.\n하지만 설명에는 모든 설정이 하드코딩된 형태로 보통 이렇게 client-id 나 client-secret을 공개된 형태로 사용하지 않습니다.\n위에서 사용하듯이 yml처럼 환경 변수로 코드 밖에서 따로 관리하길 원합니다.\n따로 환경 변수를 불러올 수도 있지만, oauth2 client에서 기본적으로 설정한 구성을 그대로 불러오고 싶을 수 있습니다.\n이 경우 Spring에서는 `OAuth2ClientProperties` 클래스를 통해 불러올 수 있습니다.\n따라서 위의 코드를 수정하면 다음과 같은 형태가 됩니다.\n\n```java \n@Configuration\n@RequiredArgsConstructor\npublic class OAuth2LoginConfig {\n\n  private final OAuth2ClientProperties properties;\n\n  @Bean\n  public ClientRegistrationRepository clientRegistrationRepository() {\n    return new InMemoryClientRegistrationRepository(this.googleClientRegistration());\n  }\n\n  private ClientRegistration googleClientRegistration() {\n    Registration googleRegistration = this.properties.getRegistration().get(\"google\");\n    \n    return ClientRegistration.withRegistrationId(\"google\")\n        .clientId(googleRegistration.getClientId())\n        .clientSecret(googleRegistration.getClientSecret())\n        .clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n        .authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n        .redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n        .scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n        .authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth/?access_type=offline\")\n        .tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n        .userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n        .userNameAttributeName(IdTokenClaimNames.SUB)\n        .jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n        .clientName(\"Google\")\n        .build();\n  }\n}\n```\ngoogle이 아니더라도 registration에 등록한 키 값을 기준으로 불러와 속성들을 가져와 사용할 수 있습니다.\n\n### CustomAuthorizationRequestResolver 추가하기\nClientRegistrationRepository를 수정하는 것도 방법이지만 옵션만 추가하는 건데 등록 정보 전부를 불러오는 건 번거로울 수 있습니다.\n다른 방법으로는 AuthorizationRequestResolver를 구현하는 방법으로 request에 resolver를 추가할 수 있습니다.\nAuthorizationRequestResolver를 구현하고 나면 추가할 위치는 다음 코드와 같습니다.\n\n```java \n@EnableWebSecurity\n@RequiredArgsConstructor \npublic class SecurityConfig extends WebSecurityConfigurerAdapter {\n\n private final ClientRegistrationRepository clientRegistrationRepository;\n\n @Override\n  protected void configure(HttpSecurity http) throws Exception {\n    http.\n    .oauth2Login()\n        .authorizationEndpoint()\n        .authorizationRequestResolver(customAuthorizationRequestResolver))\n```\n\nAuthorizationRequestResolver는 ClientRegistrationRepository를 생성 파라미터로 받습니다.\n이 코드는 Spring docs에서 제공하는 파리미터를 수정하는 코드에서 access_type을 추가한 코드입니다.\n코드를 살펴보면 생성자로 ClientRegistrationRepository를 주입 받습니다.\n위에서 ClientRegistationRepository를 수정했다면 중복해서 처리되므로 하나만 선택해서 설정해야 합니다.\n다음으로 OAuth2AuthorizationRequestResolver로 DefaultOAuth2AuthorizationRequestResolver를 만들어서 사용합니다.\n구현하는 클래스를 필드값으로 갖고 있는 이유는 DefaultOAuth2AuthorizationRequestResolver는 final 클래스로 상속받을 수 없습니다.\n상속받을 수 없지만 Spring에서 기본적으로 사용하는 위 클래스가 구현하는 기능이 많기 때문에 가져와서 쓰는 것이 편합니다.\n모든 기능을 그대로 복사해서 사용해도 되지만 그것도 마찬가지로 중복이 많아지게 됩니다.\n따라서 필드값으로 사용해서 기본 기능을 실행하고 추가적인 옵션을 넣는 식으로 구현됩니다.\n\n```java \n@Component\npublic class CustomAuthorizationRequestResolver implements OAuth2AuthorizationRequestResolver {\n\n  private final OAuth2AuthorizationRequestResolver defaultAuthorizationRequestResolver;\n\n  public CustomAuthorizationRequestResolver(\n      ClientRegistrationRepository clientRegistrationRepository) {\n\n    this.defaultAuthorizationRequestResolver =\n        new DefaultOAuth2AuthorizationRequestResolver(\n            clientRegistrationRepository, \"/oauth2/authorize\");\n  }\n\n  @Override\n  public OAuth2AuthorizationRequest resolve(HttpServletRequest request) {\n    OAuth2AuthorizationRequest authorizationRequest =\n        this.defaultAuthorizationRequestResolver.resolve(request);\n\n    return authorizationRequest != null ?\n        customAuthorizationRequest(authorizationRequest) :\n        null;\n  }\n\n  @Override\n  public OAuth2AuthorizationRequest resolve(\n      HttpServletRequest request, String clientRegistrationId) {\n\n    OAuth2AuthorizationRequest authorizationRequest =\n        this.defaultAuthorizationRequestResolver.resolve(\n            request, clientRegistrationId);\n\n    return authorizationRequest != null ?\n        customAuthorizationRequest(authorizationRequest) :\n        null;\n  }\n\n  private OAuth2AuthorizationRequest customAuthorizationRequest(\n      OAuth2AuthorizationRequest authorizationRequest) {\n\n    Map<String, Object> additionalParameters =\n        new LinkedHashMap<>(authorizationRequest.getAdditionalParameters());\n    additionalParameters.put(\"access_type\", \"offline\");\n    additionalParameters.put(\"prompt\", \"consent\");\n\n    return OAuth2AuthorizationRequest.from(authorizationRequest)\n        .additionalParameters(additionalParameters)\n        .build();\n  }\n}\n```\n\n## Refresh Token 사용하기\n위에서 받아온 Refresh Token은 `OAuth2AuthorizedClientService`에서 관리됩니다.\n따라서 사용할 클래스에서 Bean으로 주입받고 사용하면 됩니다.\nOAuth2AuthorizedClientService에서 loadAuthorizedClient로 저장된 정보를 불러와 사용할 수 있습니다.\n```java \n  private final OAuth2AuthorizedClientService oAuth2AuthorizedClientService;\n\n  OAuth2AuthorizedClient user = oAuth2AuthorizedClientService.loadAuthorizedClient(\"google\", authentication.getName());\n  OAuth2RefreshToken refreshToken = user.getRefreshToken();\n```\n\nController에서 사용하는 경우 다른 방법으로 받을 수 있습니다.\n```java \n@GetMapping(\"/foo\")\nvoid foo(@RegisteredOAuth2AuthorizedClient(\"google\") OAuth2AuthorizedClient user) {\n    OAuth2RefreshToken refreshToken = user.getRefreshToken();\n}\n```\n\n---\n이렇게 정리한 이유는 OAuth2 Access Token만으로 구현한 글들은 많이 접할 수 있었지만 Refresh Token은 많이 없었습니다.\n로그인이 아니라 API를 호출하는 경우 이후에 토큰을 갱신하기 위해서 필요한데 생길 수 있는 문제를 정리해봤습니다."},{"metadata":{"layout":"post","title":"TIL 210210","date":"2022-02-10 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220210TIL"},"content":"\n## ClientRegistrationRepository\nOAuth2 Client 세부 설정 변경\n\n"},{"metadata":{"layout":"post","title":"invalid_token_response","date":"2022-02-09 00:01:00 +0900","category":"trouble","tags":["trouble"],"keywords":["trouble"],"id":"invalid-token"},"content":"\n## [invalid_token_response]\n`An error occurred while attempting to retrieve the OAuth 2.0 Access Token Response`\n직전까지 잘되던 OAuth2 인증에서 에러가 발생했습니다. \n서버에 에러 로그도 없이 클라이언트에서 보이는 에러였기에 문제점을 찾지 못했습니다.\n그러다가 어쩌다가 OAUth2 Client Secret Key를 보니 이전에 설정했던 것과 달라져 있었습니다.\n주기적으로 테스트용 구글 client secret key가 만료가 되어 바뀌는 것이 문제점이었습니다. \n"},{"metadata":{"layout":"post","title":"TIL 210209","date":"2022-02-09 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220209TIL"},"content":"\n## react toastify\n알림창을 예쁘게 보여주는 라이브러리\n\n"},{"metadata":{"layout":"post","title":"TIL 210208","date":"2022-02-08 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220208TIL"},"content":"\n## NextJS Routing\n- NextJS 라우팅 사용법 숙지\n\n## SSR 환경에서 context\n- localstorage 접근 방법\n"},{"metadata":{"layout":"post","title":"[백준] 순위 검색","date":"2022-02-07 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"행성 터널"},"content":"\n```java \nimport java.util.*\n\nvar parent: IntArray = intArrayOf()\nvar rank: IntArray = intArrayOf()\n\nfun main() {\n    val n = readLine()!!.toInt()\n    val xQueue: MutableList<Pair<Int, Int>> = mutableListOf()\n    val yQueue: MutableList<Pair<Int, Int>> = mutableListOf()\n    val zQueue: MutableList<Pair<Int, Int>> = mutableListOf()\n\n    repeat(n) {\n        val (x, y, z) = readLine()!!.split(\" \").map { it.toInt() }\n        xQueue.add(Pair(it, x))\n        yQueue.add(Pair(it, y))\n        zQueue.add(Pair(it, z))\n    }\n    xQueue.sortBy { it.second }\n    yQueue.sortBy { it.second }\n    zQueue.sortBy { it.second }\n\n    val queue: PriorityQueue<Pair<Pair<Int, Int>, Int>> = PriorityQueue(compareBy { it.second })\n    for (i in 0 until n - 1) {\n        queue.add(\n            Pair(\n                Pair(xQueue[i].first, xQueue[i + 1].first),\n                xQueue[i + 1].second - xQueue[i].second\n            )\n        )\n        queue.add(\n            Pair(\n                Pair(yQueue[i].first, yQueue[i + 1].first),\n                yQueue[i + 1].second - yQueue[i].second\n            )\n        )\n        queue.add(\n            Pair(\n                Pair(zQueue[i].first, zQueue[i + 1].first),\n                zQueue[i + 1].second - zQueue[i].second\n            )\n        )\n    }\n\n    var result = 0\n    parent = IntArray(n) { it }\n    rank = IntArray(n) { 1 }\n    while (queue.isNotEmpty()) {\n        val (loc, distance) = queue.poll()\n        val (a, b) = loc\n        val connect = union(a, b)\n        if (connect) result += distance\n    }\n    println(result)\n}\n\nprivate fun union(a: Int, b: Int): Boolean {\n    val aRoot = find(a)\n    val bRoot = find(b)\n    if (aRoot == bRoot) return false\n    if (rank[aRoot] < rank[bRoot]) {\n        parent[aRoot] = bRoot\n    } else {\n        parent[bRoot] = aRoot\n        if (rank[aRoot] == rank[bRoot]) rank[aRoot]++\n    }\n    return true\n}\n\nprivate fun find(a: Int): Int {\n    if (parent[a] == a) return a\n    val findParent = find(parent[a])\n    parent[a] = findParent\n    return findParent\n}\n```\n\n## 실수했던 점\n처음에는 메모리 초과, 그 다음으로는 시간 초과가 계속 발생했던 문제였습니다.  \n그 이유는 행성 간 연결이 최대인 경우 10000 * 99999 / 2 만큼 발생하게 됩니다.  \n이 경로를 전부 저장하려고 했다가 메모리 초과가 나왔습니다.\n그 다음으로는 한 점에서 다음 행성들에서 나올 수 있는 최솟값만 저장하려고 했습니다.  \n이 방법도 마찬가지로 연결이 최대인 경우 시간 초과가 나와서 통과하지 못했습니다.  \n결국 해결방법은 무식해보이지만 각 축마다 정렬을 하고 인접한 두 점들만 넣어서 구하면 됐습니다.\n인접한 두 점들만 구하면 된다는 걸 모르면 해결하기 어려운 문제였습니다. "},{"metadata":{"layout":"post","title":"단일 랜덤 재생 목록","date":"2022-02-07 00:01:00 +0900","category":"project","tags":["project"],"keywords":["project"],"id":"단일 랜덤 재생 목록"},"content":"\n## 홈화면 재생 목록\n현재 프로젝트에서 홈화면에서 기본 재생 목록이 제공됩니다.\n이 때 재생목록을 주기적으로 랜덤 재생목록을 불러와 변경시키려고 합니다.\n문제는 현재 설정된 홈화면 재생목록을 저장하는 방법이었습니다.\n\n### 해결 방법 1\n플레이리스트에 현재 재생중인 목록을 표시하는 필드를 생성합니다.\n검색할 때 재생중인 필드가 참인 값을 불러와서 사용합니다.\n\n- 문제점: 유일한 로우를 위해 전체 플레이리스트에 필드가 추가됩니다.\n\n### 해결 방법 2\n재생중인 목록을 저장하는 테이블을 생성합니다.\nnow_playing 처럼 재생중인 목록을 관리하는 테이블에서 불러와 사용합니다.\n\n- 문제점: 유일한 로우를 위해 테이블 하나를 관리해야 합니다.\n\n### 해결 방법 3\nKey-value 구조의 DB를 추가로 사용합니다.\nKey-value라면 당연히 현재 재생중인 키값으로 불러오면 값은 유일합니다.\n\n- 문제점: 추가적인 데이터베이스를 관리해야 합니다.\n\n### 해결 방법 4\n특정 관리자 계정의 지금 재생중 목록을 불러와 사용합니다.\n"},{"metadata":{"layout":"post","title":"Java URI Builder","date":"2022-02-07 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Uri Builder"},"content":"\n## URI Builder\n자바에서 URI 클래스는 문자열에서 URI 객체를 생성하거나 URI 구성 별로 가져올 수 있습니다.\n하지만 구성 요소들을 조합해서 URI를 만들려고 할 때 직접 문자열들을 합쳐서 만들 수 밖에 없습니다.\n\n```java\nURI uri = new URI(host + port + path + query);\n```\n\nquery에 여러 값이 들어가거나 하면 만드는게 번잡해집니다.\n이런 불편함을 해소하기 위해 URI 빌더 클래스들이 있습니다.\n대표적으로 Spring의 UriComponentsBuilder가 있습니다.\n\n```java \nUriComponentsBuilder uri = UriComponentsBuilder.fromUri(uri)\n                                .queryParam(\"name\", name)\n                                .queryParam(\"age\", age)\n                                .build();\n```\n\n문자열을 직접 조합할 필요 없이 key value 형식으로 query를 조합할 수 있습니다.\n\n## URI query 파싱하기\nquery의 전체부분을 가져오는 방법은 간단합니다.\n\n```java \nuri.getQuery();\n```\n\n다만 이렇게 출력된 결과는 query에 key value를 구분하는 특수문자('=', '&') 이 전부 합쳐져 있습니다.\n구분한 값을 받아오려면 `getQueryParams()`를 사용하면됩니다.\n반환된 결과는 MultiValueMap인데 그 이유는 쿼리에서 하나의 key에 여러 value를 넣을 수 있어서 입니다. \n따라서 key 에 따라 반환된 List String value 값들을 사용하면 됩니다.\n\n```java \nMultiValueMap<String, String> queryParams = u.getQueryParams();\n```\n\n"},{"metadata":{"layout":"post","title":"MySQL PublicKey Retrieval","date":"2022-02-07 00:01:00 +0900","category":"trouble","tags":["trouble"],"keywords":["trouble"],"id":"MySQL Public key retrieval"},"content":"\n## Public key retrieval is not allowed\nuseSSL=false로 설정되어 있을 때 발생하는 에러입니다.\n\n## 해결 방법\n\n### allowPublicKeyRetrieval 설정하기\nallowPublicKeyRetrieval는 RSA 공개키를 검색하거나 가져오는 설정을 정합니다.\ntrue 값을 주면 연결에 성공합니다.  \n"},{"metadata":{"layout":"post","title":"TIL 210207","date":"2022-02-07 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220207TIL"},"content":"\n## 쿠키\n- 쿠키 개념 정리\n\n## OAuth2 인증 플로우 \n- OAuth2 인증 플로우 정리"},{"metadata":{"layout":"post","title":"Spring Security OAuth2","date":"2022-02-06 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring Security OAuth2"},"content":"\n# OAuth2 Login\n\n## application.yml 설정하기\n```yaml\nspring:\n  security:\n    oauth2:\n      client:\n        registration:\t\n          google:\t\n            client-id: google-client-id\n            client-secret: google-client-secret\n```\n\n1. spring.security.oauth2.client.registration 까지 고정적으로 쓰이는 속성입니다.\n2. `google` 처럼 고정된 id에 따라 OAuth2 인증을 진행할 수 있습니다.\n\n## OAuth2 인증 시 결과\nOAuth2 로그인을 마치면 기본 개인정보를 받으면서 인증 세션이 연결됩니다.\n\n## 부가적인 설정\nredirect uri 나 인증 방식 그리고 OAuth2 인증 범위등을 설정할 수 있습니다.  \n```yaml\nredirect-uri: {baseUrl}/login/oauth2/code/{registrationId}\n```\nredirectUri의 기본형식입니다. 그대로 입력하면 baseUrl에는 현재 주소가 들어갑니다.\nregistrationId는 위에서 사용한 Id가 그대로 들어가게 됩니다.\n따라서 redirectUri를 수정한다면 위의 템플릿을 이용해서 수정하면 됩니다.\n\n## OAuth2 설정 오버라이드하기\nOAuth2 설정을 오버라이드하는 방법에는 3가지가 있습니다.\n그 중에서 스프링을 사용한다면 2가지 방법을 사용하게 됩니다.\n\n### ClientRegistrationRepository @Bean\n```java\n@Configuration\npublic class OAuth2LoginConfig {\n\n\t@Bean\n\tpublic ClientRegistrationRepository clientRegistrationRepository() {\n\t\treturn new InMemoryClientRegistrationRepository(this.googleClientRegistration());\n\t}\n\n\tprivate ClientRegistration googleClientRegistration() {\n\t\treturn ClientRegistration.withRegistrationId(\"google\")\n\t\t\t.clientId(\"google-client-id\")\n\t\t\t.clientSecret(\"google-client-secret\")\n\t\t\t.clientAuthenticationMethod(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n\t\t\t.authorizationGrantType(AuthorizationGrantType.AUTHORIZATION_CODE)\n\t\t\t.redirectUri(\"{baseUrl}/login/oauth2/code/{registrationId}\")\n\t\t\t.scope(\"openid\", \"profile\", \"email\", \"address\", \"phone\")\n\t\t\t.authorizationUri(\"https://accounts.google.com/o/oauth2/v2/auth\")\n\t\t\t.tokenUri(\"https://www.googleapis.com/oauth2/v4/token\")\n\t\t\t.userInfoUri(\"https://www.googleapis.com/oauth2/v3/userinfo\")\n\t\t\t.userNameAttributeName(IdTokenClaimNames.SUB)\n\t\t\t.jwkSetUri(\"https://www.googleapis.com/oauth2/v3/certs\")\n\t\t\t.clientName(\"Google\")\n\t\t\t.build();\n\t}\n}\n```\n빈을 등록해서 기본적으로 설정되어 있는 구성들을 변경할 수 있습니다.\n\n### WebSecurityConfigurerAdapter\n```java\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t.authorizeHttpRequests(authorize -> authorize\n\t\t\t\t.anyRequest().authenticated()\n\t\t\t)\n\t\t\t.oauth2Login(withDefaults());\n\t}\n}\n```\n좀 더 범용적으로 쓰이는 WebSecurityConfigurerAdapter를 사용할 수 있습니다.\noauth2Login()에 변경할 내용들을 추가해주면 됩니다. 두 개를 같이 사용하는 방법도 있습니다.\n먼저 oauth2Login()에서 변경할 수 있는 구성 요소들입니다.\n```java \n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t.oauth2Login(oauth2 -> oauth2\n\t\t\t    .authorizationEndpoint(authorization -> authorization\n\t\t\t            ...\n\t\t\t    )\n\t\t\t    .redirectionEndpoint(redirection -> redirection\n\t\t\t            ...\n\t\t\t    )\n\t\t\t    .tokenEndpoint(token -> token\n\t\t\t            ...\n\t\t\t    )\n\t\t\t    .userInfoEndpoint(userInfo -> userInfo\n\t\t\t            ...\n\t\t\t    )\n\t\t\t);\n\t}\n}\n```\n- Authorization Endpoint: 클라이언트가 인증을 위해 접속하는 곳입니다.\n- Token Endpoint: 클라이언트가 접근 토큰으로 인가를 받는 곳입니다.\n- Redirection Endpoint: 인증 서버에서 인증 정보를 담은 결과를 보낼 곳입니다.\n- UserInfo Endpoint: 인증정보로 user에 대한 정보를 처리하는 곳입니다.\n\n### Login 페이지 처리\nSpring Security를 사용하면 기본적으로 로그인 페이지로 id, password 폼 창이 나옵니다.\nOAuth2-Client를 설정하고 yml에 등록된 OAuth2 id가 있다면 소셜 로그인 페이지로 바뀝니다.\n이런 Login Page처리는 `DefaultLoginPageGeneratingFilter`에서 이뤄집니다.\n각 이름은 등록된 `ClientRegistration.clientName`으로 표시됩니다.\n각 링크는 `OAuth2AuthorizationRequestRedirectFilter.DEFAULT_AUTHORIZATION_REQUEST_BASE_URI + \"/{registrationId}\"`이 됩니다.\n예를 들면 `/oauth2/authorization/google` 방식으로 구성됩니다.\n이런 로그인 페이지를 수정하려면 위치를 수정하려면 oauth2Login()에서 수정합니다.\n```java \n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t.oauth2Login(oauth2 -> oauth2\n\t\t\t    .loginPage(\"/login/oauth2\")\n\t\t\t    ...\n\t\t\t    .authorizationEndpoint(authorization -> authorization\n\t\t\t        .baseUri(\"/login/oauth2/authorization\")\n\t\t\t        ...\n\t\t\t    )\n\t\t\t);\n\t}\n}\n```\n\n### Redirection Endpoint\n기본적으로 OAuth2 응답 uri는 `/login/oauth2/code/*`로 설정되어 있습니다.\n이 정보는 `OAuth2LoginAuthenticationFilter.DEFAULT_FILTER_PROCESSES_URI`에 정의되어 있습니다.\n```java\n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t.oauth2Login(oauth2 -> oauth2\n\t\t\t    .redirectionEndpoint(redirection -> redirection\n\t\t\t        .baseUri(\"/login/oauth2/callback/*\")\n\t\t\t        ...\n\t\t\t    )\n\t\t\t);\n\t}\n}\n```\n원하는 redirectUri로 수정하려면 위처럼 수정하면 가능합니다. \n당연히 각 OAuth2 페이지에서 설정한 redirectUri 와 일치해야 합니다.\n\n## UserInfo Endpoint\n\n### Mapping User Authorities\nOAuth2 에서 받은 인증 정보로 사용자마다 권한을 부여할 수 있습니다.\n기본적으로 OAuth2 에서 제공되는 Authority는 ` OAuth2User.getAuthorities()`에서 제공됩니다.\n이 정보를 가지고 GrantedAuthority에 권한들을 매치시켜야 합니다.\n그리고 이런 권한은 OAuth2AuthenticationToken에 제공됩니다.\n\n### Using a GrantedAuthoritiesMapper\nGrantedAuthorityMapper 구현체를 만들어 매핑시킬 수 있습니다.\n```java \n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t.oauth2Login(oauth2 -> oauth2\n\t\t\t    .userInfoEndpoint(userInfo -> userInfo\n\t\t\t        .userAuthoritiesMapper(this.userAuthoritiesMapper())\n\t\t\t        ...\n\t\t\t    )\n\t\t\t);\n\t}\n\n\tprivate GrantedAuthoritiesMapper userAuthoritiesMapper() {\n\t\treturn (authorities) -> {\n\t\t\tSet<GrantedAuthority> mappedAuthorities = new HashSet<>();\n\n\t\t\tauthorities.forEach(authority -> {\n\t\t\t\tif (OidcUserAuthority.class.isInstance(authority)) {\n\t\t\t\t\tOidcUserAuthority oidcUserAuthority = (OidcUserAuthority)authority;\n\n\t\t\t\t\tOidcIdToken idToken = oidcUserAuthority.getIdToken();\n\t\t\t\t\tOidcUserInfo userInfo = oidcUserAuthority.getUserInfo();\n\n\t\t\t\t\t// Map the claims found in idToken and/or userInfo\n\t\t\t\t\t// to one or more GrantedAuthority's and add it to mappedAuthorities\n\n\t\t\t\t} else if (OAuth2UserAuthority.class.isInstance(authority)) {\n\t\t\t\t\tOAuth2UserAuthority oauth2UserAuthority = (OAuth2UserAuthority)authority;\n\n\t\t\t\t\tMap<String, Object> userAttributes = oauth2UserAuthority.getAttributes();\n\n\t\t\t\t\t// Map the attributes found in userAttributes\n\t\t\t\t\t// to one or more GrantedAuthority's and add it to mappedAuthorities\n\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn mappedAuthorities;\n\t\t};\n\t}\n}\n```\n\n### Delegation-based strategy with OAuth2UserService\nGrantedAuthoritiesMapper 대신 OAuth2UserService를 구현할 수 있습니다.\n입력값으로는 OAuth2UserRequest에서 OAuth2AccessToken을 받아올 수 있습니다.\n이 과정에서 사용자에게 인증 정보를 처리하기 전에 접근 토큰으로 인증 정보를 불러올 수 있습니다.  \n\n```java \n@EnableWebSecurity\npublic class OAuth2LoginSecurityConfig extends WebSecurityConfigurerAdapter {\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp\n\t\t\t.oauth2Login(oauth2 -> oauth2\n\t\t\t    .userInfoEndpoint(userInfo -> userInfo\n\t\t\t        .userService(this.oauth2UserService())\n\t\t\t        ...\n\t\t\t    )\n\t\t\t);\n\t}\n\n\tprivate OAuth2UserService<OAuth2UserRequest, OAuth2User> oauth2UserService() {\n\t\t...\n\t}\n}\n```\n\n`DefaultOAuth2UserService`는 OAuth2UserService의 구현체입니다.\n기본적으로 RestTemplate을 이용해 토큰에서 인증 정보를 불러오는 역할을 담당합니다.\n이렇게 받아온 인증 정보로 `AuthenticatedPrincipal`을 반환합니다.\n인증 처리 과정을 바꾸는 방법은 두 가지입니다.\n- 직접 OAuth2UserService 구현하기\n- DefaultOAuth2UserService에서 제공하는 set함수에 파라미터 제공하기\n"},{"metadata":{"layout":"post","title":"TIL 210206","date":"2022-02-06 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220206TIL"},"content":"\n## OAuth2-client\n- OAuth2 Client 정리"},{"metadata":{"layout":"post","title":"TIL 210205","date":"2022-02-05 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220205TIL"},"content":"\n## JWT\n- JWT 정리\n\n## OAuth2\n- OAuth2 기능 정리"},{"metadata":{"layout":"post","title":"Spring Security Authorization","date":"2022-02-04 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring Security Authorization"},"content":"\n## Authorities\n인증 정보에 담긴 권한은 GrantedAuthority 객체들에 담기게 됩니다.\nAuthenticationManager에 저장된 Authentication에 넣고 뺄 수 있습니다.\nGrantedAuhtority 인터페이스는 하나의 메소드만 갖고 있습니다.\n```java\nString getAuthority();\n```\n이 메소드는 AuthorizationManager의 GrantedAuthority를 나타냅니다.\n문자열로 반환되기 때문에 이후 접근 결정시 쉽게 읽을 수 있습니다.\n만약 문자열로 나타낼 수 없는 권한이라면 복잡한 형태로 null을 반환해야 합니다.\n\n복잡한 형태는 권한이 주어지는 형태가 복잡할 때 발생할 수 있습니다. \n이 경우 문자열로는 구분할 수 없기 때문에 null로 처리해서 AuthorizationManager에게\nGrantedAuthority를 다르게 처리해야 하는 것을 명시해야 합니다.\n\nSpring Security는 GrantedAuthority 구현으로 `SimpleGrantedAuthority`를 제공합니다.\n이 구현체는 사용자가 지정한 문자열들에게 권한을 부여합니다.\n`AuthenticationProvider`들은 `SimpleGrantedAuthority`를 이용해 Authentication을 채웁니다.\n\n## Pre-Invocation Handling\nSpring Security는 인터셉터로 접근 제어를 제공합니다.\nAccessDecisionManager에서 pre-invocation decision, 실행할지를 결정합니다.\n\n## The AuthorizationManager\nAuthorizationManager는 AccessDecisionManager와 AccessDecisionVoter를 대신합니다.\nAuthorizationManager은 AuthorizationFilter에 의해 호출 되어 최종적인 접근 결정을 내립니다.\n인터페이스는 두 가지 메소드를 가집니다.\n```java\nAuthorizationDecision check(Supplier<Authentication> authentication, Object secureObject);\n\ndefault AuthorizationDecision verify(Supplier<Authentication> authentication, Object secureObject)\n        throws AccessDeniedException {\n    // ...\n}\n```\ncheck 메소드는 관련 있는 정보들로 접근이 가능한지 확인합니다. \n접근이 가능하다면 Authorization 의 긍정적인 결과값이 담기게 되고 접근이 제한되면 부정적인 값이 나오게 됩니다.\n그리고 마찬가지로 결과를 결정할 수 없는 경우 null 값을 통해 결정을 미룹니다.\nverify는 check 메소드를 실행해 결과를 받고 부정적인 경우 AccessDeniedException 예외를 던집니다.\n\n## Delegate-based AuthorizationManager Implementations\nAuthorizationManager를 여러 개 만들어서 특정 상황에 맞는 경우 실행시킬 수 있도록 만들 수 있습니다.\n이 때 실행되기 전후로 실행시킬 메소드를 AuthorizationManagerBeforeMethodInterceptor, AuthorizationManagerAfterMethodInterceptor로 사용 가능합니다.\n\n## AuthorityAuthorizationManager\nAuthorizationManager의 가장 흔히 쓰이는 것으로 AuthorityAuthorizationManager가 쓰입니다.\n현재 인증 정보에서 Authentication을 불러와서 해당하는 authority가 있는 경우 긍정적으로 판단합니다.\n\n## AuthenticatedAuthorizationManager\n익명, 완전히 증명된, 기억하고 있는 증명 사용자를 구분합니다.\n\n## Hierarchical Roles\n권한을 계층적으로 설계하고 싶을 때 순위를 지정할 수 있습니다.\nadmin이 항상 user보다 높게 설정하고 싶거나 하는 경우 사용합니다.\n```java\n@Bean\nAccessDecisionVoter hierarchyVoter() {\n    RoleHierarchy hierarchy = new RoleHierarchyImpl();\n    hierarchy.setHierarchy(\"ROLE_ADMIN > ROLE_STAFF\\n\" +\n            \"ROLE_STAFF > ROLE_USER\\n\" +\n            \"ROLE_USER > ROLE_GUEST\");\n    return new RoleHierarcyVoter(hierarchy);\n}\n```\n"},{"metadata":{"layout":"post","title":"Spring Security Authentication","date":"2022-02-04 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring Security Authentication"},"content":"\n## Architecture\nSecurityContextHolder > SecurityContext > Authentication  \n- `SecurityContextHolder` 는 인증한 사람의 정보를 저장하는 곳입니다. \n- `SecurityContext`는 Holder로 부터 얻어서 현재 인증중인 사람의 인증정보를 얻습니다.\n- `Authentication`은 신원 정보를 담거나 들어온 입력을 의미합니다.\n  - 인증 정보는 AuthenticationManager로 넘어갈 수 있습니다.\n  - SecurityContext로 부터 신원정보를 받을 수 있습니다.\n- `GrantedAuthority` 는 Authentication에 저장된 사람의 부여된 권한입니다.\n- `AuthenticationManager`는 Spring Secuirty Filter가 인증을 수행하게 하는 API 입니다.\n- `ProviderManager` 는 AuthenticationManager의 대표적인 구현체입니다.\n- `AuthenticationProvider`는 ProviderManager 중 인증에 특화된 종류입니다.\n- `Request Crendentials with AuthenticationEntryPoint` 사용자에게 인증을 요청할 때 쓰입니다.\n- `AbstractAuthenticationProcessingFilter` 기본적인 인증을 위한 필터입니다.\n\n## SecurityContextHolder\n### 인증 정보 넣기\nSpring Security는 SecurityContextHolder의 구성방식은 신경쓰지 않습니다.  \n값이 채워져 있으면 현재 인증 정보라고 생각합니다.  \nSecurityContextHolder에 인증 정보를 넣는 간단한 방법은 바로 넣는 것입니다.\n```java\nSecurityContext context = SecurityContextHolder.createEmptyContext();\nAuthentication authentication =\n    new TestingAuthenticationToken(\"username\", \"password\", \"ROLE_USER\");\ncontext.setAuthentication(authentication);\n\nSecurityContextHolder.setContext(context);\n```\n1. 빈 SecurityContext를 생성합니다. SecurityContextHolder.getContext().setAuthentication(authentication)\n처럼 get으로 가져와서 쓰는 방식은 멀티 쓰레드 환경에서 경쟁 상태를 발생할 수 있습니다.\n2. Authentication 구현체를 만들어 넣어줍니다. 대표적인 구현체는 `UsernamePasswordAuthenticationToken`입니다.\n3. SecurityContext를 SecurityContextHolder에 넣어줍니다.\n\n### 인증정보 가져오기\n```java\nSecurityContext context = SecurityContextHolder.getContext();\nAuthentication authentication = context.getAuthentication();\nString username = authentication.getName();\nObject principal = authentication.getPrincipal();\nCollection<? extends GrantedAuthority> authorities = authentication.getAuthorities();\n```\nSecurityContextHolder는 ThreadLocal을 사용하기 때문에 같은 쓰레드내에서 언제든 접근이 가능합니다.  \n반대로 쓰레드가 끝나면 인증 정보를 전부 지우면 되기 때문에 안전합니다.\n별도의 Thread를 사용해서 ThreadLocal를 사용하기 애매한 경우 제공하는 다른 전략을 사용해 접근할 수 있습니다.\n\n## Authentication\n`Authentication`의 주요 목적은 두 가지입니다.\n- AuthenticationManager의 사용자 인증 정보 입력으로 사용됩니다.\n  - isAuthenticated() 가 false를 반환하는 등으로 쓰입니다.\n- SecurityContext가 담고 있는 현재 사용자의 인증 정보를 나타냅니다.\n\nAuthentication이 갖고 있는 정보입니다.\n- principal : 사요자가 누구인지 구분하는데 사용합니다. 주로 UserDetails를 사용합니다.\n- credentials : 주로 비밀번호로 유출을 방지하도록 끝난 이후에 지워집니다.\n- authroities : GrantedAuthoritys는 유저가 부여 받은 권한으로 role이나 scope가 해당합니다.\n\n## GrantedAuthority\nGrantedAuthority 는 `Authentication.getAuthorities()` 메소드로 얻습니다.  \n메소드는 GrantedAuthroity 객체의 Collection으로 반환됩니다. \nROLE_ADMINISTRATOR 처럼 `ROLE_` prefix로 구분되며 주로 UserDetailsService 에서 호출됩니다.  \n이러한 권한의 주의할 점은 주로 전역적으로 쓰이기 때문에 특정 객체를 기준으로 생성하면 안됩니다.  \n예를 들어 ID 54번 만을 위한 권한을 만들거나 각각으로 만들다보면 authorities가 많아져 메모리가 부족하게 됩니다.  \n\n## AuthenticationManager\nSpring Security Filter에서 인증을 수행하는 API입니다.\nController에서 SecurityContextHolder에 저장된 Authentication의 인증 정보를 얻으려할 때 호출됩니다.\n\n## ProviderManager\nProviderManager는 AuthenticationManager의 대표적인 구현체로 쓰입니다.  \nProviderManager는 AuthenticationProvider의 List에게 넘어갑니다.\n각각의 AuthenticationProvider는 성공, 실패 혹은 다음 AuthenticationProvider에서 결정하게 정할 수 있습니다.\n`ProviderNotFoundException`은 `AuthenticationException`중 인증을 위한 타입이 없다는 것을 나타내는 예외입니다.\nAuthenticationProvider가 여러 개인 이유는 password, SAML, token등 다양한 인증 방법을 가능하게 합니다.\n이렇게 여러가지 인증방법을 `AuthenticationManager` 빈 하나에서 관리할 수 있습니다.\n물론 여러 SecurityFilterChain을 관리하기 위해 AuthenticationManager의 구현체가 여러개 일 수 있습니다.\n\nProviderManager에서 주의할 점은 기본적으로 주요한 인증 정보는 지워진다는 점입니다.\n만약에 성능 향상을 위해 유저 객체등을 캐싱할려고 한다면 절대로 인증 정보의 참조값을 사용해선 안됩니다.\n지워지기 때문에 캐시에서 사용하려고 할 때는 없을 수 있습니다.\n명확한 해결책은 두 가지입니다. \n- 인증 정보 객체를 완전히 복사한 객체를 사용합니다.\n- eraseCredentialAfterAuthentication 속성을 끕니다.\n\n"},{"metadata":{"layout":"post","title":"TIL 210204","date":"2022-02-04 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220204TIL"},"content":"\n## Spring Security\n- 핵심 개념\n- 인증, 인가 방법"},{"metadata":{"layout":"post","title":"Spring Security Configuration","date":"2022-02-03 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring Security Configuration"},"content":"\n## Java Configuration\n```java\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport org.springframework.context.annotation.*;\nimport org.springframework.security.config.annotation.authentication.builders.*;\nimport org.springframework.security.config.annotation.web.configuration.*;\n\n@EnableWebSecurity\npublic class WebSecurityConfig {\n\n\t@Bean\n\tpublic UserDetailsService userDetailsService() {\n\t\tInMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();\n\t\tmanager.createUser(User.withDefaultPasswordEncoder().username(\"user\").password(\"password\").roles(\"USER\").build());\n\t\treturn manager;\n\t}\n}\n```\n\n\n"},{"metadata":{"layout":"post","title":"Spring Security Architecture","date":"2022-02-03 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Spring Security Architecture"},"content":"\n## Security\n애플리케이션에서 보안은 인증과 권한 두 가지 문제로 구분됩니다.\n\n### Authentication\n인증을 위한 주요 전략은 인증 메서드 하나면 됩니다.  \nauthenticate 메서드라고 한다면 예상되는 결과는 세 가지 중 하나입니다.  \n- 인증을 성공했습니다 -> 인증 주체 정보 + 인증 성공 정보\n- 인증을 실패했습니다 -> 인증 실패 예외 처리\n- 인증을 결정할 수 없습니다 -> 인증 정보 null\n\n인증 실패의 경우 401 응답과 예외 처리 정보를 보낼 수 있습니다.  \n인증 결정을 못한 경우 이어지는 다음 인증 처리로 넘기거나 예외처리할 수 있습니다.\n\n### Authorization\n권한은 인증이 성공한 이후에 이뤄지며 인증 정보를 가지고 권한을 판단합니다.  \n나온 결과로 ROLE_ADMIN, ROLE_AUDIT 처럼 보통 ROLE_ 로 권한을 구분합니다.\n\n## Web Security\n클라이언트에서 받아서 Servlet까지 가는 과정동안 Filters를 거치게 됩니다.  \nFilter가 연쇄적으로 구성된 FilterChain으로 HttpServletRequest가 처리됩니다.\nFilter가 할 수 있는 일은 두 가지입니다.\n\n- 다음으로 처리될 Filter나 Servlet 처리를 막습니다. 바로 응답으로 넘어갑니다.\n- 다음으로 처리될 Filter나 Servlet에 사용될 요청이나 응답을 수정합니다.\n\n### DelegatingFilterProxy\nDelegatingFilterProxy로 구현된 Filter는 스프링 ApplicationContext 상에서 서블릿 컨테이너 생명주기에 맞게 사용할 수 있습니다.  \n다시 말하면 서블릿 컨테이너는 아무 Filter나 사용 가능하지만, 스프링에 정의된 빈인 것을 신경쓰지 않습니다.\nDelegatingFilterProxy를 사용하면 서블릿 컨테이너에 필터를 직접 등록하는 대신 스프링 빈이 대신합니다.\n서블릿 컨테이너가 실행되기 이전에 필터들이 등록되어야 하는데 Proxy로 처리된 필터들이 등록됩니다.\n따라서 Context에 등록된 빈들을 불러오기 이전에 컨테이너에 필터를 등록하는 작업을 할 수 있습니다.\n\n### FilterChainProxy & SecurityFilterChain\nFilter를 구현해서 사용할 때 하나의 필터가 아닌 여러개를 FilterChainProxy로 등록이 가능합니다.\n이런 필터들을 SecurityFilterChain이라고 합니다.  \n하나의 필터를 여러개로 대체하는 이유는 상황이나 경로에 따라 여러 조건을 추가할 수 있습니다.  \napi를 처리할 때, view를 처리할 때등 경로에 따라 다른 필터를 적용시킬 수 있습니다.\n\n\n## Security Filters\nSecurity Filter들은 순서에 따라 진행됩니다. 따라서 순차적인 처리가 필요하다면 대표적인 필터의 처리 순서를 알고 있는 것이 좋습니다.\n- CorsFilter\n- CsrfFilter\n- LogOutFilter\n- OAuth2AuthorizationRequestRedirectFilter\n- BearerTokenAuthenticationFilter\n\n## Handling Security Exceptions\n`ExceptionTranslationFilter`에선 `AccessDeniedException`이나 `AuthenticationException`을 응답으로 바꿀 수 있습니다.\n필터에서 인증되지 않은 상태거나 `AuthenticationException` 이라면 다음 과정을 거칩니다.\n- SecurityContextHolder를 비웁니다.\n- HttpServletRequest에 담긴 `RequestCache`를 저장합니다.\n- AuthenticationEntryPoint를 통해 `WWW-Authenticate`헤더로 보내거나 로그인 페이지로 리다이렉트합니다.\n- `AccessDeniedException`인 경우 `AccessDeniedHandler`가 인증 거부를 처리합니다.\n"},{"metadata":{"layout":"post","title":"TIL 210203","date":"2022-02-03 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220203TIL"},"content":"\n## QueryDSL\n- QueryDSL 기본\n\n## 최소 스패닝 트리\n- Prim"},{"metadata":{"layout":"post","title":"TIL 210202","date":"2022-02-02 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220202TIL"},"content":"\n## JPA 기본 강의 학습\n- 객체지향 쿼리 언어 2\n\n## 데이터베이스 Date\n- TimeStamp vs DateTime\n\n## QueryDSL\n- QueryDSL 기본\n"},{"metadata":{"layout":"post","title":"JPA Date Auditing","date":"2022-02-01 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"JPA Audit"},"content":"\n## 데이터베이스 타입 정하기\n먼저 Auditing이 저장할 날짜의 데이터 타입을 정해야 합니다.  \nMySQL을 기준으로 정하겠습니다.  \nJPA DDL 생성을 이용하면 기본으로 DATETIME 으로 지정되고 설정으로 바꿀 수 있습니다.  \n\n### MySQL Date Type \n| Data Type | Value                 |\n|-----------|-----------------------|\n| DATE      | '0000-00-00'          |\n| TIME      | '00:00:00'            |\n| DATETIME  | '0000-00-00 00:00:00' |\n| TIMESTAMP | '0000-00-00 00:00:00' |\n| YEAR      | 0000                  |\n\nDATE, TIME, YEAR 은 각각 보듯이 시간, 날짜, 년도에 따라 구분되어 있습니다.  \nDATETIME 과 TIMESTAMP 는 형식이 같은데 어떤 차이점이 있을까요?  \n\n### DATETIME\n- '1000-01-01 00:00:00.000000' ~ '9999-12-31 23:59:59.999999' 까지의 범위를 가집니다.\n- 타임존에 상관 없이 그대로 저장됩니다.\n\n### TIMESTAMP\n- '1970-01-01 00:00:01.000000' ~ '2038-01-19 03:14:07.999999' 까지의 범위를 가집니다.  \n- 타임존 설정에 따라 바뀌어서 저장됩니다. \n\n### 차이점\n둘의 가장 큰 차이점은 설정한 타임존에 따라 시간이 설정된다는 점입니다. \n따라서 위치에 상관없이 시간을 그대로 저장하고 싶다면 DATETIME을, 아니라면 TIMESTAMP로 설정합니다.  \n\n## 자바 타입 정하기\n자바에서 지원하는 날짜 타입으로 Date, Timestamp, Instant, LocalDateTime, ZonedDateTime 등이 있습니다.\n자바 8 이상이라면 Date나 TimeStamp 대신 조건에 맞는 날짜 타입을 쓰는 것이 좋습니다.  \n위에서 DATETIME처럼 시간대 구분 없이 사용할 때는 `LocalDateTime`을 사용합니다.  \nTIMESTAMP 처럼 시간대 구분이 필요할 때는 `ZonedDateTime`을 사용합니다.  \n다른 시간대 말고 무조건 UTC 기준으로 사용할 때 `Instatnt`을 사용합니다.  \n\n## JPA Auditing 설정하기\nSpring 전체에서 audit 기능을 사용하려면 @EnableJpaAuditing 어노테이션을 추가해줍니다.  \n```\n@Configuration\n@EnableJpaAuditing\nclass Config {\n...\n```\n\n혹은 엔티티 별로 사용하고 싶다면 엔티티에 @EntityListeners 어노테이션을 추가해주면 됩니다.  \n```java\n@Entity\n@EntityListeners(AuditingEntityListener.class)\npublic class MyEntity {\n\n}\n```\n\n그리고 Auditing을 설정할 필드에 어노테이션을 추가해줍니다.  \n```java\nclass Customer {\n\n  @CreatedDate\n  private Instant createdDate;\n\n  ...\n  \n  @CreationTimeStamp\n  private ZonedDateTime createdAt;\n}\n\n```\nJPA 에서 제공하는 어노테이션 @CreatedDate 는 Instant, LocalDateTime, Date, DateTime 등에 사용 가능합니다. \n하지만 ZonedDateTime 의 경우 사용할 수 없습니다. \nZonedDateTime 을 사용하고 싶다면 hibernate에서 제공하는 어노테이션인 @CreationTimeStamp 을 사용하면 됩니다.  \n"},{"metadata":{"layout":"post","title":"TIL 210201","date":"2022-02-01 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220201TIL"},"content":"\n## JPA 기본 강의 학습\n- 프록시\n- 값 타입\n- 객체지향 쿼리 언어 1\n"},{"metadata":{"layout":"post","title":"TIL 210131","date":"2022-01-31 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220131TIL"},"content":"\n## JPA 기본 강의 학습\n- 연관관계 매핑\n\n## 최소 스패닝 트리\n- Kruskal\n\n"},{"metadata":{"layout":"post","title":"AWS 도메인 연결","date":"2022-01-30 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"AWS 도메인 연결"},"content":"\n## 도메인 구매하기\n원하는 도메인을 먼저 구매합니다.  \n[가비아](https://www.gabia.com) [까페24](https://hosting.cafe24.com/) 등에서 구매할 수 있습니다.  \nAWS 내에서도 도메인 구입이 가능합니다.  \n\n## Route53\nAWS 내의 인스턴스와 도메인을 연결하기 위해 Route53을 이용합니다.\n\n### 도메인 등록하기\n먼저 호스팅 영역 > 호스팅 영역 생성 에서 구입한 도메인 이름을 입력합니다.  \n입력을 마치면 NS, SOA 유형으로 두 개의 레코드가 생깁니다.\n\n## 호스팅하기\n앞에 blog, www 등 원하는 호스트명을 지정하려면 `레코드 세트 생성`으로 이름을 지정해줍니다.  \n여기서 원하는 주소에 해당하는 인스턴스를 지정할 수 있습니다.  \n\n### 도메인 연결하기\n외부 도메인의 경우 도메인 제공자는 도메인과 연결되어 있는 정보를 알지 못합니다.  \n이 정보를 받아오기 위해서 외부 도메인 네임 설정에서 네임 서버에 등록해줘야 합니다.  \nRoute53에서 처음 생성된 NS 값 4개를 복사해줍니다.  \n\n### 연결 확인하기  \n```shell\nnslookup 도메인이름\n```\n간단하게 명령어로 연결을 확인할 수 있습니다.  \n결과로 위에서 입력한 네임 서버가 나오면 연결된 것입니다.\n\n## HTTPS 연결하기\nEC2 인스턴스를 HTTPS와 연결하기 위해선 로드밸런서 설정과 ACM 설정이 필요합니다.  \n\n### AWS Certificate Manager\nAWS Certificate Manager > 인증서 요청 에서 요청합니다.  \n퍼블릭 인증서 요청으로 구매한 도메인 이름을 입력합니다.  \n인증 방법으로 DNS 검증을 선택합니다.  \n요청하면 상태가 `검증 대기중` 으로 됩니다.  \n생성한 인증서에 들어가서 Route 53에서 레코드 생성을 선택합니다.\n\n### 로드밸런서 설정하기\n먼저 만들기 이전에 로드밸런서가 지정할 `대상 그룹`을 설정해야 합니다.  \n\n### 대상 그룹\nEC2 > 로드 밸런싱 > 대상 그룹 > Create target group 으로 생성합니다.  \n`target group`은 인스턴스, IP 주소, 람다, 다른 로드 밸런서들을 지정할 수 있습니다.  \nEC2 인스턴스나 IP 주소를 연결하면 됩니다.  \n여기서 포트는 연결할 서버의 포트를 지정하면 됩니다.  \n서버를 3000번으로 켰다면 3000번, 8080이라면 8080번으로 지정해줍니다.  \n서버가 정상적으로 동작하나 확인하기 위해서 `health check`를 할 지점이 필요합니다.  \n`200`번으로 응답하는 경로를 지정해줍니다.  \n\n### 로드 밸런서\nEC2 > 로드밸런싱 > 로드밸런서 > 로드밸랜서 생성에서 `로드밸런서`를 생성합니다.   \n외부에서 HTTPS로 연결할 로드밸런서를 만들것이기 때문에 `Application Load Balancer`를 선택합니다.  \n이름을 지정해주고 Network mapping에서 최소 2개의 subnet을 지정해줘야 합니다.  \n사용중인 인스턴스 지역을 포함하는 subnet을 지정해주면 됩니다.  \nEC2 인스턴스의 가용 영역 부분에서 확인할 수 있습니다.  \n`Listeners and routing` 에서 포트를 HTTPS 로 설정하고 위에서 생성한 대상 그룹을 선택합니다.  \nSSL 인증서로 위에서 설정한 ACM을 지정합니다.  \n\n### Route 53 설정\nRoute 53에서 레코드 생성으로 레코드 유형 A으로 설정합니다.  \n값은 별칭을 누르고 대상으로 `Application/Classic Load Balancer`로 설정합니다.  \n지역으로 인스턴스가 위치한 지역을 선택합니다.  \n위에서 생성한 로드 밸런서를 선택하고 레코드를 생성합니다.  \n레코드를 생성하면 https 주소와 로드밸런서가 연결됩니다.  \n\n## HTTP를 HTTPS로 리다이렉트 하기\n위의 설정까지 마치면 HTTPS로는 연결이 되지만 HTTP 주소로는 연결이 되지 않습니다.  \nHTTP를 연결하려면 로드밸런서에서 리스너를 추가해야합니다.  \n위에서 생성한 로드밸런서에 리스너를 추가하고 HTTP 80 포트로 지정합니다.  \n`Default actions`에서 `redirect`로 선택합니다.  \n그리고 프로토콜을 HTTPS 443으로 지정합니다.  \n이제 HTTP 주소로 입력하면 HTTPS로 리다이렉트 되는 것을 확인할 수 있습니다.  \n\n"},{"metadata":{"layout":"post","title":"TIL 210130","date":"2022-01-30 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220130TIL"},"content":"\n## 도메인 설정\n- 도메인 구입\n- AWS 연결\n- 로드 밸런서 설정\n- HTTPS 설정\n\n## API 설계\n- OpenAPI \n- Swagger\n- Stoplight\n\n"},{"metadata":{"layout":"post","title":"TIL 210129","date":"2022-01-29 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220129TIL"},"content":"\n## Kotlin 코딩테스트 시작\n코틀린으로 알고리즘 문제 풀이\n- 자바 파일로 바꿔서 다시 확인하기\n\n## 논리성 찾기\n- 이메일의 최대 크기는?\n- 이름의 최대 길이는?\n"},{"metadata":{"layout":"post","title":"TIL 210128","date":"2022-01-28 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220128TIL"},"content":"\n## 프로젝트 기획부터 다시\n- 유즈케이스, 기획, ERD 작성\n- 피그마로 디자인 뽑기"},{"metadata":{"layout":"post","title":"Youtube Ad Block","date":"2022-01-27 00:01:00 +0900","category":"trouble","tags":["trouble"],"keywords":["trouble"],"id":"Youtube ad block"},"content":"\n## 문제 발생\n프로젝트에서 Youtube 영상을 embed 형식으로 불러와 사용하고 있습니다.  \n그런데 웹페이지를 불러올 때마다 네트워크에서 에러가 발생했습니다.  \n\n```\nwww-embed-player.js:668 \nGET https://googleads.g.doubleclick.net/pagead/id net::ERR_BLOCKED_BY_CLIENT\n\nwww-embed-player.js:1367 \nGET https://static.doubleclick.net/instream/ad_status.js net::ERR_BLOCKED_BY_CLIENT\n```\n두 부분에서 발생하고 있었고 에러를 살펴보았을때 광고와 구글 관련 문제였습니다.  \n발생한 위치가 embed-player이니 기본적으로 불러올 때 발생하는 문제였습니다.  \n\n## 원인\n이 에러가 발생하는 원인은 `ad blocker` 때문입니다.  \n저는 크롬 브라우저에 ad blocker 플러그인을 사용 중입니다.  \n그러다보니 광고와 기타 정보를 제 쪽에서 막고 있기 때문에 발생한 문제였습니다.\n\n## 해결\nad blocker를 중지 시키면 문제는 발생하지 않았습니다!\n"},{"metadata":{"layout":"post","title":"TIL 210127","date":"2022-01-27 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220127TIL"},"content":"\n## gapi 학습\ngapi client 사용법\n\n## 아이디 중복 확인\n아이디 중복 확인 방법 "},{"metadata":{"layout":"post","title":"TIL 210126","date":"2022-01-26 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220126TIL"},"content":"\n## react hook\n상태 관리 학습\n\n## Google OAuth2\n로그인 학습"},{"metadata":{"layout":"post","title":"TIL 210125","date":"2022-01-25 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220125TIL"},"content":"\n## Youtube Embed\nYoutube Embed 학습\n\n## BootStrap 설정\nBootStrap 옵션들 숙지\n\n## FontAwesome 사용법\nFontAwesome 사용법 숙지\n\n"},{"metadata":{"layout":"post","title":"TIL 210124","date":"2022-01-24 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220124TIL"},"content":"\n## NextJS 학습\n기본 설정\n\n"},{"metadata":{"layout":"post","title":"Github pages react","date":"2022-01-23 00:45:00 +0900","category":"blog","tags":["blog"],"keywords":["blog"],"id":"github pages react"},"content":"\n## Pages 설정으로 바꿔보기\n기본 React 예제 앱을 Github에 올리고 pages에 배포로 설정을 했습니다.  \n결과는 README 페이지만 나옵니다."},{"metadata":{"layout":"post","title":"Github pages 배포","date":"2022-01-23 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"github pages"},"content":"\n## 정적 페이지 배포하기\n동적으로 바뀌는 사이트가 아니라면 github pages를 통해 호스팅이 가능합니다.  \n\n## 설정하기\nSettings > Pages > Source  \n배포하길 원하는 브랜치를 설정해줍니다.  \n\n## 배포 확인하기\nEnvironments > github-pages  \n현재 배포중인 상태를 확인 가능합니다.  \nView deployment를 통해 웹사이트로 이동할 수 있습니다.  \n\n## 경로 문제\nhtml에서 css나 js를 불러오는 경우 경로를 지정해야합니다.  \n일반적인 경우 '/' 로 시작해도 도지만 github pages의 경우 다릅니다.  \n'/' 로 시작하면 '이름.github.io' 로 기본 경로가 지정됩니다.  \n따라서 다른 repository 에서 불러오면 파일을 불러올 수 없습니다.  \n제대로 사용하려면 './' 로 현재 위치에서 찾을 수 있게 상대 경로로 바꿔야 합니다.  \n\n## .nojekyll\njekyll을 사용하지 않는 경우 .nojekyll 파일을 추가해줘야합니다.  \n추가하지 않으면 생길 수 있는 일로 _가 앞에 붙은 경로를 무시합니다.  \n내부에서 _로 시작하는 경로를 불러와야 해도 인식하지 못할 수 있습니다."},{"metadata":{"layout":"post","title":"TIL 210123","date":"2022-01-23 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220123TIL"},"content":"\n## Spring Request, Response\n기본 파라미터, 설정 학습\n\n"},{"metadata":{"layout":"post","title":"TIL 210122","date":"2022-01-22 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220122TIL"},"content":"\n## Spring MVC \n- Spring MVC 기본 개념들\n\n## 프로그래머스 2단계 완료\n2단계 모든 문제 해결\n\n"},{"metadata":{"layout":"post","title":"TIL 210121","date":"2022-01-21 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220121TIL"},"content":"\n## HttpServlet\n- HttpServlet 기본 개념들\n\n\n"},{"metadata":{"layout":"post","title":"TIL 210120","date":"2022-01-20 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220120TIL"},"content":"\n## Servlet\n- Servlet 기본 개념들\n\n\n"},{"metadata":{"layout":"post","title":"[프로그래머스] 순위 검색","date":"2022-01-19 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"순위 검색"},"content":"\n```java\nimport java.util.*;\n\n// [순위 검색] https://programmers.co.kr/learn/courses/30/lessons/72412?language=java\npublic class Solution {\n\n    public int[] solution(String[] info, String[] query) {\n        Map<String, List<Integer>> map = new HashMap<>();\n        for (String i : info) {\n            String[] split = i.split(\" \");\n            int score = Integer.parseInt(split[4]);\n            for (String c : combination(split)) {\n                List<Integer> scores = map.getOrDefault(c, new ArrayList<>());\n                scores.add(score);\n                map.put(c, scores);\n            }\n        }\n\n        map.values().forEach(Collections::sort);\n\n        int[] answer = new int[query.length];\n        for (int j = 0; j < query.length; j++) {\n            String[] split = query[j].split(\" \");\n            int score = Integer.parseInt(split[7]);\n            String q = split[0] + split[2] + split[4] + split[6];\n            if (map.get(q) == null) continue;\n            answer[j] = binarySearch(map.get(q), score);\n        }\n        return answer;\n    }\n\n    private String[] combination(String[] split) {\n        String[] comb = new String[16];\n        Arrays.fill(comb, \"\");\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < (2 << i); j++) {\n                int size = 8 >> i;\n                for (int k = 0; k < size; k++) {\n                    comb[j * size + k] += j % 2 == 0 ? '-' : split[i];\n                }\n            }\n        }\n        return comb;\n    }\n\n    private int binarySearch(List<Integer> a, int score) {\n        int low = 0;\n        int high = a.size();\n        int mid;\n        while (low < high) {\n            mid = (low + high) / 2;\n            if (a.get(mid) >= score) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return a.size() - low;\n    }\n\n}\n```\n\n## 실수했던 점\n처음에 각 부문마다 나누어서 계산했더니 정확성은 통과했지만 효율성에서 실패했습니다.  \n몇 번을 최적화했지만 실패했습니다.  \n그래서 다음으로 시도해본게 모든 경우의 수를 구하고 시도했습니다.  \n하지만 점수를 넘는 사람을 찾을 때 선형탐색으로 구했더니 역시 시간초과였습니다.  \n그래서 이분탐색 라이브러리를 사용했는데 문제가 생겼습니다.  \n이분탐색 라이브러리는 중복되는 값이 있는 경우 최저 인덱스를 구해주지 않습니다.  \n중복 중에는 랜덤으로 인덱스를 구하게 됩니다.  \n여기서 문제를 찾느라 한참 걸렸습니다.  \n좀만 더 하면 풀거 같은 아쉬운 마음에 너무 시간을 많이 잡아먹은 문제였습니다.  "},{"metadata":{"layout":"post","title":"TIL 210119","date":"2022-01-19 00:01:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220119TIL"},"content":"\n## 스프링 부트와 JPA 활용 1 정리\n- Spring MVC 기본 개념들\n- JPA 기본 개념들\n\n\n"},{"metadata":{"layout":"post","title":"TIL 210118","date":"2022-01-18 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220118TIL"},"content":"\n## 이진탐색\n하한선 맞추기\n\n## 멘토링\n운영상의 동시성 문제 고려  \n로그 잘 찍고 에러 관리하기\n\n\n"},{"metadata":{"layout":"post","title":"RDS 외부 접속","date":"2022-01-18 00:01:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"RDS 외부 접속"},"content":"\n# RDS 외부 접속 방법\n\n## 퍼블릭 엑세스 허용\n연결 > 추가 연결 구성 > 퍼블릭 엑세스 가능 > 예\n\n## VPC 보안 그룹 인바운드 \n인바운드 규칙 > 인바운드 규칙 편집 > 추가"},{"metadata":{"layout":"post","title":"MVCC","date":"2022-01-17 00:50:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"MVCC"},"content":"\n# MVCC\nMulti Version Concurrency Control의 약자로 다중 버전 동시성 제어를 뜻합니다.  \n먼저 동시성 제어부터 이해해야 합니다.  \n\n## Concurrency Control\n트랜잭션을 사용하는 데이터베이스에서 동시에 여러 사람이 사용 중입이라고 가정합니다.  \n1. 사용자 A가 트랜잭션 내에서 Y 데이터를 수정했습니다.  \n2. 사용자 B가 A의 트랜잭션이 끝나기 전 Y 데이터를 읽습니다.\n3. 사용자 A가 트랜잭션에서 에러가 발생해 롤백을 실행합니다.\n\n이 상황에서 사용자 B는 잘못된 Y 데이터를 읽게 됩니다.  \n이런 상황을 방지하기 위해 한 명이 사용중일 때 막는 Lock을 이용합니다.  \nLock을 사용하면 안전한 데이터만 사용할 수 있지만 동시에 사용할 수 있는 기능이 떨어집니다.  \n따라서 안전성과 동시성을 위해서 어떻게 Lock을 걸지 결정하는 것이 동시성 제어입니다.  \n\n## Multi Version\n두 트랜잭션이 같은 데이터를 수정하려고 하면 Lock을 거는 걸 막기는 힘듭니다.  \n하지만 위의 상황처럼 한 쪽이 쓰고 있는 중에 읽을 때는 피해갈 수 있습니다.  \n위에서 사용자 B가 Y 데이터를 읽으려고 한다면 원하는 데이터는 트랜잭션이 실행되기 전 커밋값입니다.    \n트랜잭션 진행중일 때 달라진 변경값을 바로 적용하지 않고 임시로 따로 저장하면 어떨까요?  \n가장 일반적으로 사용하는 방법이 스냅샷을 이용해 변경 부분만 따로 관리하는 것입니다.  \n이렇게 되면 읽을 때는 예전 스냅샷을 읽어 트랜잭션이 실행되기 전 값을 읽습니다.  \n트랜잭션이 성공적으로 처리되면 커밋된 결과가 최신 스냅샷이 최종 스냅샷이 됩니다.  \n트랜잭션이 실패했다면 최신 스냅샷을 삭제하면 됩니다.  \n이렇게 되면 데이터베이스에는 동시에 여러 버전이 존재하게 됩니다.  \n이 방법으로 동시성을 제어하는 것을 **MVCC** 라고 합니다. \n"},{"metadata":{"layout":"post","title":"화면 크기에 따라 toc 변경하기","date":"2022-01-17 00:45:00 +0900","category":"blog","tags":["blog"],"keywords":["blog"],"id":"화면 크기에 따른 toc"},"content":"\n## 뷰에 따라 겹쳐 보이는 toc\n현재 블로그는 오른쪽에 목차가 나오고 있습니다.  \n문제는 화면 가로가 짧아지면 따로 처리하지 않아 본문가 겹처보이게 됩니다.  \n\n## 해결 방법\ncss의 @media 태그를 사용하면 됩니다.  \n```css\n@media screen and (min-width: 800px) {\n}\n```\n먼저 어느 매체에서 사용할 때를 구분할 수 있습니다.  \n어떤 매체든 상관없다면 all을 기본적으로 컴퓨터나 태블릿 스크린은 screen입니다.  \n연산자로는 and, not, .(or)을 사용할 수 있습니다.  \n조건으로 width, height, orientation등 특정 상황을 가정하고 지정할 수 있습니다.  \n\n따라서 가장 간단한 방법으로 최소 가로 길이가 일정 범위가 넘지 않으면 기본 toc로 지정합니다.  \n\n"},{"metadata":{"layout":"post","title":"MapStruct","date":"2022-01-17 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"mapstruct"},"content":"\n## MapStruct\n계층 간 데이터를 주고 받을 때 다른 객체로 변환해서 사용하는 일이 잦습니다.  \n이럴 때 모든 코드를 직접 만들어서 사용한다면 반복적이고 실수하기 쉽습니다.  \n이때 Object Mapping을 사용하면 간단하게 처리가 가능합니다.  \n그 중에서 MapStruct를 가장 많이 사용합니다.  \n\n## 사용법\n```java\n@Mapper \npublic interface CarMapper {\n \n    CarMapper INSTANCE = Mappers.getMapper( CarMapper.class ); \n \n    @Mapping(source = \"numberOfSeats\", target = \"seatCount\")\n    CarDto carToCarDto(Car car); \n}\n```\n@Mapper 어노테이션을 인터페이스에 지정합니다.  \n이렇게 명시된 인터페이스에 따라 빌드 시 Object Mapping을 하는 클래스를 생성해줍니다.  \n기본적으로 멤버 변수가 같은 이름으로 생성됩니다.  \n다르게 사용하려면 해당 source에 바꿀 이름을 target으로 선택 가능합니다.  \n\n### 함수 사용법\n변수 그대로가 아닌 변수가 가진 함수나 다른 함수로 매핑할 수 있습니다.    \n```java\n@Mapping(target = \"creationDate\", expression = \"java(new java.util.Date())\")\n```\n\n## Spring에서 주입 받기\nMapper는 인터페이스이기 때문에 사용할 때 방법은 두 가지가 있습니다.\n빌드되어 있는 구현체를 직접 생성해서 사용하거나 Spring에서 주입 받는 형태입니다.\nSpring에서 주입 받으려면 빈으로 등록해야합니다.\n어노테이션으로 생성 방식을 spring으로 지정하면 가능합니다.\n```java\n@Mapper(componentModel = \"spring\")\n```"},{"metadata":{"layout":"post","title":"TIL 210117","date":"2022-01-17 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220117TIL"},"content":"\n## HTTP 웹 기본 지식\nHTTP 웹 기본 지식 강의 완강\n\n## 스프링 부트와 JPA 활용 1 시작\n빠르게 프로젝트 완성하기\n\n\n"},{"metadata":{"layout":"post","title":"Exception Handling in Spring MVC","date":"2022-01-16 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Exception Handling"},"content":"\n# Spring MVC의 예외 처리\nSpring MVC에서 개발하다보면 예외 처리를 할 일이 많습니다.  \n처리하는 방법에 정답이 있는 건 아니지만 어떻게 하면 좋을지 좋은 글이 있어 요약해봤습니다.  \n\n## Spring Boot\nSpring Boot를 사용한다면 기본 오류 페이지를 넣어주지 않아도 white label을 볼 수 있습니다.  \n하지만 당연히 오류가 생겼을 때 이런 화면을 보고 싶지는 않기 때문에 처리가 필요합니다.  \n![](/assets/img/error-page.png)\n\n## Spring 예외처리 옵션\n먼저 Spring에서 예외처리를 할 수 있는 방법은 3가지가 있습니다.\n\n- Exception 별로 처리\n- Controller 별로 처리\n- Global 로 처리\n\n### Exception 별로 처리\n먼저 Excpetion 별로 어떤 에러 응답 코드를 반환할지 지정할 수 있습니다.\n```java\n @ResponseStatus(value=HttpStatus.NOT_FOUND, reason=\"No such Order\")  // 404\n public class OrderNotFoundException extends RuntimeException {\n     // ...\n }\n```\n이제 Controller에서 위의 Exception을 throw하면 404 코드로 응답합니다.  \n\n### Controller 별로 처리\n```java\n@Controller\npublic class ExceptionHandlingController {\n\n  // @RequestHandler methods\n  ...\n  \n  // Exception handling methods\n  \n  // Convert a predefined exception to an HTTP Status code\n  @ResponseStatus(value=HttpStatus.CONFLICT,\n                  reason=\"Data integrity violation\")  // 409\n  @ExceptionHandler(DataIntegrityViolationException.class)\n  public void conflict() {\n    // Nothing to do\n  }\n  \n  // Specify name of a specific view that will be used to display the error:\n  @ExceptionHandler({SQLException.class,DataAccessException.class})\n  public String databaseError() {\n    // Nothing to do.  Returns the logical view name of an error page, passed\n    // to the view-resolver(s) in usual way.\n    // Note that the exception is NOT available to this view (it is not added\n    // to the model) but see \"Extending ExceptionHandlerExceptionResolver\"\n    // below.\n    return \"databaseError\";\n  }\n\n  // Total control - setup a model and return the view name yourself. Or\n  // consider subclassing ExceptionHandlerExceptionResolver (see below).\n  @ExceptionHandler(Exception.class)\n  public ModelAndView handleError(HttpServletRequest req, Exception ex) {\n    logger.error(\"Request: \" + req.getRequestURL() + \" raised \" + ex);\n\n    ModelAndView mav = new ModelAndView();\n    mav.addObject(\"exception\", ex);\n    mav.addObject(\"url\", req.getRequestURL());\n    mav.setViewName(\"error\");\n    return mav;\n  }\n}\n```\nController에서 처리하는 경우 @ExceptionHandler로 처리가 가능합니다.  \n@ExceptionHandler는 Controller안에 메서드에만 사용이 가능합니다.  \n처리할 수 있는 방법은 여라가지가 있습니다.\n- @ResponseStatus로 예외 처리\n- 지정된 page 반환\n- 새로운 페이지에 error를 담아 반환\n가장 일반적으로는 에러를 로그로 남기고 에러 정보를 담아 반환합니다.\n\n### Global 로 처리\n**@ControllerAdvice**  \n컨트롤러 별로 처리릏 하면 동일한 예외 처리가 생기면 반복해서 작성하게 됩니다.  \n전역적으로 처리하려면 @ControllerAdvice를 이용합니다.  \n@ControllerAdvice는 @ExceptionHandler, @ModelAttribute, @initBinder를 지원합니다.  \n\n```java \n@ControllerAdvice\nclass GlobalControllerExceptionHandler {\n    @ResponseStatus(HttpStatus.CONFLICT)  // 409\n    @ExceptionHandler(DataIntegrityViolationException.class)\n    public void handleConflict() {\n        // Nothing to do\n    }\n}\n```\n\n## HandlerExceptionResolver\nDispatcherServlet에 선언된 스프링 빈들은 HandlerExceptionResolver를 구현합니다.  \n클래스 뜻대로 exception이 발생하면 처리되기 전에 되는 작업을 하는 클래스입니다.  \n세 가지 resolver를 순서대로 거치게 됩니다.  \n- ExceptionHandlerExceptionResolver  \n@ExceptionHandler와 controlleradvice에서 처리되지 않은 예외들이 거칩니다.  \n\n- ResponseStatusExceptionResolver  \n@ResponseStatus에서 처리되지 않은 예외들이 거칩니다.  \n\n- DefaultHandlerExceptionResolver  \n표준 Spring 예외들을 변환하고 HTTP 상태 코드로 변환합니다.  \n\n### SimpleMappingExceptionResolver\nSpring에서는 기본적으로 제공하는 처리들이 있습니다.  \n\n- 예외가 발생하는 클래스 이름 명시\n- 예외처리에 해당하는 에러 페이지 명시\n- 에러 로그 \n\n## REST 처리\n예외에 대한 응답 값을 뷰가 아닌 데이터로 반환하고 싶을 수 있습니다.  \n이때 사용할 수 있는 방법은 @ResponseBody를 이용할 수 있습니다.  \n```java\n@ResponseStatus(HttpStatus.BAD_REQUEST)\n@ExceptionHandler(MyBadDataException.class)\n@ResponseBody ErrorInfo\nhandleBadRequest(HttpServletRequest req, Exception ex) {\n    return new ErrorInfo(req.getRequestURL(), ex);\n} \n```\n전역적으로 처리하고 싶은 경우 @RestControllerAdvice를 사용합니다.  \n@RestControllerAdvice는 @ControllerAdvice에 @ResponseBody만 더해진 어노테이션입니다.  \n\n## ResponseEntityExceptionHandler\n전역적인 처리를 할 때 모든 예외처리를 다시 다 작성할 필요가 없습니다.  \nSpring에서 기본적으로 처리하는 예외들을 ResponseEntityExceptionHandler을 상속해 사용가능합니다.  \n\n### 출처\n[exception-handling-in-spring-mvc](https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc)"},{"metadata":{"layout":"post","title":"TIL 210116","date":"2022-01-16 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220116TIL"},"content":"\n## mapstruct 정리\nmapstruct 사용법 숙지\n\n\n\n"},{"metadata":{"layout":"post","title":"TIL 210115","date":"2022-01-15 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220115TIL"},"content":"\n## 테스트코드 작성\nMocking 방법\n\n## Global Exception Handler\n예외처리를 한 번에 하는법 \n\n"},{"metadata":{"layout":"post","title":"TIL 210114","date":"2022-01-14 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220114TIL"},"content":"\n## thymeleaf 문법 숙지\nthymeleaf 정리\n\n## Regex\n특수기호들 문법 숙지\n\n"},{"metadata":{"layout":"post","title":"Intellij Plugin","date":"2022-01-13 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Intellij Plugin"},"content":"\n## [GitToolBox](https://plugins.jetbrains.com/plugin/7499-gittoolbox) \nGit Blame 기능을 대신해줍니다.  \n코드 옆에 작성자와 작성 일자를 보여줍니다.  \n\n## [Rainbow Brackets](https://plugins.jetbrains.com/plugin/10080-rainbow-brackets)\n괄호마다 색상을 다르게 해서 구분을 쉽게 해줍니다.  \n\n## [Key Promoter X](https://plugins.jetbrains.com/plugin/9792-key-promoter-x)\n마우스로 실행하는 기능들에 해당하는 단축키를 알려줍니다.  "},{"metadata":{"layout":"post","title":"TIL 210113","date":"2022-01-13 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220113TIL"},"content":"\n## Unit Test\nMockito 사용법 숙지중\n\n## 사소한 것도 기록하기\n인텔리제이 플러그인 자주 쓰는 것들을 정리했다.\n"},{"metadata":{"title":"[프로그래머스] 멀쩡한 사각형","date":"2022-01-12 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"멀쩡한사각형"},"content":"\n```java \nclass Solution {\n    public long solution(int w, int h) {\n        long result = 0;\n        double gradient = (double) w / h;\n        for (long i = 1; i < h; i++) {\n            result += Math.floor(gradient * i);\n        }\n        return result * 2;\n    }\n}\n```\n\n## 실수했던 점\n자료형이 중요했던 문제였습니다.  \n계산할 때 double에서 long으로 바꾸어도 크기가 크다보니 문제가 있었습니다.  \n다 풀고나서 다른 사람들 풀이에는 gcd를 사용한 방법이 많았습니다.  \n하지만 실제로 문제를 접할 때 떠오르기 쉽지 않을 것 같습니다.  "},{"metadata":{"layout":"post","title":"[프로그래머스] 후보키 (JAVA)","date":"2022-01-11 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"후보키"},"content":"\n```java\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Arrays;\nclass Solution {\n    boolean[] visited;\n    Set<String> columns = new HashSet<>();\n    Set<Set<String>> candidates = new HashSet<>();\n\n    public int solution(String[][] relation) {\n        visited = new boolean[relation[0].length];\n        int answer = 0;\n        for (int size = 1; size <= relation[0].length; size++) {\n            answer += countCandidateKey(relation, 0, size);\n        }\n        return answer;\n    }\n\n    private int countCandidateKey(String[][] relation, int start, int size) {\n        if (size == columns.size()) {\n            if (relation.length != getTupleSize(relation)) return 0;\n            for (Set<String> candidate : candidates) {\n                if (columns.containsAll(candidate)) return 0;\n            }\n            candidates.add(new HashSet<>(columns));\n            return 1;\n        }\n\n        int candidateKey = 0;\n        for (int i = start; i < relation[0].length; i++) {\n            if (visited[i]) continue;\n            columns.add(String.valueOf(i));\n            visited[i] = true;\n            candidateKey += countCandidateKey(relation, i + 1, size);\n            columns.remove(String.valueOf(i));\n            visited[i] = false;\n        }\n        return candidateKey;\n    }\n\n    private int getTupleSize(String[][] relation) {\n        String[] row = new String[relation.length];\n        Arrays.fill(row, \"\");\n        for (String column : columns) {\n            for (int i = 0; i < relation.length; i++) {\n                row[i] += relation[i][Integer.parseInt(column)];\n            }\n        }\n        return new HashSet<>(Arrays.asList(row)).size();\n    }\n}\n```\n\n## 실수했던 점\n이전에 풀다가 포기했었던 문제였습니다.  \n여러 개의 칼럼을 어떻게 조합할지 감이 안왔는데 **DFS**를 이욯해 풀었습니다.  \n먼저 조합으로 모든 경우의 수를 만들고 최소성을 만족하는지 확인했습니다.  \n그런데 처음에는 키들을 문자열 하나로 합쳐서 비교했는데 여기서 문제가 있었습니다.  \n`[\"01\", \"001\"] [\"010\", \"01\"]` 은 유일성을 만족하지만 합치면 만족 못하는 걸로 판별됩니다.  \n따라서 문자열 말고 집합에 담아서 집합끼리 비교해야 했습니다.  \n이걸 가능하게 해주는 함수는 **containsAll** 입니다.  \n바꾸고서 문제는 통과하지만 비효율적이라고 느껴져 다른 사람들의 풀이를 찾아봤습니다.  \n인상적이었던 부분은 완전 탐색을 할 때 비트연산을 사용하는 것입니다.  \n**BitSet**을 사용할 수도 있고 단순 비트연산으로도 가능합니다.  \n"},{"metadata":{"layout":"post","title":"[프로그래머스] 프렌즈4블록 (JAVA)","date":"2022-01-11 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"프렌즈4블록"},"content":"\n```java\nclass Solution {\n    boolean[][] visited;\n    char[][] blocks;\n    int[] dy = {0, 1, 0, 1};\n    int[] dx = {0, 0, 1, 1};\n\n    public int solution(int m, int n, String[] board) {\n        blocks = new char[m][];\n        int answer = 0;\n        for (int i = 0; i < board.length; i++)\n            blocks[i] = board[i].toCharArray();\n\n        while (true) {\n            int count = 0;\n            visited = new boolean[m][n];\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (blocks[i][j] == Character.MIN_VALUE) continue;\n                    if (!isMatched(i, j)) continue;\n                    count += checkVisited(i, j);\n                }\n            }\n            if (count == 0) break;\n            removeBlocks(m, n);\n            arrangeBlocks(m, n);\n            answer += count;\n        }\n        return answer;\n    }\n\n    private void removeBlocks(int m, int n) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (visited[i][j])\n                    blocks[i][j] = Character.MIN_VALUE;\n            }\n        }\n    }\n\n    private void arrangeBlocks(int m, int n) {\n        for (int j = 0; j < n; j++) {\n            for (int i = m - 1; i >= 0; i--) {\n                if (blocks[i][j] != Character.MIN_VALUE) continue;\n                int next = i - 1;\n                while (next >= 0 && blocks[next][j] == Character.MIN_VALUE) {\n                    next--;\n                }\n                if (next < 0) break;\n                blocks[i][j] = blocks[next][j];\n                blocks[next][j] = Character.MIN_VALUE;\n            }\n        }\n    }\n\n    private boolean isMatched(int y, int x) {\n        for (int i = 1; i < 4; i++) {\n            int ny = dy[i] + y;\n            int nx = dx[i] + x;\n            if (ny >= blocks.length || nx >= blocks[0].length) return false;\n            if (blocks[ny][nx] != blocks[y][x]) return false;\n        }\n        return true;\n    }\n\n    private int checkVisited(int y, int x) {\n        int visitCount = 0;\n        for (int i = 0; i < 4; i++) {\n            int ny = dy[i] + y;\n            int nx = dx[i] + x;\n            if (!visited[ny][nx]) visitCount++;\n            visited[ny][nx] = true;\n        }\n        return visitCount;\n    }\n}\n```\n\n## 실수했던 점\ndfs로 재귀함수로 작성했을 때 시간초과가 발생했습니다.  \n이전에도 그랬지만 되도록 반복문으로 처리해야겠습니다.  \n중복되는 부분들을 더 최적화할 수 있을 것 같습니다.  "},{"metadata":{"layout":"post","title":"TIL 210112","date":"2022-01-11 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220112TIL"},"content":"\n## 프로젝트 진행 일지\n아직 회원 엔티티를 만드는데 커밋을 어디서 끊어야할지 모르겠다.  \n간단하게 하고 수정한 걸 커밋으로 올려야하나 싶기도 하다.  \n기본적으로 올라가는 기본 응답이나 에러를 참고하면서 만들고 있다.  \n이번주까지 로그인까지는 완성해야겠다.\n\n## 멀쩡한 사각형\nJava로 문제를 풀다보면 자료형에서 걸릴 때 참 아쉽다.\n"},{"metadata":{"layout":"post","title":"TIL 210111","date":"2022-01-11 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220111TIL"},"content":"\n## JPA 롬복\nEntity는 기본 생성자가 필요하다.\n\n## 후보키 문제\n이전에 못풀거라고 생각했던 문제를 풀었다.\n"},{"metadata":{"layout":"post","title":"[프로그래머스] 압축 (JAVA)","date":"2022-01-10 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"압축"},"content":"\n```java \nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nclass Solution {\n    public int[] solution(String msg) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < 26; i++) {\n            map.put(String.valueOf((char) ('A' + i)), i + 1);\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < msg.length(); i++) {\n            int index = i + 1;\n            while (index <= msg.length() && map.get(msg.substring(i, index)) != null) {\n                index++;\n            }\n            String existWord = msg.substring(i, index - 1);\n            list.add(map.get(existWord));\n            if (index < msg.length()) {\n                map.put(msg.substring(i, index), map.size() + 1);\n            }\n            if (existWord.length() > 1) i += existWord.length() - 1;\n        }\n\n        return list.stream().mapToInt(i -> i).toArray();\n    }\n}\n```\n\n## 실수했던 점\nchar 형 자료에서 덧셈을 하면 int형으로 캐스팅되는 것을 놓쳤습니다.  \n여기서 문제점을 찾는데 5분정도 낭비했습니다.  "},{"metadata":{"title":"[랜덤 플레이]","date":"2022-01-10 00:44:00 +0900","category":"project","tags":["project"],"keywords":["project"],"id":"[랜덤 플레이]"},"content":""},{"metadata":{"title":"[랜덤 플레이] 프론트 작업","date":"2022-01-10 00:44:00 +0900","category":"project","tags":["project"],"keywords":["project"],"id":"[랜덤 플레이] 프론트 작업"},"content":"\n\n# 랜덤 플레이\n음악을 랜덤으로 재생하는 사이트\n\n## 유저\n- 유저는 아이디와 비밀번호로 로그인합니다.  \n- 유저는 개인의 플레이리스트를 가질 수 있습니다.\n- 유저는 다른 사람의 플레이리스트에 답글을 달 수 있습니다.\n- 유저는 DJ가 되어 랜덤 사이트 진행곡을 신청할 수 있습니다.  \n\n## DJ\n사이트 전체에서 나오는 노래를 신청할 수 있습니다.  \n- 로그인한 유저만 가능합니다.  \n- 추천을 1 이상 받은 유저만 가능합니다.  \n\n## 플레이리스트\n유튜브 링크로 리스트를 추가할 수 있습니다.  \n- 로그인한 상태에서만 리스트를 추가할 수 있습니다.  \n\n## 현재 재생 곡\n사용자가 없는 경우 설정해둔 곡 중에서 랜덤으로 실행됩니다.\n\n"},{"metadata":{"title":"[랜덤 플레이] 프로젝트 기획","date":"2022-01-10 00:44:00 +0900","category":"project","tags":["project"],"keywords":["project"],"id":"[랜덤 플레이] 프로젝트 시작"},"content":"\n\n# 랜덤 플레이\n음악을 랜덤으로 재생하는 사이트\n\n## 유저\n- 유저는 아이디와 비밀번호로 로그인합니다.  \n- 유저는 개인의 플레이리스트를 가질 수 있습니다.\n- 유저는 다른 사람의 플레이리스트에 답글을 달 수 있습니다.\n- 유저는 DJ가 되어 랜덤 사이트 진행곡을 신청할 수 있습니다.  \n\n## DJ\n사이트 전체에서 나오는 노래를 신청할 수 있습니다.  \n- 로그인한 유저만 가능합니다.  \n- 추천을 1 이상 받은 유저만 가능합니다.  \n\n## 플레이리스트\n유튜브 링크로 리스트를 추가할 수 있습니다.  \n- 로그인한 상태에서만 리스트를 추가할 수 있습니다.  \n\n## 현재 재생 곡\n사용자가 없는 경우 설정해둔 곡 중에서 랜덤으로 실행됩니다.\n\n"},{"metadata":{"title":"[랜덤 플레이] 프로젝트 설정","date":"2022-01-10 00:44:00 +0900","category":"project","tags":["project"],"keywords":["project"],"id":"[랜덤 플레이] 프로젝트 설정"},"content":"\n\n# Development Environment\n- Java 11\n- SpringBoot 2.x\n- Intellij"},{"metadata":{"title":"[랜덤 플레이] 에러 모음","date":"2022-01-10 00:44:00 +0900","category":"project","tags":["project"],"keywords":["project"],"id":"[랜덤 플레이] 에러 모음"},"content":"\n\n- [Youtube Ad Blocker](posts/trouble/2022-01-27-Youtube ad block.md)\n\n- [invalid_token_response](posts/trouble/2022-02-09-invalid token.md)"},{"metadata":{"title":"[랜덤 플레이] 고민 모음","date":"2022-01-10 00:44:00 +0900","category":"project","tags":["project"],"keywords":["project"],"id":"[랜덤 플레이] 고민 모음"},"content":"\n## 인증 토큰\nOAuth2 토큰으로 나온 인증 정보를 최대한 이용해서 인증 과정을 간략하게 만드려했습니다.  \n그래서 JWT에 인증 정보를 모두 담아 전송해, DB와의 연결 없이 인증을 시도했습니다.\n하지만 여러 부분에서 문제가 생겼습니다.\n- 회원 탈퇴, 로그 아웃 시 JWT를 만료시킬 수 없습니다.\n\n\n## 홈화면 랜덤 재생 목록 구성\n"},{"metadata":{"layout":"post","title":"TIL 210110","date":"2022-01-10 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220110TIL"},"content":"\n## 랜덤 플레이 프로젝트 시작\n생각만 했었던 음악을 랜덤으로 틀어주는 사이트 시작\n까페 같은 분위기를 만들고 싶다."},{"metadata":{"layout":"post","title":"[프로그래머스] 방금그곡 (JAVA)","date":"2022-01-09 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"방금그곡"},"content":"\n```java \nimport java.util.List;\nimport java.util.ArrayList;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.concurrent.TimeUnit;\n\nclass Solution {\n    public String solution(String m, String[] musicinfos) throws ParseException {\n        /*\n        musicinfos 로 재생된 거 만들기\n        m과 비교해서 일치하는 것 찾기\n        일치하면 재생된 시간 제일 긴것\n        재생된 시간도 같으면 먼저 입력된 음악 제목\n        */\n        List<String> list = new ArrayList<>();\n        int max = 0;\n        SimpleDateFormat format = new SimpleDateFormat(\"HH:mm\");\n        m = translateNoSharp(m);\n        for (String musicinfo : musicinfos) {\n            String[] split = musicinfo.split(\",\");\n            long startDate = format.parse(split[0]).getTime();\n            long endDate = format.parse(split[1]).getTime();\n            int minute = (int) TimeUnit.MILLISECONDS.toMinutes(endDate - startDate);\n\n            String title = split[2];\n            String score = split[3];\n            score = translateNoSharp(score);\n            StringBuilder melody = new StringBuilder();\n            int length = minute;\n            while (length > 0) {\n                melody.append(score, 0, Math.min(length, score.length()));\n                length -= score.length();\n            }\n            int idx = melody.indexOf(m);\n            if (idx == -1) continue;\n            if (minute < max) continue;\n            if (minute > max) {\n                list.clear();\n                max = minute;\n            }\n            list.add(title);\n        }\n        String answer = \"(None)\";\n        if (list.size() > 0) answer = list.get(0);\n        return answer;\n    }\n\n    private String translateNoSharp(String score) {\n        score = score.replaceAll(\"C#\", \"c\");\n        score = score.replaceAll(\"D#\", \"d\");\n        score = score.replaceAll(\"F#\", \"f\");\n        score = score.replaceAll(\"G#\", \"g\");\n        score = score.replaceAll(\"A#\", \"a\");\n        return score;\n    }\n}\n```\n\n## 실수했던 점\n처음 시도는 #을 기준으로 예외처리를 할려고 했습니다.  \n하지만 로직에 문제가 있었는지 테스트케이스 3개정도가 통과하지 못했습니다.  \n결국 다른 방법을 찾아 #을 아예 치환하는 방법을 택했습니다.  \n처음 방법으로 성공하지 못한게 아쉬웠습니다.  \n문법적으로 잘 몰랐던 부분은 SimpleDateFormat입니다.  \n처음에 Date 클래스를 사용하려했는데 `시:분`만 따로 사용할 수가 없었습니다.  \n그래서 포맷으로 바꾸고 시간 차이를 분으로 바꿔야 됐습니다.  \n시간 차이는 밀리세컨드로 나오므로 분으로 바꾸려면 나누기 60 * 1000을 해주면 됩니다.  \n하지만 더 보기 쉬운 방법으로 TimeUnit의 Enum을 사용하면 ms에서 minute으로 변환할 수 있습니다.  \n\n"},{"metadata":{"layout":"post","title":"TIL 210109","date":"2022-01-09 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220109TIL"},"content":"\n## HTTP 강의\n인프런에서 HTTP 강의를 듣고 정리중이다.\n\n## 프로그래머스 LEVEL 2 풀이\n방금그곡 문제를 해결했다."},{"metadata":{"layout":"post","title":"[프로그래머스] 파일명 정렬 (JAVA)","date":"2022-01-08 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"파일명 정렬"},"content":"\n```java\nimport java.util.Map;\nimport java.util.LinkedHashMap;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public String[] solution(String[] files) {\n        /*\n        HEAD 대소문자 구분 X\n        앞에 0 무시 숫자 순\n        TAIL은 순서에 영향 X\n        */\n        Map<String, FileName> fileNames = new LinkedHashMap<>();\n        Pattern numberPattern = Pattern.compile(\"[0-9]+\");\n        for (String file : files) {\n            Matcher matcher = numberPattern.matcher(file);\n            matcher.find();\n            String head = file.substring(0, matcher.start()).toLowerCase();\n            int number = Integer.parseInt(matcher.group());\n            fileNames.put(file, new FileName(head, number));\n        }\n\n        Arrays.sort(files, (o1, o2) -> {\n            FileName fileName1 = fileNames.get(o1);\n            FileName fileName2 = fileNames.get(o2);\n\n            if (!fileName1.head.equals(fileName2.head))\n                return fileName1.head.compareTo(fileName2.head);\n\n            return fileName1.number - fileName2.number;\n        });\n\n        return files;\n    }\n\n    static class FileName {\n        String head;\n        int number;\n\n        public FileName(String head, int number) {\n            this.head = head;\n            this.number = number;\n        }\n    }\n\n}\n```\n\n## 몰랐던 점\nmap에서 입력한 순서를 유지할 때 **LinkedHashMap**을 사용합니다.\nJava에서 정규식을 사용할 때 **Pattern**과 **Matcher**를 사용해야 합니다.  \n**Pattern**은 정규식 패턴을 만들고 패턴과 일치하는지 확인할 수 있습니다.  \n일치된 패턴을 해석할 때 **Matcher**를 이용합니다.  \n**find**로 다음 패턴을 찾고 **group**으로 찾은 값을 반환 받을 수 있습니다.  \n"},{"metadata":{"layout":"post","title":"배민다움","date":"2022-01-08 00:45:00 +0900","category":"blog","tags":["blog"],"keywords":["blog"],"id":"배민다움"},"content":"\n## 배민다움\n기술적인 글을 찾아보다 배민 기술블로그는 종종 방문했습니다.  \n하지만 [배민다움](https://story.baemin.com/) 이라는 문화를 볼 수 있는 사이트를 발견했습니다.  \n당연히 배민다움을 보는 이유는 대부분 **\"배민이 어떻게 일하나?\"** 일 것입니다.  \n그래서인지 카테고리도 \"잘 먹고\", \"일 잘하고\", \"함께 잘 살자\" 입니다.    \n흔한 말들이지만 정말 배민을 대표하는 단어들입니다.  \n\n## 일하는 방식\n\n### 재택근무\n회사에서 정말 재택근무가 잘 이뤄질까 궁금했습니다.  \n그리고 그간 경험해온 걸 통해서 어떤 식으로 근무할지 가이드를 내릴지도요.  \n배민은 이런 [재택근무 가이드](https://woowahan.oopy.io/7c77ab61-aa66-4be4-b403-6f0f77ba472f) 를 공유하고 있습니다.   \n핵심적인 내용이지만 대부분은 배려가 돋보이는 가이드였습니다.  \n\n## 복지\n\n### 책\n요즘 많은 회사들이 도서비 무제한 지원을 복지로 삼습니다.  \n그렇지만 왜 도서 지원을 해주는지 궁금했습니다.  \n그 중 인상 깊었던 말은 **\"읽을 책을 사는 것이 아니라 산 책 중에서 읽는 것이다.\"** 였습니다.  \n사더라도 안 보는 책도 많은데 사지 않는다면 더 볼 기회가 줄어들게 됩니다.  \n도서를 공용으로 빌려야하는 곳에서 대여하는데 오래 걸려 포기했던 책들이 떠올랐습니다.\n\n### 복지 포인트\n200만원이 주어진다면 뭘 할지 배민 구성원들의 지출 내역서를 공유했습니다.  \n정말 아무 조건 없이 200만원이라는 혜택이 부러워지네요.\n\n## 아쉬웠던 점\n처음에는 글 위주였지만 갈수록 영상이나 링크로 대체되어서 아쉬웠습니다.  \n직접 찾아간 사이트이니 만큼 갔을 때 더 자세한 내용이 있었으면 좋을 것 같네요."},{"metadata":{"layout":"post","title":"REST","date":"2022-01-08 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"REST"},"content":"\n## REST  \n`Representational State Transfer`의 약자입니다.  \n**REST**는 네트워크에서 전송을 위한 아키텍처입니다.   \n이름에서 보듯이 표현할 수 있는 상태를 주고 받을 수 있어야 합니다.  \n데이터를 주고 받을 수 있는 방법은 많은데 왜 REST를 준수할까요?\n\n## REST 탄생\nREST가 왜 필요한지 알려면 왜 만들어졌는지를 먼저 알아야 합니다.  \nHTTP를 설계한 로이 필딩이 HTTP의 하위호환성을 안 깨트리면서 발전시키기 위해 만들었습니다.  \n즉 중요한 점은 하위 호환성이었습니다.  \n앞으로 서버에서 업데이트가 있더라도 클라이언트는 그대로 사용할 수 있어야 했습니다.  \n그러기 위해서 지켜야하는 규칙들이 아키텍처입니다.\n\n## REST 규칙\n**인터페이스 일관성**  \n\n일관적인 인터페이스로 분리되어야 합니다\n\n**무상태(Stateless)**\n\n각 요청 간 클라이언트의 콘텍스트가 서버에 저장되어서는 안 됩니다.\n\n**캐시 처리 가능(Cacheable)**\n\nWWW에서와 같이 클라이언트는 응답을 캐싱할 수 있어야 합니다. \n\n**계층화(Layered System)**\n\n프록시 서버처럼 중간에 거치는 서버가 더 있더라도 사용할 수 있어야합니다.  \n\n**Code on demand (optional)**\n\njavascript처럼 실행할 수 있는 로직을 코드로 전달할 수 있어야합니다.  \n\n**클라이언트/서버 구조**\n\n클라이언트와 서버가 독립적으로 업데이트할 수 있어야 합니다.  \n\n## 가이드\n### 자원의 식별\n요청 내에 기술된 개별 자원을 식별할 수 있어야 합니다.   \n웹 기반의 REST 시스템에서의 URI의 사용을 예로 들 수 있습니다.    \n데이터를 주고 받을 때도 우리는 정해진 형식으로 데이터를 주고 받습니다.  \nHTML, JSON 처럼 지정된 형식으로 데이터를 주고 받아야 합니다.  \n\n### 메시지를 통한 리소스의 조작\nGET, POST 같은 메소드와 리소스만으로 서버의 리소스를 조작할 수 있어야 합니다.    \n\n### 자기서술적 메시지\n각 메시지는 자신을 어떻게 처리해야 하는지에 대한 충분한 정보를 포함해야 합니다.  \n미디어 타입만 가지고도, 클라이언트는 어떻게 그 내용을 처리해야할 지 알 수 있어야 합니다.   \n메시지를 이해하기 위해 그 내용까지 살펴봐야 한다면, 그 메시지는 자기서술적이 아닙니다.   \n따라서 json, xml등 형식만 제공하는 것 외에도 어떻게 해석할지 정보가 필요합니다.  \n\n\n### HATEOAS\n`Hypermedia as the Engine of Application State`의 약자입니다.  \n만약에 클라이언트가 관련된 리소스에 접근하기를 원한다면, 하이퍼미디어로써 정보를 지원해야합니다.  \n리소스에 대한 값 이외에도 리소스가 있는 위치 혹은 링크를 포함해 만족할 수 있습니다.  \n\n## REST을 만족했을 떄 장점\n아키텍처들은 대부분 어떤 제약을 통해서 변화에 유연한 구조를 만들려고 합니다.  \nREST도 위의 제약들을 지키면 서버와 클라이언트가 독립적으로 변할 수 있습니다.  \n\n"},{"metadata":{"layout":"post","title":"TIL 210108","date":"2022-01-08 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220108TIL"},"content":"\n## REST 복습\n매번 봐도 헷갈리지만 REST에 대해 다시 알아봤다.\n\n## Java 정규식\n정규식 문제를 풀며 Pattern과 Match에 대해 학습했다."},{"metadata":{"layout":"post","title":"테스트 더블","date":"2022-01-07 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"테스트 더블"},"content":"\n## 테스트 더블\n테스트 더블이라는 단어는 xUnit의 저자 [Gerard Meszaros](http://xunitpatterns.com/gerardmeszaros.html) 가 만든 단어입니다.  \n영화계에서 영화배우 대신 대역을 스턴트 더블이라고 하는데서 유래했습니다.  \n유래처럼 테스트 더블은 실제 객체 대신 테스트를 대신해주는 객체를 의미합니다.\n\n### 테스트 더블이 필요할 때\n- 실제 객체를 사용하면 실제 서비스 환경에도 영향이 갈 때\n- 출력값이 잘 나오는지 확인할 수 없는 환경일 때\n- 외부 라이브러리를 쓰고 있고 잘못된 입력값의 예외처리를 잘하는지 확인하고 싶을 때\n- 테스트가 너무 느려서 빠르게 만들고 싶을 때\n\n## 테스트 더블 종류\n- Dummy object\n- Test stub\n- Test spy\n- Mock object\n- Fake object\n\n### 1. Dummy\n실제 동작이 필요 없는 객체를 의미합니다. null 값으로 만들어도 상관없습니다.  \n테스트할려는 메서드에서 테스트할려는 기능은 아니지만 인자값을 넣어줘야할 때 쓰입니다.  \n즉 어떤 면에선 테스트 더블이라고 보기 힘든 객체입니다.  \n우리가 테스트하려는 객체를 대신하는 객체가 아니라 그 외의 객체를 대신합니다.  \n\n### 2. Test stub\n테스트하려는 객체를 대신해 원하는 입력값을 반환하는 객체입니다.  \n즉 실제 구현과는 상관없이 원하는 값만을 반환합니다.  \n예를 들어 시간을 반환하는 상황에서 잘못 나오면 예외처리를 하는 상황을 테스트합니다.  \n문제는 우리가 만든 객체는 표준 라이브러리를 이용해 시간을 받아옵니다.  \n이 상황에서 잘못된 시간값을 받아오는 처리하는 것은 어렵습니다.  \n이럴 때 stub은 우리가 만든 객체를 대신해 잘못된 값을 넣어줘 예외처리를 테스트하게 합니다.  \n이처럼 실제 상황에서 원하는 입력값을 만들기 힘들 때 사용할 수 있습니다.  \n\n### 3. Test spy\nTest stub에서 출력값을 확인할 수 있는 방법을 추가한 객체입니다.  \n콘솔에 출력하거나 로그로 찍으면 잘 출력됐는지 테스트하기 힘듭니다.  \n이런 출력을 검증은 못해도 약간의 기록을 남겨서 확인합니다.  \n\n### 4. Mock object\nTest stub에서 출력값을 확인할 수 있고 검증까지 가능해야 합니다.  \nTest spy에서는 기록을 남기기는 했지만 검증을 하고 넘어갈 필요는 없습니다.  \n하지만 Mock object는 출력이 잘됐는지 검증이 가능해야 합니다.  \n\n### 5. Fake Object\nTest stub처럼 원하는 입력값을 반환하는 객체입니다.  \n하지만 실제 구현과 상관 없는게 아닌 실제와 비슷하지만 더 단순하게 작성합니다.  \n예를 들면 데이터베이스 연결과 같은 외부 연결만 대신하는 식으로 작성합니다.  \n테스트가 느린 경우, 외부 환경이 준비 안된 경우 대신 사용할 수 있습니다.  \n\n---\n책을 보다 보면 테스트 더블이라는 말을 많이 보게 됐습니다.  \n테스트를 위한 객체라는 것은 감이 왔지만 제대로 된 뜻을 모르고 있었습니다.  \n그래서 [xUnit](http://xunitpatterns.com/Test%20Double.html) 을 기준으로 정리해봤습니다.  \n하지만 다른 단어들도 그렇듯 같은 말이지만 다르게 쓰이는 경우가 많은 것 같습니다.  \n그런 부분은 추후에 추가하겠습니다.  \n"},{"metadata":{"layout":"post","title":"Jeykll 목차 추가하기","date":"2022-01-07 00:45:00 +0900","category":"blog","tags":["blog"],"keywords":["blog"],"id":"toc"},"content":"\n**TOC (Table of Contents)**  \n\n목차를 영어로 TOC라고 부릅니다.  \n\n## gem 설치로 추가하기\n\n### plugin 추가하기\nGemfile에 아래 명령어를 추가해줍니다.\n```ruby\ngem 'jekyll-toc'\n```\n\n### _config.yml 추가하기\n플러그인 목록에 `jekyll-toc`를 추가해줍니다.  \n```yml\nplugins:\n  - jekyll-toc\n```\n\n### toc 설정 추가하기\n목차를 추가할 post 설정에 `toc: true`를 추가합니다.  \n```\n---\nlayout: post\ntoc: true\n---\n```\n\n### 사용하기\n사용할 layout html에 toc를 추가해야합니다.\n\n전체에 다 적용될려면 default.html 에`{{ content | toc }}` 를 추가합니다.\n```html\n{{ content | toc }}\n```\ncontent와 연결된 형태가 아닌 따로 사용하는 경우 변수로 사용합니다.  \n```html\n```\n\n## gem 설치 없이하기\n\n### toc html 받아오기\n[jekyll toc](https://github.com/allejo/jekyll-toc/releases/tag/v1.2.0) 에서 toc.html을 다운받습니다.  \ntoc.html파일을 _includes 폴더에 넣어줍니다.  \n\n### 사용하기\n사용할 html에 다음 태그를 추가해줍니다.  \n```html\n{% include toc.html html=content %}\n```\n\n## toc를 옆에 추가하기\ntoc를 옆에 추가하려면 `<aside>`에 넣어주면 됩니다.  \n\n```html\n<aside>\n    {% include toc.html html=content %}   \n</aside>\n```\n\n"},{"metadata":{"layout":"post","title":"favicon 추가하기","date":"2022-01-07 00:45:00 +0900","category":"blog","tags":["blog"],"keywords":["blog"],"id":"favicon 추가하기"},"content":"## favicon 생성하기\n[favicon generator](https://www.favicon-generator.org/) 에서 원하는 이미지로 favicon.ico 파일을 생성해줍니다.  \n\n## html에 favicon 추가하기\n\\<head\\> 태그 사이에 아래와 같이 추가하면 됩니다.  \n```html\n<link rel=\"shortcut icon\" href=\"favicon 경로/favicon.ico\">\n```\n\n### Jekyll favicon 추가하기\n보통 assets 폴더에 이미지 같은 리소스를 보관합니다.  \nfavicon 파일을 assets 폴더에 넣었다면 경로는 /assets 가 됩니다.  \n"},{"metadata":{"layout":"post","title":"TIL 210107","date":"2022-01-07 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220107TIL"},"content":"\n## TOC 추가\n블로그에 TOC를 오른쪽 사이드에 추가했다.\n\n## 테스트 더블\n테스트 더블에 대해 좀 더 자세하게 알아봣다.\n\n"},{"metadata":{"layout":"post","title":"[프로그래머스] 스킬트리 (JAVA)","date":"2022-01-06 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"스킬트리"},"content":"\n```java\nclass Solution {\n    public int solution(String skill, String[] skill_trees) {\n        int answer = 0;\n        for(String skill_tree : skill_trees){\n            char[] s = skill_tree.toCharArray();\n            boolean[] learned = new boolean[skill.length()];\n            boolean possible = true;\n            for(char c : s){\n                int order = skill.indexOf(c);\n                if(order == 0) learned[0] = true;\n                if(order <= 0) continue;\n                if(!learned[order-1]){\n                    possible = false;\n                    break;\n                }\n                learned[order] = true;\n            }\n            if(possible) answer++;\n        }\n        return answer;\n    }\n}\n```\n\n## 생각해볼 점\n난이도 2 중에서 쉬웠던 문제였습니다.  \n"},{"metadata":{"layout":"post","title":"[프로그래머스] 방문 길이 (JAVA)","date":"2022-01-06 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"방문길이"},"content":"\n```java\nclass Solution {\n    \n    private static final int MAX_X = 10, MAX_Y = 10, MIN_X = 0, MIN_Y = 0;\n    \n    public int solution(String dirs) {\n        boolean[][][] visited = new boolean[10][10][2];\n        int answer = 0, y = 5, x = 5;\n        for(String dir : dirs.split(\"\")){\n            DIRECTION d = DIRECTION.valueOf(dir);\n            int vertical = d.vertical;\n            int ny = y + d.y;\n            int nx = x + d.x;\n            if(nx > MAX_X || nx < MIN_X || ny > MAX_Y || ny < MIN_Y) continue;\n            int pointY = Math.max(y, ny);\n            int pointX = Math.max(x, nx);\n            y = ny; \n            x = nx;\n            if(visited[pointY][pointX][vertical]) continue;\n            visited[pointY][pointX][vertical] = true;\n            answer++;\n        }\n        return answer;\n    }\n    \n    enum DIRECTION {\n        U(1, 0, 0), D(-1, 0, 0), R(0, 1, 1), L(0, -1, 1);\n        final int y, x, vertical;\n        DIRECTION(int y, int x, int vertical){\n            this.y = y;\n            this.x = x;\n            this.vertical = vertical;\n        }\n    }\n}\n```\n\n## 실수했던 점\n처음에 방문한 위치를 선 기준이 아니라 점 기준으로 잡아서 틀렸습니다.  \n선 기준으로 잡기 위해서 선의 두 점 중에서 더 큰 점을 기준으로 체크했습니다.  \n그 다음으로 개선한 방법은 반복문을 인덱스로 처리하고 있었습니다.  \n하지만 split을 이용하면 문자열 배열을 이용할 수 있다는 것을 찾아 수정했습니다.  "},{"metadata":{"layout":"post","title":"OSI 7계층","date":"2022-01-06 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"OSI"},"content":"\n![OSI 7계층](/assets/img/osi.jfif)\n\n## 네트워크 계층\n\n## 1계층 물리계층\n말 그대로 물리적인 데이터 전송을 담당하는 계층입니다.  \n전송 단위는 비트, 심볼입니다.  \n디지털 신호를 아날로그 신호로, 그리고 그 반대로 변환하는 역할을 합니다.  \n아날로그 신호를 받으면 디지털 신호로 변환해서 데이터링크 계층으로 넘깁니다.  \n허브, 케이블 등이 여기에 속합니다. \n\n## 2계층 데이터링크 계층\n노드와 노드 사이를 연결하는 계층입니다.  \n전송 단위는 **프레임**입니다.  \nMAC 주소를 이용해 다른 네트워크에 데이터를 전송합니다.\n여기서 필요한 기능들입니다.  \n- MAC 주소 추가\n- 오류 제어\n- 흐름 제어\n\n오류 제어는 잘못 온 데이터 체크, 흐름 제어는 데이터 전송속도 제어입니다.  \n스위치, 브릿지 등이 여기에 속합니다.  \n\n### 프레임\n1계층에서는 0과 1로 구성된 비트를 사용했습니다.  \n프레임은 비트의 집합입니다.  \n비트를 주소, 데이터, 플래그등 의미 있는 단위로 나눠서 전송합니다.  \n\n### 노드\n노드는 통신 엔드포인트를 뜻합니다.  \n하나의 네트워크 상에 있는 컴퓨터, 허브, 공유기등을 합쳐서 하나의 노드라고 합니다.\n\n## 3계층 네트워크 계층\n하나의 호스트에서 다른 네트워크로 통신을 담당합니다.  \n경로를 정하고 패킷을 전달해주는 역할을 맡습니다.  \n전송 단위는 패킷입니다.\n네트워크 통신시 연결되어 있는 경로가 많으므로 어느 경로로 갈지 결정해야 합니다.  \n전송할 빠른 길을 결정하는 라우팅, 흐름 제어등을 담당합니다.  \n\n## 4계층 전송 계층\n응용 계층과 네트워크 계층을 연결합니다.  \n이전 계층까지는 네트워크 단에서의 조작이었다면 여기부터는 호스트 안에서 동작합니다.  \n호스트에서 어떤 앱에게 데이터를 전송할지 포트를 통해 판단합니다.  \n전송 단위는 세그먼트입니다.  \nTCP와 UDP 프로토콜이 여기에 해당합니다.  \n\n## 5계층 세션 계층\n연결, 인증, 보안등을 담당하는 계층입니다.  \n전송 단위는 데이터입니다.\n\n## 6계층 표현 계층\n데이터들을 응용 계층에서 조작할 수 있는 단위로 변환합니다.  \nASCII를 EBCDIC 로 변환한다거나, 암호화, 압축등을 담당합니다.  \n\n## 7계층 응용 계층\nHTTP, FTP, SMTP 등 사용자들이 사용하는 프로토콜등이 해당합니다.  \n\n---\n\n실제로 사용하는 계층은 아니지만 매번 까먹어서 다시 정리해봤습니다.  \n"},{"metadata":{"layout":"post","title":"CORS","date":"2022-01-06 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"CORS"},"content":"\n# Cross-Origin Resource Sharing\n팀 프로젝트를 하다가 자주 마주친 문제였습니다.  \n당시에는 깊게 파볼 생각을 못하고 단순히 해결책만 찾아서 적용했습니다.  \n하지만 웹 개발자로써 문제에 대해 다시 생각해보기로 했습니다.  \n\n## 왜 CORS를 막았을까? \nCORS를 막은 이유는 '보안' 때문입니다.  \n웹에서 보안적으로 위험한 경우로 **CSRF**와 **XSS**가 있습니다.  \nCSRF는 간단하게 웹에서 이미지 링크 같은 걸 누르면 사용자의 정보로 악용 요청을 보내는 겁니다.\nXSS는 주로 입력 값을 악용해 사용자 정보를 다른 서버에 전송합니다.  \n둘다 공통점이 있다면 원하지 않는 요청을 보낸다는 것에 있습니다.  \n웹 개발자가 보안에 신경 쓴다면 이런 경우를 막을 수 있겠지만 근본적으로 막을 필요가 있습니다.  \nCORS는 이런 악용을 막기 위해 기본적으로 다른 도메인으로의 요청을 막습니다.  \n\n## 그래도 필요하다면?\n웹을 개발하다보면 다른 서버에 요청할 일이 많습니다.  \nAPI를 호출할 수도 있고, 이미지나 리소스등을 불러올 일들이 있습니다.  \n이럴 때 CORS를 안전하게 사용하기 위해서는 서버에서 설정이 필요합니다.  \nAccess-Control-Allow-Origin에 가능한 요청들을 명시하면 됩니다.  \n허용한 도메인이 아니라면 응답이 실패하게 됩니다.  \n허용할 때 도메인 뿐만 아니라 허용할 메서드도 지정할 수 있습니다.  \n서버에서 허용하는 목록이 있기 때문에 다른 오리진에 요청할 때는 서버를 먼저 거치게 됩니다.  \n브라우저는 preflight 요청을 먼저 보내 서버에서 허용하는 목록에 있는지 확인합니다.  \n허용한다는 응답을 받게 되면 그 다음으로 실제 요청이 가게 됩니다.  \n그래서 외부로 요청하는 걸 브라우저로 확인해보면 요청이 2번 가는 것을 확인할 수 있습니다.  \n그 중 먼저 요청이 간 부분은 preflight로 명시되어 있는 것을 확인할 수 있습니다.  \n그리고 두번째 요청에 헤더에는 보낸 웹사이트의 주소가 Origin 필드에 들어가게 됩니다.  \n\n"},{"metadata":{"layout":"post","title":"TIL 210106","date":"2022-01-06 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220106TIL"},"content":"\n## Github profile 꾸미기\n어려울줄 알았는데 생각보다 쉽다?\n\n## OSI 7계층\n파도 파도 모르는게 계속 나온다.\n\n## Blog css 가운데로 옮기기\n바꾸긴 했지만 아직 볼게 많다..."},{"metadata":{"layout":"post","title":"[프로그래머스] 가장 먼 노드 (JAVA)","date":"2022-01-05 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"가장 먼 노드"},"content":"\n```java\nimport java.util.*;\nclass Solution {\n    \n    boolean[] visited;\n    int[] distances;\n    \n    public int solution(int n, int[][] edge) {\n        int answer = 0;\n        List<List<Integer>> graph = new ArrayList<>();\n        visited = new boolean[n+1];\n        distances = new int[n+1];\n        Arrays.fill(distances, 20001);\n        distances[1] = 0;\n        visited[1] = true;\n        \n        for(int i = 0; i <= n; i++){\n            graph.add(new ArrayList<>());\n        }\n        for(int[] e : edge){\n            graph.get(e[0]).add(e[1]);\n            graph.get(e[1]).add(e[0]);\n        }\n        \n        PriorityQueue<Node> queue = new PriorityQueue<>();\n        queue.add(new Node(1, 0));\n        int max = 0;\n        \n        while(!queue.isEmpty()){\n            Node now = queue.poll();\n            int dist = now.dist;\n            int to = now.to;\n            distances[to] = Math.min(distances[to], dist + 1);\n            if(distances[to] > max){\n                max = distances[to];\n                answer = 1;\n            } else if(distances[to] == max){\n                answer++;\n            }\n            for(int i : graph.get(to)){\n                if(visited[i]) continue;\n                visited[i] = true;\n                queue.add(new Node(i, dist + 1));\n            } \n        }\n \n        return answer;\n    }\n    \n    static class Node implements Comparable<Node>{\n        int to;\n        int dist;\n        public Node(int to, int dist){\n            this.to = to;\n            this.dist = dist;\n        }\n        @Override\n        public int compareTo(Node n){\n            return this.dist - n.dist;\n        }\n    }\n}\n```\n\n### 실수했던 점\n처음 풀었을 때 플로이드 방식을 풀었더니 메모리 초과 + 시간초과가 나왔습니다.  \n그래서 그래프 자료구조를 연결 리스트로 바꾸고 bfs 방식으로 탐색했습니다.  "},{"metadata":{"layout":"post","title":"Stop the world","date":"2022-01-05 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"STW"},"content":"\n## Garbage Collector\nJava는 메모리를 직접 해제하지 않고 Garbage Collector가 처리합니다.  \n프로그램이 실행 되는 동안 객체를 생성하기만 한다면 메모리가 가득차게 됩니다.  \n이때 실제로 사용하지 않는 데이터들을 GC가 메모리를 해제합니다.  \n사용하지 않는 데이터의 기준은 참조되지 않고 있는 객체들입니다.  \n어떻게 참조되지 않는 값들이 생길 수 있을까요?\n\n### 메모리 영역\n먼저 우리가 직접 접근 하는 변수들은 Stack 영역에 위치합니다.  \n그리고 그 변수들은 객체에 대한 참조값을 나타냅니다.  \n실제로 객체에 대한 정보는 Heap 영역에 생성되고 Stack에서 이 값을 참조합니다.  \n즉 참조값으로 다른 Heap 영역을 가리키게 되면 Heap 영역에 생성된 메모리는 접근할 수 없습니다.  \n이렇게 사용자가 접근할 수 없지만 Heap 영역에 차지하는 부분을 GC가 처리합니다.  \nGC에서 메모리를 해제하고 나면 그만큼 메모리를 더 사용할 수 있게 됩니다.\n\n## Stop the world\n자동으로 메모리를 처리해주므로 편해보이지만 문제는 \"Stop the world\"가 발생합니다.  \n영어 그대로 GC를 처리하는 동안 프로그램이 정지하게 됩니다.  \nGC를 처리하는 쓰레드를 제외한 모든 쓰레드가 정지하게 됩니다.  \n예를 들어 서버라고 하면 이렇게 멈춘 시간에 요청이 들어오면 처리하지 못하게 됩니다.  \n그래서 이런 GC 처리 시간을 줄이는 것이 중요합니다.  \n\n### 왜 GC 처리 중엔 멈추게 되는 걸까?\n알고리즘마다 다르지만 GC가 처리되는 과정은 크게 2단계입니다.  \n먼저 참조되지 않는 객체들을 찾습니다.  \n그리고 참조되지 않는 메모리들을 해제합니다.  \nGC중에 멈추는 이유는 메모리를 해제할 때 객체들의 위치도 변경합니다.  \n단순히 참조되지 않는 메모리들을 해제만 한다면 다른 쓰레드를 멈출 필요가 없습니다.  \n하지만 메모리를 해제만 하면 사용할 수 있는 메모리가 파편처럼 분포됩니다.  \n이런 부분에 객체를 만들다보면 또 금방 파편 부분에 생성하지 못해 GC가 필요합니다.  \n따라서 사용할 수 있는 객체가 차지하는 메모리와 여유 메모리 부분을 정리하는 작업을 합니다.  \n이 과정에서 메모리 위치를 옮기고 객체에서 참조하는 위치를 변경합니다.  \n만약 GC 중에 다른 쓰레드에서 메모리 위치를 옮기는 중에 객체를 사용하면 에러가 발생하게 됩니다.  \n잘못된 위치를 참조하는 Dangling Pointer로 어떤 에러가 발생할지 모릅니다.  \n이런 점을 방지하기 위해 다른 쓰레드를 모두 멈추고 GC 쓰레드만 동작합니다.  \n\n\n\n"},{"metadata":{"layout":"post","title":"Clean Architecture","date":"2022-01-05 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Clean Architecture"},"content":"\n## Clean Architecture\n[클린 아키텍쳐](http://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html) 는 로버트 마틴이 작성한 글에서 유래되었습니다.  \n이에 대한 같은 이름에 책으로도 나와서 더 자세한 내용을 볼 수 있습니다.  \n주된 내용은 아키텍처적으로 의존성을 줄이는 내용입니다.  \n우리는 학습할 때 기본적으로 의존성을 줄이려고 노력합니다.  \n하지만 Spring에서 작성하다보면 결국 이렇게 하면 Spring에 의존적이지 않은가 생각이 듭니다.  \n이런 의구심이 들 때 이 내용을 보고 의구심이 많이 풀렸습니다.  \n\n### Entities\n핵심 도메인들이 여기에 위치하게 됩니다.  \n흔히 사용하는 Entity와 해당하는 비즈니스 로직들이 여기에 해당하게 됩니다.  \n\n### Use Cases\nEntity들을 이용해 구체적인 작업을 하는 계층입니다.  \nUse Cases가 바뀐다고 해서 Entity에 영향이 가지 않습니다.  \nUse Cases를 통해 데이터의 입력과 출력이 처리되기도 합니다.  \n\n### Interface Adapters\nController, Gateway, Presenter 같은 외부에서 사용될 때 접하는 부분입니다.  \nentity와 use cases에서 사용하기 쉽게 데이터를 변환하는 작업을 하기도 합니다.  \n\n### Frameworks and Drivers\n데이터베이스, 프레임워크 같은 외부적인 요소들이 맨 바깥에 위치하게 됩니다.  \n즉 안에 있는 요소들은 Framework를 알아서도, 사용해서도 안됩니다.  \n이런 구조를 만족했을 때 어떠한 마이그레이션이 있더라도 내부 계층의 코드는 수정하지 않습니다.  \n\n"},{"metadata":{"layout":"post","title":"TIL 210105","date":"2022-01-05 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220105TIL"},"content":"\n## BFS 문제 풀이\n- 가장 먼 노드\n\n"},{"metadata":{"layout":"post","title":"ORM","date":"2022-01-04 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"ORM"},"content":"\n## Object Relational Mapping\n객체와 관계형 데이터베이스를 매핑해주는 기술을 ORM이라고 합니다.  \n\n### 사용하는 이유\n코드와 SQL을 따로 작성하는 것보다 일관적이게 작업할 수 있습니다.  \n데이터를 가져오고 처리하는 작업을 객체지향적으로 처리할 수 있습니다.  \n단점으로 느껴질 수도 있지만 DB에 종속적이지 않은 문법을 주로 사용하게 됩니다.  \n즉 실제로 사용할 때는 DB 연결 설정을 넣기는 하지만 처리하는 부분은 공통된 코드를 사용하게 됩니다.  \n객체지향적으로 따지면 인터페이스에서 제공하는 메서드만 사용할 수 있습니다.  \n여기서 오는 장점은 DB가 교체되더라도 코드를 바꿀 필요가 없게 됩니다.  \n정리해보면 장점은 다음과 같습니다.\n\n- SQL 없이 객체지향적인 코드만으로 데이터를 처리할 수 있습니다.\n- DB에 종속적이지 않은 코드를 처리할 수 있습니다.\n\n### 객체지향적으로 처리하는 게 무슨 의미일까?\n객체지향적으로 처리하는 게 무조건 좋다는 뜻은 아닙니다.  \n하지만 Java 처럼 객체지향적인 언어를 사용할 때 객체지향적으로 처리하는 것이 좋습니다.  \n이는 개발 속도나 개발자의 실수등을 막는데 도움이 됩니다.  \n예를 들어 ORM이 아닌 JDBC를 사용했다면 이렇게 사용하게 됩니다. \n```java\nString sql = \"select empno, ename, sal from emp\";\nps = con.prepareStatement(sql);\nrs = ps.executeQuery();\nwhile(rs.next()){\n    System.out.println(rs.getInt(\"empno\"));\n}\n```\n여기서 \"empno\"를 \"emnpo\" 같이 잘못써도 컴파일 에러를 볼 수 없습니다.  \n그리고 empno, ename 같은 값들을 emp 객체가 아닌 단순 값들로 받아오게 됩니다.  \n즉 우리가 실제로 사용할 때는 객체로 변환하는 과정을 직접해주게 됩니다.  \nORM을 사용한다면 이런 에러를 컴파일 에러로 찾을 수 있고 변환하는 과정도 처리해줍니다.  \n\nC#에서 사용하는 SQL을 사용해 값을 받아오는 방법입니다.  \n```cs\nvar sql = \"SELECT id, first_name, last_name  FROM persons WHERE id = 10\";\nvar result = context.Persons.FromSqlRaw(sql).ToList();\nvar name = result[0][\"first_name\"];\n```\nJavascript에서도 기본 db connector를 사용하면 비슷하게 사용합니다.  \n여기서 볼 점은 이 코드를 보고 바로 id가 10인 사람을 찾으려는 결 알 수 있을까요?  \n개발자가 스스로 id가 10인 사람을 찾으니까 result 0번을 봐야겠다고 판단해야합니다.  \n없을 경우를 생각해서 예외처리도 따로 필요합니다.\n\n```cs\nvar person = Person.Get(10);\n```\nORM으로 작성하면 이런 식으로 작성하게 됩니다.  \n개발자가 아니더라도 10이라는 사람을 찾으려는구나 이해할 수 있습니다.  \n이렇게 실제 코드와 SQL 간의 차이를 좁혀줄 수 있습니다.  \n"},{"metadata":{"layout":"post","title":"TIL 210104","date":"2022-01-04 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220104TIL"},"content":"\n## 플로이드 알고리즘\n- 그래프 문제 풀이\n\n"},{"metadata":{"layout":"post","title":"함께 자라기","date":"2022-01-03 00:45:00 +0900","category":"book","tags":["book"],"keywords":["book"],"id":"함께 자라기"},"content":""},{"metadata":{"layout":"post","title":"[프로그래머스] 빛의 경로 사이클 (JAVA)","date":"2022-01-03 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"빛의 경로 사이클"},"content":"```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n    // S, L, R 순\n    // 좌, 상, 우, 하 순\n    int[][] dy = { {0, 1, 0, -1}, {-1, 0, 1, 0}, {1, 0, -1, 0} };\n    int[][] dx = { {1, 0, -1, 0}, {0, 1, 0, -1}, {0, -1, 0, 1} };\n    int[][] dd = { {0, 1, 2, 3}, {3, 0, 1, 2}, {1, 2, 3, 0} };\n    boolean[][][] visited;\n    char[][] dir;\n    int count;\n\n    public int[] solution(String[] grid) {\n        /*\n        시작할 수 있는 위치 모든 점 * 4\n        */\n        dir = new char[grid.length][];\n        for(int i = 0; i < grid.length; i++){\n            dir[i] = grid[i].toCharArray();\n        }\n        visited = new boolean[dir.length][dir[0].length][4];\n        List<Integer> list = new ArrayList<>();\n\n        for(int i = 0; i < dir.length; i++){\n            for(int j = 0; j < dir[i].length; j++){\n                for(int k = 0; k < 4; k++){\n                    if(visited[i][j][k]) continue;\n                    count = 0;\n                    dfs(i, j, k);\n                    list.add(count);\n                }\n            }\n        }\n        return list.stream().sorted().mapToInt(Integer::intValue).toArray();\n    }\n\n    void dfs(int y, int x, int d){\n\n        while(!visited[y][x][d]){\n            visited[y][x][d] = true;\n            count++;\n            int m = Direction.valueOf(String.valueOf(dir[y][x])).value;\n            y = (y + dy[m][d] + dir.length) % dir.length;\n            x = (x + dx[m][d] + dir[0].length) % dir[0].length;\n            d = dd[m][d];\n        }\n    }\n\n    enum Direction{\n        S(0), L(1), R(2);\n        private final int value;\n        Direction(int value) {\n            this.value = value;\n        }\n    }\n\n}\n```\n\n### 실수했던 점\n실제 시험 때 풀어보려다가 일이 생겨서 못 풀었던 문제였습니다.  \n다시 풀어보려했을 때도 막막해보였지만 이번에는 방법이 보였습니다.  \n그런데 테스트케이스 하나에서 계속 런타임 에러가 발생했습니다.  \n배열 크기가 넘어가는 문제가 있나 계속 봤지만 찾을 수 없었습니다.  \n그러다 최적화를 하다가 문제를 고칠 수 있었습니다.  \n런타임 에러가 생겼던 이유는 재귀 함수로 인한 스택 오버 플로우였습니다.  \n재귀함수를 썼는데 이유를 알 수 없는 런타임 에러라면 의심해볼만 합니다.  "},{"metadata":{"title":"[프로그래머스] 빛의 경로 사이클 (JAVA)","date":"2022-01-03 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"교점에 별 만들기"},"content":"\n```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class Solution {\n\n    public String[] solution(int[][] line) {\n        /*\n        Ax + By + E = 0\n        Cx + Dy + F = 0\n        */\n        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;\n        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;\n        Set<Pair> set = new HashSet<>();\n        for (int i = 0; i < line.length; i++) {\n            for (int j = i + 1; j < line.length; j++) {\n                if (i == j) continue;\n                long A = line[i][0];\n                long B = line[i][1];\n                long E = line[i][2];\n                long C = line[j][0];\n                long D = line[j][1];\n                long F = line[j][2];\n\n                long down = A * D - B * C;\n                long ux = B * F - E * D;\n                long uy = E * C - A * F;\n                if (down == 0 || ux % down != 0 || uy % down != 0) continue;\n                minX = Math.min(minX, (int) (ux / down));\n                maxX = Math.max(maxX, (int) (ux / down));\n                minY = Math.min(minY, (int) (uy / down));\n                maxY = Math.max(maxY, (int) (uy / down));\n                set.add(new Pair((int) (uy / down), (int) (ux / down)));\n            }\n        }\n        int x = (int) (maxX - minX + 1);\n        int y = (int) (maxY - minY + 1);\n        char[][] map = new char[y][x];\n        String[] answer = new String[y];\n\n        for (char[] m : map)\n            Arrays.fill(m, '.');\n\n        for (Pair p : set)\n            map[p.y - minY][p.x - minX] = '*';\n\n        for (int i = 0; i < y; i++) {\n            answer[i] = new String(map[y - 1 - i]);\n        }\n\n        return answer;\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int y, x;\n\n        public Pair(int y, int x) {\n            this.y = y;\n            this.x = x;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair pair = (Pair) o;\n            return y == pair.y && x == pair.x;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(y, x);\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            if (y == o.y) {\n                return x - o.x;\n            }\n            return Integer.compare(y, o.y);\n        }\n    }\n\n}\n```\n\n### 실수했던 점\n공식이 주어져서 구현만 잘하면 되는 문제라고 생각했습니다.  \n하지만 테스트케이스 한 두개에서 계속 실패했습니다.  \n로직상으로 잘못된 부분이 없다고 생각해서 오래 고민했습니다.  \n그러다 찾은 문제는 자료형의 크기였습니다.  \n최대로 나올 수 있는 크기가 10만 * 10만이라 100억까지 가게됩니다.  \n음수로 처리되서 계속해서 잘못된 값이 나왔습니다.   \n코딩하기 전에 최대값을 계산하고 자료형을 선택해야겠습니다.  \n"},{"metadata":{"layout":"post","title":"Jekyll structure","date":"2022-01-03 00:45:00 +0900","category":"blog","tags":["blog"],"keywords":["blog"],"id":"jekyll structure"},"content":"\n## Jekyll에서 변수 사용하기\n\\{\\{ \\}\\} 는 변수를 표시합니다.  \n| 는 변수와 뒤에 조건문에 따라 변경합니다.  \n\n\n```yaml\n---\nmy_number: 5\n---\n```\n--- 사이에 yaml 형식으로 변수를 작성합니다.  \n사이에 작성한 값들은 page 뒤 변수로 사용 가능합니다.  \n"},{"metadata":{"layout":"post","title":"Jekyll에서 페이지 추가하기","date":"2022-01-03 00:45:00 +0900","category":"blog","tags":["blog"],"keywords":["blog"],"id":"jekyll page 추가"},"content":"\n## Jekyll에서 다른 페이지에 추가하기\nJekyll에서 html이나 markdown을 추가하는 방법은 루트 위치에 파일을 놓으면 됩니다.  \n빌드가 되면 _site에 생성된 파일을 확인할 수 있습니다. \n\n## 원하는 위치에 파일 놓기\n하지만 루트에 파일이 많아지면 확인하기 힘드므로 이런 파일들을 다른 곳에 분리시킬 필요가 있습니다.  \n이때 다른 디렉토리에 위치시키고 최상단에 liquid 형식으로 permalink를 추가해주면 됩니다.  \n해당 html이 생성될 위치를 지정할 수 있습니다.  \n```ruby\n---\npermalink: /a.html\n---\n```\n"},{"metadata":{"layout":"post","title":"TIL 210103","date":"2022-01-03 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220103TIL"},"content":"## 알고리즘 문제 풀이\n- 교점에 별 만들기\n- 빛의 경로 사이클\n\n## 블로그 수정\n블로그 카테고리별 루트 추가"},{"metadata":{"title":"[프로그래머스] 전력망을 둘로 나누기 (JAVA)","date":"2022-01-02 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"전력망을 둘로 나누기"},"content":"\n```java\npublic class Solution {\n\n    public int solution(int n, int[][] wires) {\n        int answer = 100;\n        for(int i = 0; i < n-1; i++){\n            DisjointSet set = new DisjointSet(n);\n            for(int j = 0; j < n-1; j++){\n                if(j == i) continue;\n                set.merge(wires[j][0], wires[j][1]);\n            }\n            int partialSize = set.getPartialSize();\n            answer = Math.min(answer, Math.abs(n - 2 * partialSize));\n        }\n        return answer;\n    }\n\n    static class DisjointSet{\n        int[] parents;\n        int[] rank;\n\n        public DisjointSet(int n){\n            parents = new int[n+1];\n            rank = new int[n+1];\n            for(int i = 1; i < n+1; i++){\n                parents[i] = i;\n                rank[i] = 1;\n            }\n        }\n\n        public int find(int u){\n            if(parents[u] == u) return u;\n            return parents[u] = find(parents[u]);\n        }\n\n        public void merge(int u, int v){\n            u = find(u);\n            v = find(v);\n            if(u == v) return;\n            parents[u] = v;\n        }\n\n        private int getPartialSize(){\n            int size = 0;\n            int partialParent = find(1);\n            for(int i = 1; i < parents.length; i++){\n                if(find(i) == partialParent)\n                    size++;\n            }\n            return size;\n        }\n    }\n}\n```\n\n### 실수했던 점\n각 집합의 루트를 찾아서 일치하는지 확인했어야 하는데 부모를 찾아서 비교했습니다.  \n부모가 부분적으로만 갱신되는 점을 생각하지 못했습니다.  \n일단 시간이 더 걸리더라도 확실한 방법으로 풀어야겠습니다.  "},{"metadata":{"title":"Union Find","date":"2022-01-02 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"Union Find"},"content":"\n## Disjoint Set\nDisjoint Set은 상호 배타적 집합으로 서로 구분되는 집합입니다.\n각 집합은 중복되지 않은 원소의 집합으로 구성되어 있습니다.  \nDisjoint Set은 여러 자료구조로 표현할 수 있습니다.  \n\n### 배열로 표현하기\n가장 단순한 방법은 배열로 표현하는 것입니다.  \n시작은 크기가 1인 집합으로 자신의 값에 해당하는 위치를 표현합니다.  \n```java\narr[i] = i;\n```\n이후에 합쳐질 때마다 값을 바꿔주면 됩니다.  \n예를 들어 집합을 나타내는 기준을 더 작은 값이라고 두겠습니다.  \n1, 3, 5가 같은 집합이라면 배열의 1, 3, 5번은 1이 됩니다.  \n이런 식으로 구하다보면 제일 작은 기준으로 집합이 나눠집니다.  \n이때 찾는데 걸리는 시간은 배열 값을 보면 되므로 O(1)입니다.  \n문제는 합치는 데 걸리는 시간은 O(N)이 됩니다.  \n두 수가 주어질 때 다른 점들이 어느 집합에 있는지 모르기 때문에 전체를 돌아야 합니다.  \n그래서 찾는 시간은 빠르지만 이 방법보단 다른 방법을 사용합니다.  \n\n### 트리로 표현하기\n트리로 사용할 때는 자신의 부모를 따라 올라가 루트로 집합을 비교합니다.  \n따라서 찾기 연산은 루트를 찾는데 걸리는 시간이 됩니다.   \n합칠 때 두 집합의 루트 중 하나를 다른 하나의 루트로 만들면 되므로 배열보다 시간이 줄어듭니다.  \n이 때 찾기 연산은 잘 분포되어있다면 트리가 그렇듯 O(logN)이 됩니다.  \n하지만 균등하게 분포되어 있지않다면 O(N)이 됩니다.  \n\n## Union FInd\nDisjoint Set을 구현할 때 세 가지 연산이 필요합니다.  \n- 초기화 : 크기가 1인 원소들의 집합으로 초기화\n- 찾기 : 집합의 루트 찾기\n- 합치기 : 두 집합이 연결되어 있을 때 합치기\n여기서 찾기와 합치는 연산이 대표적이기에 Union Find라고 부릅니다.\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n// 트리를 이용해 상호 배타적 집합을 구현한다.\npublic class NaiveDisjointSet {\n    List<Integer> parent;\n    public NaiveDisjointSet(int n){\n        this.parent = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            parent.add(i);\n        }\n    }\n    // u가 속한 트리의 루트를 반환한다.\n    int find(int u) {\n        if(u == parent.get(u)) return u;\n        return find(parent.get(u));\n    }\n    // u가 속한 트리와 v가 속한 트리를 합친다.\n    void merge(int u, int v){\n        u = find(u);\n        v = find(v);\n        // u와 v가 이미 같은 트리에 속하는 경우를 걸러낸다.\n        if(u == v) return;\n        parent.set(u, v);\n    }\n}\n```\n\n간단하게 만드는 경우 문제는 불균형하게 분포되었을 때입니다.  \n트리가 일직선으로 분포되는 경우로 시간 복잡도가 O(N)입니다.  \n배열로 만들었을 때도 O(1)인 걸 생각하면 사용할 이유가 없습니다.  \n그래서 사용하는 방법은 트리의 높이를 비교해서 합칩니다.  \n높은 트리가 낮은 트리의 부모가 된다면 일직선 분포를 막을 수 있습니다.  \n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n// 트리를 이용해 상호 배타적 집합을 구현한다.\npublic class OptimizedDisjointSet extends NaiveDisjointSet{\n\n  List<Integer> rank;\n\n  public OptimizedDisjointSet(int n) {\n    super(n);\n    rank = new ArrayList<>(n);\n    for(int i = 0; i < n; i++)\n      rank.add(1);\n  }\n\n  @Override\n  public int find(int u){\n    if(u == parent.get(u)) return u;\n    parent.set(u, find(parent.get(u)));\n    return parent.get(u);\n  }\n\n  @Override\n  public void merge(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if(u == v) return;\n    if(rank.get(u) > rank.get(v)){\n      v = swap(u, u = v);\n    }\n    parent.set(u, v);\n    if(rank.get(u).equals(rank.get(v))){\n      rank.set(v, rank.get(v));\n    }\n  }\n\n  // y = swap(x, x = y)\n  private int swap(int a, int b){\n    return a;\n  }\n}\n```"},{"metadata":{"layout":"post","title":"Java Static Nested Class","date":"2022-01-02 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Inner Static"},"content":"\n## Static Nested Class\n\n```java\npublic class MainClass{\n    static class NestedClass{\n    }\n}\n```\nIntellij 에서 inner class를 만들면 static으로 수정하라는 경고가 나옵니다.  \nstatic을 붙여도 안붙여도 동작은 하지만 붙인다면 어떤 차이점이 있을까요?\n\n- 바깥 클래스를 참조할 수 없습니다.\n- 바깥 클래스 생성 여부와 상관 없이 생성할 수 있습니다.\n\n우선 내부에서 바깥 클래스 데이터를 알 필요가 없을 때 사용하는 걸 권장하고 있습니다.  \nstatic을 붙이지 않으면 외부 클래스를 사용하기 위해 외부 참조가 필요합니다.  \n이 경우 메모리도 더 차지하고, 내부에서 참조하고 있어 가비지 컬렉션이 수거하기 어려워집니다.  \n클래스에 인스턴스를 생성할 때도 멤버 클래스에 대한 메모리를 더 차지하게 됩니다.  \n\n두 번째 차이점은 사용 용도에 따라 필요해질 수 있습니다.  \nDTO나 VO처럼 파생되는 클래스들을 모두 만들다보면 클래스가 너무 많아지게 됩니다.  \n이럴 때 연관되는 클래스끼리 모아서 inner static class로 만들어서 사용할 수 있습니다.  \n이때 바깥 클래스는 패키지처럼 묶어주는 역할만 하므로 생성 여부와 상관없어야 합니다.  \n따라서 이런 상황에서 static class가 유용해집니다.   \n\n```java\npublic class Member{\n    public static class Request{\n        ...\n    } \n    public static class Response{\n        ...\n    }\n}\n```\n"},{"metadata":{"layout":"post","title":"TIL 210102","date":"2022-01-02 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220102TIL"},"content":"\n## 유니온 파인드 알고리즘\n- 프로그래머스 dfs, 유니온 파인드 문제 해결\n- 유니온 파인드 책보며 알고리즘 정리\n\n## Java Static Class\nJava inner static class 쓰는 이유 학습\n"},{"metadata":{"layout":"post","title":"Head vs Header","date":"2022-01-01 00:45:00 +0900","category":"backend","tags":["backend"],"keywords":["backend"],"id":"Header"},"content":"\n## Head\nhead 태그는 html의 메타데이터를 표기합니다.  \ntitle, css의 링크, charset 같은 눈에 보이지 않지만 메타정보를 표기합니다.  \n```html\n  <head>\n    <meta charset=\"utf-8\">\n    <title>title</title>\n  </head>\n```\n\n## Header\nheader 태그는 말 그대로 소개를 위해 쓰이는 태그입니다. \n```html\n<header class=\"large-header\">\n    <h1>Introduce my story</h1>\n</header>\n```\n\n---\nhtml이나 css를 다룰 일이 많지 않다보니 head를 header로 잘못 작성한 적이 있습니다.  \n메타데이터를 나타내는 태그는 html과 body처럼 4글자인 걸 기억하면 좋을 것 같습니다.  "},{"metadata":{"title":"TIL 210101","date":"2022-01-01 00:44:00 +0900","category":"til","tags":["til"],"keywords":["til"],"id":"220101TIL"},"content":"\n## 코딩테스트 공부를 다시 시작\n- 프로그래머스 레벨 1 새로 생긴 문제들 다 풀기\n\n## 블로그 필요한 부분들 만들기\n- 홈화면에 카테고리를 만들려면?\n"}]},"__N_SSG":true}