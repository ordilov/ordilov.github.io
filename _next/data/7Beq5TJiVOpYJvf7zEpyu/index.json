{"pageProps":{"postsMetaData":[{"metadata":{"layout":"post","title":"KCM Travel","date":"2022-02-26 00:01:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-02-26-KCM Travel"},"content":"\n```kotlin\npackage boj.graph\n\nimport java.util.*\n\n// [KCM Travel] https://www.acmicpc.net/problem/10217\nfun main() {\n    val sb = StringBuilder()\n    val t = readLine()!!.toInt()\n    repeat(t) {\n        val (n, m, k) = readLine()!!.split(\" \").map { it.toInt() }\n        val graph = Array(n + 1) { ArrayList<Ticket>() }\n        repeat(k) {\n            val (u, v, c, d) = readLine()!!.split(\" \").map { it.toInt() }\n            graph[u].add(Ticket(v, c, d))\n        }\n        val queue = PriorityQueue<Ticket>()\n        val dist = Array(n + 1) { Array(m + 1) { Int.MAX_VALUE } }\n        dist[1][0] = 0\n        queue.add(Ticket(1, 0, 0))\n        var answer = Int.MAX_VALUE\n\n        while (queue.isNotEmpty()) {\n            val cur = queue.poll()\n            if (cur.v == n) {\n                answer = cur.d\n                break\n            }\n            if (dist[cur.v][cur.c] < cur.d) continue\n            for (ticket in graph[cur.v]) {\n                val cost = cur.c + ticket.c\n                val time = cur.d + ticket.d\n\n                if (cost > m) continue\n                if(dist[ticket.v][cost] <= time) continue\n                dist[ticket.v][cost] = time\n                queue.add(Ticket(ticket.v, cost, time))\n            }\n        }\n        sb.append(if (answer == Int.MAX_VALUE) \"Poor KCM\" else answer).append(\"\\n\")\n    }\n    println(sb)\n}\n\nprivate class Ticket(val v: Int, val c: Int, val d: Int) : Comparable<Ticket> {\n    override fun compareTo(other: Ticket): Int = d.compareTo(other.d)\n}\n```\n\n## 실수했던 점\n시간초과가 계속 나와서 반복작업을 줄여봤지만 계속해서 시간이 초과됐습니다.\n결국 문제였던 부분은 다른 부분이 아니라 출력 때문이었습니다.\n처음에 반복마다 println() 으로 출력하는 식으로 해서 오래 걸렸습니다.\nstringbuilder로 모아서 출력했더니 통과할 수 있었습니다.\n만약 로직에서 맞는 것 같은데 시간초과가 나온다면 출력을 모아서 해보는걸 추천드립니다."},{"metadata":{"layout":"post","title":"LIS","date":"2022-02-24 00:01:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-02-24-LIS"},"content":"\n## Longest Increasing Subsequence\n최장 증가 수열 문제로 어떤 수열에서 순서를 유지한 채 부분을 뽑아낼 때 만들 수 있는 가장 긴 수열을 찾습니다.\n처음에 헷갈렸던 부분은 증가의 의미가 \"~ 이상 ( >= )\" 이라고 생각했는데 순수하게 증가하는 \"초과\"의 의미를 갖습니다.\n`[1, 2, 3, 4]` 는 가능하지만 `[1, 2, 3, 3]` 은 증가 수열이 아닙니다.\n\n## 가장 간단한 방법\n문제를 해결하는 가장 간단한 방법은 모든 경우를 만드는 방법입니다.\n예제로 `[1, 3, 2, 4]`를 가정하겠습니다.\n현재까지 완성된 순열을 저장하는 리스트를 저장하는 이차원 리스트가 있다고 가정합니다.\n매 순서마다 각 인덱스에서 시작하는 리스트를 추가합니다.\n그리고 현재까지 생성된 리스트의 마지막보다 현재 인덱스가 크면 그 리스트에 현재 인덱스 값을 추가한 리스트를 추가합니다.\n\n```java\nList<List<Integer>> sequences;\n```\n\n첫 번째 인덱스에서 만들어지는 리스트는 첫 번째 원소를 포함합니다.\n추가되는 리스트는 `[1]`이 됩니다.\n\n그리고 두 번째 인덱스에서 시작하는 리스트를 추가합니다.\n두 번째 인덱스에서는 기존에 존재하는 리스트는 `[1]` 이었고 3이 더 크기 때문에 추가합니다.\n이렇게 추가된 리스트는 `[1], [3], [1, 3]`이 됩니다.\n\n세 번째 인덱스에서도 위의 방식을 반복합니다.  \n이렇게 추가된 리스트는 `[1], [2], [3], [1, 2], [1, 3]`이 됩니다.\n\n네 번째까지 반복하면 `[1], [2], [3], [4], [1, 4], [2, 4], [3, 4], [1, 3, 4], [1, 2, 4]`이 됩니다.\n\n이런 리스트가 만들어진다고 하면 LIS는 `[1, 3, 4], [1, 2, 4]` 중 하나가 되고 최장 길이는 3이 됩니다.\n\n위의 방식을 보면 최악의 경우 모든 인덱스에서 증가하는 경우 증가 수열의 개수가 늘어납니다.\n1, 3, 6, 10 ... 폭으로 증가하는 계차수열로 시간 복잡도는 O(n^3)이 됩니다.\n"},{"metadata":{"layout":"post","title":"[백준] 리모컨","date":"2022-02-22 00:01:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-02-18-리모컨"},"content":"\n```kotlin\npackage boj.bruteforce\n\nimport kotlin.math.abs\n\n// [리모컨] https://www.acmicpc.net/problem/1107\nfun main() {\n    val n = readLine()!!.toInt()\n    val m = readLine()!!.toInt()\n    val broken = BooleanArray(10)\n    if (m != 0)\n        readLine()!!.split(\" \").forEach { broken[it.toInt()] = true }\n    val justMove = abs(100 - n)\n\n    var min = 987654321;\n    for (i in 0 until 1000000) {\n        val str = i.toString()\n        var movable = true\n        for (element in str) {\n            if (broken[element.digitToInt()]) {\n                movable = false\n                break\n            }\n        }\n        if (!movable) continue\n        min = min.coerceAtMost(str.length + abs(i - n))\n    }\n    println(justMove.coerceAtMost(min))\n}\n```\n\n## 실수했던 점\n한 번 숫자가 정해지고 나면 그 이후로는 더하거나 빼서 값을 구하는 문제였습니다.\n문제는 그 숫자가 정해지는 방법인데 최적의 방법이 있을 것이라 생각하고 구하려 했습니다.\n하지만 계속해서 예외 케이스가 나왔고 결국 완전 탐색으로 해결했습니다.\n다시 한 번 시간이 충분하다면 완전 탐색으로 푸는 걸 먼저 해보는게 더 빠른 방법이라 배웠습니다.\n"},{"metadata":{"layout":"post","title":"위상 정렬","date":"2022-02-18 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-02-18-위상정렬"},"content":"\n## 위상 정렬\n`위상 정렬(Topological sort)`은 정점들의 순서를 찾는 알고리즘입니다.\n순서가 존재한다는 것은 시작점이 존재한다는 것을 의미합니다.\n따라서 시작점이 존재하지 않고 반복되는 사이클의 경우 정렬할 수 없습니다.\n\n## 위상 정렬 특징\n사이클이 생기지 않을 때 그래프에서 시작점은 여러 곳이 될 수 있습니다.\n시작점과 연결 순서에 따라서 위상 정렬은 여러가지 순서가 나올 수 있습니다.\n\n## 위상 정렬 방법\n1. 진입 차수가 0인 정점들을 큐에 넣습니다.\n2. 선택된 정점들의 진입 차수를 감소시킵니다.\n3. 큐가 빌 때까지 1~2번을 반복합니다.\n\n"},{"metadata":{"layout":"post","title":"[백준] 순위 검색","date":"2022-02-07 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-02-07-행성 터널"},"content":"\n```java \nimport java.util.*\n\nvar parent: IntArray = intArrayOf()\nvar rank: IntArray = intArrayOf()\n\nfun main() {\n    val n = readLine()!!.toInt()\n    val xQueue: MutableList<Pair<Int, Int>> = mutableListOf()\n    val yQueue: MutableList<Pair<Int, Int>> = mutableListOf()\n    val zQueue: MutableList<Pair<Int, Int>> = mutableListOf()\n\n    repeat(n) {\n        val (x, y, z) = readLine()!!.split(\" \").map { it.toInt() }\n        xQueue.add(Pair(it, x))\n        yQueue.add(Pair(it, y))\n        zQueue.add(Pair(it, z))\n    }\n    xQueue.sortBy { it.second }\n    yQueue.sortBy { it.second }\n    zQueue.sortBy { it.second }\n\n    val queue: PriorityQueue<Pair<Pair<Int, Int>, Int>> = PriorityQueue(compareBy { it.second })\n    for (i in 0 until n - 1) {\n        queue.add(\n            Pair(\n                Pair(xQueue[i].first, xQueue[i + 1].first),\n                xQueue[i + 1].second - xQueue[i].second\n            )\n        )\n        queue.add(\n            Pair(\n                Pair(yQueue[i].first, yQueue[i + 1].first),\n                yQueue[i + 1].second - yQueue[i].second\n            )\n        )\n        queue.add(\n            Pair(\n                Pair(zQueue[i].first, zQueue[i + 1].first),\n                zQueue[i + 1].second - zQueue[i].second\n            )\n        )\n    }\n\n    var result = 0\n    parent = IntArray(n) { it }\n    rank = IntArray(n) { 1 }\n    while (queue.isNotEmpty()) {\n        val (loc, distance) = queue.poll()\n        val (a, b) = loc\n        val connect = union(a, b)\n        if (connect) result += distance\n    }\n    println(result)\n}\n\nprivate fun union(a: Int, b: Int): Boolean {\n    val aRoot = find(a)\n    val bRoot = find(b)\n    if (aRoot == bRoot) return false\n    if (rank[aRoot] < rank[bRoot]) {\n        parent[aRoot] = bRoot\n    } else {\n        parent[bRoot] = aRoot\n        if (rank[aRoot] == rank[bRoot]) rank[aRoot]++\n    }\n    return true\n}\n\nprivate fun find(a: Int): Int {\n    if (parent[a] == a) return a\n    val findParent = find(parent[a])\n    parent[a] = findParent\n    return findParent\n}\n```\n\n## 실수했던 점\n처음에는 메모리 초과, 그 다음으로는 시간 초과가 계속 발생했던 문제였습니다.  \n그 이유는 행성 간 연결이 최대인 경우 10000 * 99999 / 2 만큼 발생하게 됩니다.  \n이 경로를 전부 저장하려고 했다가 메모리 초과가 나왔습니다.\n그 다음으로는 한 점에서 다음 행성들에서 나올 수 있는 최솟값만 저장하려고 했습니다.  \n이 방법도 마찬가지로 연결이 최대인 경우 시간 초과가 나와서 통과하지 못했습니다.  \n결국 해결방법은 무식해보이지만 각 축마다 정렬을 하고 인접한 두 점들만 넣어서 구하면 됐습니다.\n인접한 두 점들만 구하면 된다는 걸 모르면 해결하기 어려운 문제였습니다. "},{"metadata":{"layout":"post","title":"[프로그래머스] 순위 검색","date":"2022-01-19 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-19-순위 검색"},"content":"\n```java\nimport java.util.*;\n\n// [순위 검색] https://programmers.co.kr/learn/courses/30/lessons/72412?language=java\npublic class Solution {\n\n    public int[] solution(String[] info, String[] query) {\n        Map<String, List<Integer>> map = new HashMap<>();\n        for (String i : info) {\n            String[] split = i.split(\" \");\n            int score = Integer.parseInt(split[4]);\n            for (String c : combination(split)) {\n                List<Integer> scores = map.getOrDefault(c, new ArrayList<>());\n                scores.add(score);\n                map.put(c, scores);\n            }\n        }\n\n        map.values().forEach(Collections::sort);\n\n        int[] answer = new int[query.length];\n        for (int j = 0; j < query.length; j++) {\n            String[] split = query[j].split(\" \");\n            int score = Integer.parseInt(split[7]);\n            String q = split[0] + split[2] + split[4] + split[6];\n            if (map.get(q) == null) continue;\n            answer[j] = binarySearch(map.get(q), score);\n        }\n        return answer;\n    }\n\n    private String[] combination(String[] split) {\n        String[] comb = new String[16];\n        Arrays.fill(comb, \"\");\n        for (int i = 0; i < 4; i++) {\n            for (int j = 0; j < (2 << i); j++) {\n                int size = 8 >> i;\n                for (int k = 0; k < size; k++) {\n                    comb[j * size + k] += j % 2 == 0 ? '-' : split[i];\n                }\n            }\n        }\n        return comb;\n    }\n\n    private int binarySearch(List<Integer> a, int score) {\n        int low = 0;\n        int high = a.size();\n        int mid;\n        while (low < high) {\n            mid = (low + high) / 2;\n            if (a.get(mid) >= score) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return a.size() - low;\n    }\n\n}\n```\n\n## 실수했던 점\n처음에 각 부문마다 나누어서 계산했더니 정확성은 통과했지만 효율성에서 실패했습니다.  \n몇 번을 최적화했지만 실패했습니다.  \n그래서 다음으로 시도해본게 모든 경우의 수를 구하고 시도했습니다.  \n하지만 점수를 넘는 사람을 찾을 때 선형탐색으로 구했더니 역시 시간초과였습니다.  \n그래서 이분탐색 라이브러리를 사용했는데 문제가 생겼습니다.  \n이분탐색 라이브러리는 중복되는 값이 있는 경우 최저 인덱스를 구해주지 않습니다.  \n중복 중에는 랜덤으로 인덱스를 구하게 됩니다.  \n여기서 문제를 찾느라 한참 걸렸습니다.  \n좀만 더 하면 풀거 같은 아쉬운 마음에 너무 시간을 많이 잡아먹은 문제였습니다.  "},{"metadata":{"layout":"post","title":"[프로그래머스] 멀쩡한 사각형","date":"2022-01-12 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-12-멀쩡한사각형"},"content":"\n```java \nclass Solution {\n    public long solution(int w, int h) {\n        long result = 0;\n        double gradient = (double) w / h;\n        for (long i = 1; i < h; i++) {\n            result += Math.floor(gradient * i);\n        }\n        return result * 2;\n    }\n}\n```\n\n## 실수했던 점\n자료형이 중요했던 문제였습니다.  \n계산할 때 double에서 long으로 바꾸어도 크기가 크다보니 문제가 있었습니다.  \n다 풀고나서 다른 사람들 풀이에는 gcd를 사용한 방법이 많았습니다.  \n하지만 실제로 문제를 접할 때 떠오르기 쉽지 않을 것 같습니다.  "},{"metadata":{"layout":"post","title":"[프로그래머스] 후보키 (JAVA)","date":"2022-01-11 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-11-후보키"},"content":"\n```java\nimport java.util.Set;\nimport java.util.HashSet;\nimport java.util.Arrays;\nclass Solution {\n    boolean[] visited;\n    Set<String> columns = new HashSet<>();\n    Set<Set<String>> candidates = new HashSet<>();\n\n    public int solution(String[][] relation) {\n        visited = new boolean[relation[0].length];\n        int answer = 0;\n        for (int size = 1; size <= relation[0].length; size++) {\n            answer += countCandidateKey(relation, 0, size);\n        }\n        return answer;\n    }\n\n    private int countCandidateKey(String[][] relation, int start, int size) {\n        if (size == columns.size()) {\n            if (relation.length != getTupleSize(relation)) return 0;\n            for (Set<String> candidate : candidates) {\n                if (columns.containsAll(candidate)) return 0;\n            }\n            candidates.add(new HashSet<>(columns));\n            return 1;\n        }\n\n        int candidateKey = 0;\n        for (int i = start; i < relation[0].length; i++) {\n            if (visited[i]) continue;\n            columns.add(String.valueOf(i));\n            visited[i] = true;\n            candidateKey += countCandidateKey(relation, i + 1, size);\n            columns.remove(String.valueOf(i));\n            visited[i] = false;\n        }\n        return candidateKey;\n    }\n\n    private int getTupleSize(String[][] relation) {\n        String[] row = new String[relation.length];\n        Arrays.fill(row, \"\");\n        for (String column : columns) {\n            for (int i = 0; i < relation.length; i++) {\n                row[i] += relation[i][Integer.parseInt(column)];\n            }\n        }\n        return new HashSet<>(Arrays.asList(row)).size();\n    }\n}\n```\n\n## 실수했던 점\n이전에 풀다가 포기했었던 문제였습니다.  \n여러 개의 칼럼을 어떻게 조합할지 감이 안왔는데 **DFS**를 이욯해 풀었습니다.  \n먼저 조합으로 모든 경우의 수를 만들고 최소성을 만족하는지 확인했습니다.  \n그런데 처음에는 키들을 문자열 하나로 합쳐서 비교했는데 여기서 문제가 있었습니다.  \n`[\"01\", \"001\"] [\"010\", \"01\"]` 은 유일성을 만족하지만 합치면 만족 못하는 걸로 판별됩니다.  \n따라서 문자열 말고 집합에 담아서 집합끼리 비교해야 했습니다.  \n이걸 가능하게 해주는 함수는 **containsAll** 입니다.  \n바꾸고서 문제는 통과하지만 비효율적이라고 느껴져 다른 사람들의 풀이를 찾아봤습니다.  \n인상적이었던 부분은 완전 탐색을 할 때 비트연산을 사용하는 것입니다.  \n**BitSet**을 사용할 수도 있고 단순 비트연산으로도 가능합니다.  \n"},{"metadata":{"layout":"post","title":"[프로그래머스] 프렌즈4블록 (JAVA)","date":"2022-01-11 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-11-프렌즈4블록"},"content":"\n```java\nclass Solution {\n    boolean[][] visited;\n    char[][] blocks;\n    int[] dy = {0, 1, 0, 1};\n    int[] dx = {0, 0, 1, 1};\n\n    public int solution(int m, int n, String[] board) {\n        blocks = new char[m][];\n        int answer = 0;\n        for (int i = 0; i < board.length; i++)\n            blocks[i] = board[i].toCharArray();\n\n        while (true) {\n            int count = 0;\n            visited = new boolean[m][n];\n            for (int i = 0; i < m; i++) {\n                for (int j = 0; j < n; j++) {\n                    if (blocks[i][j] == Character.MIN_VALUE) continue;\n                    if (!isMatched(i, j)) continue;\n                    count += checkVisited(i, j);\n                }\n            }\n            if (count == 0) break;\n            removeBlocks(m, n);\n            arrangeBlocks(m, n);\n            answer += count;\n        }\n        return answer;\n    }\n\n    private void removeBlocks(int m, int n) {\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (visited[i][j])\n                    blocks[i][j] = Character.MIN_VALUE;\n            }\n        }\n    }\n\n    private void arrangeBlocks(int m, int n) {\n        for (int j = 0; j < n; j++) {\n            for (int i = m - 1; i >= 0; i--) {\n                if (blocks[i][j] != Character.MIN_VALUE) continue;\n                int next = i - 1;\n                while (next >= 0 && blocks[next][j] == Character.MIN_VALUE) {\n                    next--;\n                }\n                if (next < 0) break;\n                blocks[i][j] = blocks[next][j];\n                blocks[next][j] = Character.MIN_VALUE;\n            }\n        }\n    }\n\n    private boolean isMatched(int y, int x) {\n        for (int i = 1; i < 4; i++) {\n            int ny = dy[i] + y;\n            int nx = dx[i] + x;\n            if (ny >= blocks.length || nx >= blocks[0].length) return false;\n            if (blocks[ny][nx] != blocks[y][x]) return false;\n        }\n        return true;\n    }\n\n    private int checkVisited(int y, int x) {\n        int visitCount = 0;\n        for (int i = 0; i < 4; i++) {\n            int ny = dy[i] + y;\n            int nx = dx[i] + x;\n            if (!visited[ny][nx]) visitCount++;\n            visited[ny][nx] = true;\n        }\n        return visitCount;\n    }\n}\n```\n\n## 실수했던 점\ndfs로 재귀함수로 작성했을 때 시간초과가 발생했습니다.  \n이전에도 그랬지만 되도록 반복문으로 처리해야겠습니다.  \n중복되는 부분들을 더 최적화할 수 있을 것 같습니다.  "},{"metadata":{"layout":"post","title":"[프로그래머스] 압축 (JAVA)","date":"2022-01-10 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-10-압축"},"content":"\n```java \nimport java.util.Map;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.ArrayList;\nclass Solution {\n    public int[] solution(String msg) {\n        Map<String, Integer> map = new HashMap<>();\n        for (int i = 0; i < 26; i++) {\n            map.put(String.valueOf((char) ('A' + i)), i + 1);\n        }\n        List<Integer> list = new ArrayList<>();\n        for (int i = 0; i < msg.length(); i++) {\n            int index = i + 1;\n            while (index <= msg.length() && map.get(msg.substring(i, index)) != null) {\n                index++;\n            }\n            String existWord = msg.substring(i, index - 1);\n            list.add(map.get(existWord));\n            if (index < msg.length()) {\n                map.put(msg.substring(i, index), map.size() + 1);\n            }\n            if (existWord.length() > 1) i += existWord.length() - 1;\n        }\n\n        return list.stream().mapToInt(i -> i).toArray();\n    }\n}\n```\n\n## 실수했던 점\nchar 형 자료에서 덧셈을 하면 int형으로 캐스팅되는 것을 놓쳤습니다.  \n여기서 문제점을 찾는데 5분정도 낭비했습니다.  "},{"metadata":{"layout":"post","title":"[프로그래머스] 방금그곡 (JAVA)","date":"2022-01-09 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-09-방금그곡"},"content":"\n```java \nimport java.util.List;\nimport java.util.ArrayList;\nimport java.text.ParseException;\nimport java.text.SimpleDateFormat;\nimport java.util.concurrent.TimeUnit;\n\nclass Solution {\n    public String solution(String m, String[] musicinfos) throws ParseException {\n        /*\n        musicinfos 로 재생된 거 만들기\n        m과 비교해서 일치하는 것 찾기\n        일치하면 재생된 시간 제일 긴것\n        재생된 시간도 같으면 먼저 입력된 음악 제목\n        */\n        List<String> list = new ArrayList<>();\n        int max = 0;\n        SimpleDateFormat format = new SimpleDateFormat(\"HH:mm\");\n        m = translateNoSharp(m);\n        for (String musicinfo : musicinfos) {\n            String[] split = musicinfo.split(\",\");\n            long startDate = format.parse(split[0]).getTime();\n            long endDate = format.parse(split[1]).getTime();\n            int minute = (int) TimeUnit.MILLISECONDS.toMinutes(endDate - startDate);\n\n            String title = split[2];\n            String score = split[3];\n            score = translateNoSharp(score);\n            StringBuilder melody = new StringBuilder();\n            int length = minute;\n            while (length > 0) {\n                melody.append(score, 0, Math.min(length, score.length()));\n                length -= score.length();\n            }\n            int idx = melody.indexOf(m);\n            if (idx == -1) continue;\n            if (minute < max) continue;\n            if (minute > max) {\n                list.clear();\n                max = minute;\n            }\n            list.add(title);\n        }\n        String answer = \"(None)\";\n        if (list.size() > 0) answer = list.get(0);\n        return answer;\n    }\n\n    private String translateNoSharp(String score) {\n        score = score.replaceAll(\"C#\", \"c\");\n        score = score.replaceAll(\"D#\", \"d\");\n        score = score.replaceAll(\"F#\", \"f\");\n        score = score.replaceAll(\"G#\", \"g\");\n        score = score.replaceAll(\"A#\", \"a\");\n        return score;\n    }\n}\n```\n\n## 실수했던 점\n처음 시도는 #을 기준으로 예외처리를 할려고 했습니다.  \n하지만 로직에 문제가 있었는지 테스트케이스 3개정도가 통과하지 못했습니다.  \n결국 다른 방법을 찾아 #을 아예 치환하는 방법을 택했습니다.  \n처음 방법으로 성공하지 못한게 아쉬웠습니다.  \n문법적으로 잘 몰랐던 부분은 SimpleDateFormat입니다.  \n처음에 Date 클래스를 사용하려했는데 `시:분`만 따로 사용할 수가 없었습니다.  \n그래서 포맷으로 바꾸고 시간 차이를 분으로 바꿔야 됐습니다.  \n시간 차이는 밀리세컨드로 나오므로 분으로 바꾸려면 나누기 60 * 1000을 해주면 됩니다.  \n하지만 더 보기 쉬운 방법으로 TimeUnit의 Enum을 사용하면 ms에서 minute으로 변환할 수 있습니다.  \n\n"},{"metadata":{"layout":"post","title":"[프로그래머스] 파일명 정렬 (JAVA)","date":"2022-01-08 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-08-파일명 정렬"},"content":"\n```java\nimport java.util.Map;\nimport java.util.LinkedHashMap;\nimport java.util.Arrays;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nclass Solution {\n    public String[] solution(String[] files) {\n        /*\n        HEAD 대소문자 구분 X\n        앞에 0 무시 숫자 순\n        TAIL은 순서에 영향 X\n        */\n        Map<String, FileName> fileNames = new LinkedHashMap<>();\n        Pattern numberPattern = Pattern.compile(\"[0-9]+\");\n        for (String file : files) {\n            Matcher matcher = numberPattern.matcher(file);\n            matcher.find();\n            String head = file.substring(0, matcher.start()).toLowerCase();\n            int number = Integer.parseInt(matcher.group());\n            fileNames.put(file, new FileName(head, number));\n        }\n\n        Arrays.sort(files, (o1, o2) -> {\n            FileName fileName1 = fileNames.get(o1);\n            FileName fileName2 = fileNames.get(o2);\n\n            if (!fileName1.head.equals(fileName2.head))\n                return fileName1.head.compareTo(fileName2.head);\n\n            return fileName1.number - fileName2.number;\n        });\n\n        return files;\n    }\n\n    static class FileName {\n        String head;\n        int number;\n\n        public FileName(String head, int number) {\n            this.head = head;\n            this.number = number;\n        }\n    }\n\n}\n```\n\n## 몰랐던 점\nmap에서 입력한 순서를 유지할 때 **LinkedHashMap**을 사용합니다.\nJava에서 정규식을 사용할 때 **Pattern**과 **Matcher**를 사용해야 합니다.  \n**Pattern**은 정규식 패턴을 만들고 패턴과 일치하는지 확인할 수 있습니다.  \n일치된 패턴을 해석할 때 **Matcher**를 이용합니다.  \n**find**로 다음 패턴을 찾고 **group**으로 찾은 값을 반환 받을 수 있습니다.  \n"},{"metadata":{"layout":"post","title":"[프로그래머스] 방문 길이 (JAVA)","date":"2022-01-06 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-07-방문길이"},"content":"\n```java\nclass Solution {\n    \n    private static final int MAX_X = 10, MAX_Y = 10, MIN_X = 0, MIN_Y = 0;\n    \n    public int solution(String dirs) {\n        boolean[][][] visited = new boolean[10][10][2];\n        int answer = 0, y = 5, x = 5;\n        for(String dir : dirs.split(\"\")){\n            DIRECTION d = DIRECTION.valueOf(dir);\n            int vertical = d.vertical;\n            int ny = y + d.y;\n            int nx = x + d.x;\n            if(nx > MAX_X || nx < MIN_X || ny > MAX_Y || ny < MIN_Y) continue;\n            int pointY = Math.max(y, ny);\n            int pointX = Math.max(x, nx);\n            y = ny; \n            x = nx;\n            if(visited[pointY][pointX][vertical]) continue;\n            visited[pointY][pointX][vertical] = true;\n            answer++;\n        }\n        return answer;\n    }\n    \n    enum DIRECTION {\n        U(1, 0, 0), D(-1, 0, 0), R(0, 1, 1), L(0, -1, 1);\n        final int y, x, vertical;\n        DIRECTION(int y, int x, int vertical){\n            this.y = y;\n            this.x = x;\n            this.vertical = vertical;\n        }\n    }\n}\n```\n\n## 실수했던 점\n처음에 방문한 위치를 선 기준이 아니라 점 기준으로 잡아서 틀렸습니다.  \n선 기준으로 잡기 위해서 선의 두 점 중에서 더 큰 점을 기준으로 체크했습니다.  \n그 다음으로 개선한 방법은 반복문을 인덱스로 처리하고 있었습니다.  \n하지만 split을 이용하면 문자열 배열을 이용할 수 있다는 것을 찾아 수정했습니다.  "},{"metadata":{"layout":"post","title":"[프로그래머스] 스킬트리 (JAVA)","date":"2022-01-06 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-06-스킬트리"},"content":"\n```java\nclass Solution {\n    public int solution(String skill, String[] skill_trees) {\n        int answer = 0;\n        for(String skill_tree : skill_trees){\n            char[] s = skill_tree.toCharArray();\n            boolean[] learned = new boolean[skill.length()];\n            boolean possible = true;\n            for(char c : s){\n                int order = skill.indexOf(c);\n                if(order == 0) learned[0] = true;\n                if(order <= 0) continue;\n                if(!learned[order-1]){\n                    possible = false;\n                    break;\n                }\n                learned[order] = true;\n            }\n            if(possible) answer++;\n        }\n        return answer;\n    }\n}\n```\n\n## 생각해볼 점\n난이도 2 중에서 쉬웠던 문제였습니다.  \n"},{"metadata":{"layout":"post","title":"[프로그래머스] 가장 먼 노드 (JAVA)","date":"2022-01-05 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-05-가장 먼 노드"},"content":"\n```java\nimport java.util.*;\nclass Solution {\n    \n    boolean[] visited;\n    int[] distances;\n    \n    public int solution(int n, int[][] edge) {\n        int answer = 0;\n        List<List<Integer>> graph = new ArrayList<>();\n        visited = new boolean[n+1];\n        distances = new int[n+1];\n        Arrays.fill(distances, 20001);\n        distances[1] = 0;\n        visited[1] = true;\n        \n        for(int i = 0; i <= n; i++){\n            graph.add(new ArrayList<>());\n        }\n        for(int[] e : edge){\n            graph.get(e[0]).add(e[1]);\n            graph.get(e[1]).add(e[0]);\n        }\n        \n        PriorityQueue<Node> queue = new PriorityQueue<>();\n        queue.add(new Node(1, 0));\n        int max = 0;\n        \n        while(!queue.isEmpty()){\n            Node now = queue.poll();\n            int dist = now.dist;\n            int to = now.to;\n            distances[to] = Math.min(distances[to], dist + 1);\n            if(distances[to] > max){\n                max = distances[to];\n                answer = 1;\n            } else if(distances[to] == max){\n                answer++;\n            }\n            for(int i : graph.get(to)){\n                if(visited[i]) continue;\n                visited[i] = true;\n                queue.add(new Node(i, dist + 1));\n            } \n        }\n \n        return answer;\n    }\n    \n    static class Node implements Comparable<Node>{\n        int to;\n        int dist;\n        public Node(int to, int dist){\n            this.to = to;\n            this.dist = dist;\n        }\n        @Override\n        public int compareTo(Node n){\n            return this.dist - n.dist;\n        }\n    }\n}\n```\n\n### 실수했던 점\n처음 풀었을 때 플로이드 방식을 풀었더니 메모리 초과 + 시간초과가 나왔습니다.  \n그래서 그래프 자료구조를 연결 리스트로 바꾸고 bfs 방식으로 탐색했습니다.  "},{"metadata":{"layout":"post","title":"[프로그래머스] 빛의 경로 사이클 (JAVA)","date":"2022-01-03 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-03-빛의 경로 사이클"},"content":"```java\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n    // S, L, R 순\n    // 좌, 상, 우, 하 순\n    int[][] dy = { {0, 1, 0, -1}, {-1, 0, 1, 0}, {1, 0, -1, 0} };\n    int[][] dx = { {1, 0, -1, 0}, {0, 1, 0, -1}, {0, -1, 0, 1} };\n    int[][] dd = { {0, 1, 2, 3}, {3, 0, 1, 2}, {1, 2, 3, 0} };\n    boolean[][][] visited;\n    char[][] dir;\n    int count;\n\n    public int[] solution(String[] grid) {\n        /*\n        시작할 수 있는 위치 모든 점 * 4\n        */\n        dir = new char[grid.length][];\n        for(int i = 0; i < grid.length; i++){\n            dir[i] = grid[i].toCharArray();\n        }\n        visited = new boolean[dir.length][dir[0].length][4];\n        List<Integer> list = new ArrayList<>();\n\n        for(int i = 0; i < dir.length; i++){\n            for(int j = 0; j < dir[i].length; j++){\n                for(int k = 0; k < 4; k++){\n                    if(visited[i][j][k]) continue;\n                    count = 0;\n                    dfs(i, j, k);\n                    list.add(count);\n                }\n            }\n        }\n        return list.stream().sorted().mapToInt(Integer::intValue).toArray();\n    }\n\n    void dfs(int y, int x, int d){\n\n        while(!visited[y][x][d]){\n            visited[y][x][d] = true;\n            count++;\n            int m = Direction.valueOf(String.valueOf(dir[y][x])).value;\n            y = (y + dy[m][d] + dir.length) % dir.length;\n            x = (x + dx[m][d] + dir[0].length) % dir[0].length;\n            d = dd[m][d];\n        }\n    }\n\n    enum Direction{\n        S(0), L(1), R(2);\n        private final int value;\n        Direction(int value) {\n            this.value = value;\n        }\n    }\n\n}\n```\n\n### 실수했던 점\n실제 시험 때 풀어보려다가 일이 생겨서 못 풀었던 문제였습니다.  \n다시 풀어보려했을 때도 막막해보였지만 이번에는 방법이 보였습니다.  \n그런데 테스트케이스 하나에서 계속 런타임 에러가 발생했습니다.  \n배열 크기가 넘어가는 문제가 있나 계속 봤지만 찾을 수 없었습니다.  \n그러다 최적화를 하다가 문제를 고칠 수 있었습니다.  \n런타임 에러가 생겼던 이유는 재귀 함수로 인한 스택 오버 플로우였습니다.  \n재귀함수를 썼는데 이유를 알 수 없는 런타임 에러라면 의심해볼만 합니다.  "},{"metadata":{"title":"[프로그래머스] 빛의 경로 사이클 (JAVA)","date":"2022-01-03 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-03-교점에 별 만들기"},"content":"\n```java\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class Solution {\n\n    public String[] solution(int[][] line) {\n        /*\n        Ax + By + E = 0\n        Cx + Dy + F = 0\n        */\n        int minX = Integer.MAX_VALUE, minY = Integer.MAX_VALUE;\n        int maxX = Integer.MIN_VALUE, maxY = Integer.MIN_VALUE;\n        Set<Pair> set = new HashSet<>();\n        for (int i = 0; i < line.length; i++) {\n            for (int j = i + 1; j < line.length; j++) {\n                if (i == j) continue;\n                long A = line[i][0];\n                long B = line[i][1];\n                long E = line[i][2];\n                long C = line[j][0];\n                long D = line[j][1];\n                long F = line[j][2];\n\n                long down = A * D - B * C;\n                long ux = B * F - E * D;\n                long uy = E * C - A * F;\n                if (down == 0 || ux % down != 0 || uy % down != 0) continue;\n                minX = Math.min(minX, (int) (ux / down));\n                maxX = Math.max(maxX, (int) (ux / down));\n                minY = Math.min(minY, (int) (uy / down));\n                maxY = Math.max(maxY, (int) (uy / down));\n                set.add(new Pair((int) (uy / down), (int) (ux / down)));\n            }\n        }\n        int x = (int) (maxX - minX + 1);\n        int y = (int) (maxY - minY + 1);\n        char[][] map = new char[y][x];\n        String[] answer = new String[y];\n\n        for (char[] m : map)\n            Arrays.fill(m, '.');\n\n        for (Pair p : set)\n            map[p.y - minY][p.x - minX] = '*';\n\n        for (int i = 0; i < y; i++) {\n            answer[i] = new String(map[y - 1 - i]);\n        }\n\n        return answer;\n    }\n\n    static class Pair implements Comparable<Pair> {\n        int y, x;\n\n        public Pair(int y, int x) {\n            this.y = y;\n            this.x = x;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Pair pair = (Pair) o;\n            return y == pair.y && x == pair.x;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(y, x);\n        }\n\n        @Override\n        public int compareTo(Pair o) {\n            if (y == o.y) {\n                return x - o.x;\n            }\n            return Integer.compare(y, o.y);\n        }\n    }\n\n}\n```\n\n### 실수했던 점\n공식이 주어져서 구현만 잘하면 되는 문제라고 생각했습니다.  \n하지만 테스트케이스 한 두개에서 계속 실패했습니다.  \n로직상으로 잘못된 부분이 없다고 생각해서 오래 고민했습니다.  \n그러다 찾은 문제는 자료형의 크기였습니다.  \n최대로 나올 수 있는 크기가 10만 * 10만이라 100억까지 가게됩니다.  \n음수로 처리되서 계속해서 잘못된 값이 나왔습니다.   \n코딩하기 전에 최대값을 계산하고 자료형을 선택해야겠습니다.  \n"},{"metadata":{"title":"[프로그래머스] 전력망을 둘로 나누기 (JAVA)","date":"2022-01-02 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-02-전력망을 둘로 나누기"},"content":"\n```java\npublic class Solution {\n\n    public int solution(int n, int[][] wires) {\n        int answer = 100;\n        for(int i = 0; i < n-1; i++){\n            DisjointSet set = new DisjointSet(n);\n            for(int j = 0; j < n-1; j++){\n                if(j == i) continue;\n                set.merge(wires[j][0], wires[j][1]);\n            }\n            int partialSize = set.getPartialSize();\n            answer = Math.min(answer, Math.abs(n - 2 * partialSize));\n        }\n        return answer;\n    }\n\n    static class DisjointSet{\n        int[] parents;\n        int[] rank;\n\n        public DisjointSet(int n){\n            parents = new int[n+1];\n            rank = new int[n+1];\n            for(int i = 1; i < n+1; i++){\n                parents[i] = i;\n                rank[i] = 1;\n            }\n        }\n\n        public int find(int u){\n            if(parents[u] == u) return u;\n            return parents[u] = find(parents[u]);\n        }\n\n        public void merge(int u, int v){\n            u = find(u);\n            v = find(v);\n            if(u == v) return;\n            parents[u] = v;\n        }\n\n        private int getPartialSize(){\n            int size = 0;\n            int partialParent = find(1);\n            for(int i = 1; i < parents.length; i++){\n                if(find(i) == partialParent)\n                    size++;\n            }\n            return size;\n        }\n    }\n}\n```\n\n### 실수했던 점\n각 집합의 루트를 찾아서 일치하는지 확인했어야 하는데 부모를 찾아서 비교했습니다.  \n부모가 부분적으로만 갱신되는 점을 생각하지 못했습니다.  \n일단 시간이 더 걸리더라도 확실한 방법으로 풀어야겠습니다.  "},{"metadata":{"title":"Union Find","date":"2022-01-02 00:45:00 +0900","category":"algorithm","tags":["algorithm"],"keywords":["algorithm"],"id":"2022-01-02-Union Find"},"content":"\n## Disjoint Set\nDisjoint Set은 상호 배타적 집합으로 서로 구분되는 집합입니다.\n각 집합은 중복되지 않은 원소의 집합으로 구성되어 있습니다.  \nDisjoint Set은 여러 자료구조로 표현할 수 있습니다.  \n\n### 배열로 표현하기\n가장 단순한 방법은 배열로 표현하는 것입니다.  \n시작은 크기가 1인 집합으로 자신의 값에 해당하는 위치를 표현합니다.  \n```java\narr[i] = i;\n```\n이후에 합쳐질 때마다 값을 바꿔주면 됩니다.  \n예를 들어 집합을 나타내는 기준을 더 작은 값이라고 두겠습니다.  \n1, 3, 5가 같은 집합이라면 배열의 1, 3, 5번은 1이 됩니다.  \n이런 식으로 구하다보면 제일 작은 기준으로 집합이 나눠집니다.  \n이때 찾는데 걸리는 시간은 배열 값을 보면 되므로 O(1)입니다.  \n문제는 합치는 데 걸리는 시간은 O(N)이 됩니다.  \n두 수가 주어질 때 다른 점들이 어느 집합에 있는지 모르기 때문에 전체를 돌아야 합니다.  \n그래서 찾는 시간은 빠르지만 이 방법보단 다른 방법을 사용합니다.  \n\n### 트리로 표현하기\n트리로 사용할 때는 자신의 부모를 따라 올라가 루트로 집합을 비교합니다.  \n따라서 찾기 연산은 루트를 찾는데 걸리는 시간이 됩니다.   \n합칠 때 두 집합의 루트 중 하나를 다른 하나의 루트로 만들면 되므로 배열보다 시간이 줄어듭니다.  \n이 때 찾기 연산은 잘 분포되어있다면 트리가 그렇듯 O(logN)이 됩니다.  \n하지만 균등하게 분포되어 있지않다면 O(N)이 됩니다.  \n\n## Union FInd\nDisjoint Set을 구현할 때 세 가지 연산이 필요합니다.  \n- 초기화 : 크기가 1인 원소들의 집합으로 초기화\n- 찾기 : 집합의 루트 찾기\n- 합치기 : 두 집합이 연결되어 있을 때 합치기\n여기서 찾기와 합치는 연산이 대표적이기에 Union Find라고 부릅니다.\n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n// 트리를 이용해 상호 배타적 집합을 구현한다.\npublic class NaiveDisjointSet {\n    List<Integer> parent;\n    public NaiveDisjointSet(int n){\n        this.parent = new ArrayList<>();\n        for(int i = 0; i < n; i++){\n            parent.add(i);\n        }\n    }\n    // u가 속한 트리의 루트를 반환한다.\n    int find(int u) {\n        if(u == parent.get(u)) return u;\n        return find(parent.get(u));\n    }\n    // u가 속한 트리와 v가 속한 트리를 합친다.\n    void merge(int u, int v){\n        u = find(u);\n        v = find(v);\n        // u와 v가 이미 같은 트리에 속하는 경우를 걸러낸다.\n        if(u == v) return;\n        parent.set(u, v);\n    }\n}\n```\n\n간단하게 만드는 경우 문제는 불균형하게 분포되었을 때입니다.  \n트리가 일직선으로 분포되는 경우로 시간 복잡도가 O(N)입니다.  \n배열로 만들었을 때도 O(1)인 걸 생각하면 사용할 이유가 없습니다.  \n그래서 사용하는 방법은 트리의 높이를 비교해서 합칩니다.  \n높은 트리가 낮은 트리의 부모가 된다면 일직선 분포를 막을 수 있습니다.  \n\n```java\nimport java.util.ArrayList;\nimport java.util.List;\n\n// 트리를 이용해 상호 배타적 집합을 구현한다.\npublic class OptimizedDisjointSet extends NaiveDisjointSet{\n\n  List<Integer> rank;\n\n  public OptimizedDisjointSet(int n) {\n    super(n);\n    rank = new ArrayList<>(n);\n    for(int i = 0; i < n; i++)\n      rank.add(1);\n  }\n\n  @Override\n  public int find(int u){\n    if(u == parent.get(u)) return u;\n    parent.set(u, find(parent.get(u)));\n    return parent.get(u);\n  }\n\n  @Override\n  public void merge(int u, int v) {\n    u = find(u);\n    v = find(v);\n    if(u == v) return;\n    if(rank.get(u) > rank.get(v)){\n      v = swap(u, u = v);\n    }\n    parent.set(u, v);\n    if(rank.get(u).equals(rank.get(v))){\n      rank.set(v, rank.get(v));\n    }\n  }\n\n  // y = swap(x, x = y)\n  private int swap(int a, int b){\n    return a;\n  }\n}\n```"}]},"__N_SSG":true}